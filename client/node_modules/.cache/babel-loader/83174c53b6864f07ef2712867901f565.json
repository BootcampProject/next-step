{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar uuid = require(\"uuid\");\n\nvar makeExecutableSchema_1 = require(\"./makeExecutableSchema\"); // This function wraps addMockFunctionsToSchema for more convenience\n\n\nfunction mockServer(schema, mocks, preserveResolvers) {\n  if (preserveResolvers === void 0) {\n    preserveResolvers = false;\n  }\n\n  var mySchema;\n\n  if (!(schema instanceof graphql_1.GraphQLSchema)) {\n    // TODO: provide useful error messages here if this fails\n    mySchema = makeExecutableSchema_1.buildSchemaFromTypeDefinitions(schema);\n  } else {\n    mySchema = schema;\n  }\n\n  addMockFunctionsToSchema({\n    schema: mySchema,\n    mocks: mocks,\n    preserveResolvers: preserveResolvers\n  });\n  return {\n    query: function (query, vars) {\n      return graphql_1.graphql(mySchema, query, {}, {}, vars);\n    }\n  };\n}\n\nexports.mockServer = mockServer;\nvar defaultMockMap = new Map();\ndefaultMockMap.set('Int', function () {\n  return Math.round(Math.random() * 200) - 100;\n});\ndefaultMockMap.set('Float', function () {\n  return Math.random() * 200 - 100;\n});\ndefaultMockMap.set('String', function () {\n  return 'Hello World';\n});\ndefaultMockMap.set('Boolean', function () {\n  return Math.random() > 0.5;\n});\ndefaultMockMap.set('ID', function () {\n  return uuid.v4();\n}); // TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\n\nfunction addMockFunctionsToSchema(_a) {\n  var schema = _a.schema,\n      _b = _a.mocks,\n      mocks = _b === void 0 ? {} : _b,\n      _c = _a.preserveResolvers,\n      preserveResolvers = _c === void 0 ? false : _c;\n\n  if (!schema) {\n    throw new Error('Must provide schema to mock');\n  }\n\n  if (!(schema instanceof graphql_1.GraphQLSchema)) {\n    throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n  }\n\n  if (!isObject(mocks)) {\n    throw new Error('mocks must be of type Object');\n  } // use Map internally, because that API is nicer.\n\n\n  var mockFunctionMap = new Map();\n  Object.keys(mocks).forEach(function (typeName) {\n    mockFunctionMap.set(typeName, mocks[typeName]);\n  });\n  mockFunctionMap.forEach(function (mockFunction, mockTypeName) {\n    if (typeof mockFunction !== 'function') {\n      throw new Error(\"mockFunctionMap[\" + mockTypeName + \"] must be a function\");\n    }\n  });\n\n  var mockType = function (type, typeName, fieldName) {\n    // order of precendence for mocking:\n    // 1. if the object passed in already has fieldName, just use that\n    // --> if it's a function, that becomes your resolver\n    // --> if it's a value, the mock resolver will return that\n    // 2. if the nullableType is a list, recurse\n    // 2. if there's a mock defined for this typeName, that will be used\n    // 3. if there's no mock defined, use the default mocks for this type\n    return function (root, args, context, info) {\n      // nullability doesn't matter for the purpose of mocking.\n      var fieldType = graphql_1.getNullableType(type);\n      var namedFieldType = graphql_1.getNamedType(fieldType);\n\n      if (root && typeof root[fieldName] !== 'undefined') {\n        var result = void 0; // if we're here, the field is already defined\n\n        if (typeof root[fieldName] === 'function') {\n          result = root[fieldName](root, args, context, info);\n\n          if (result instanceof MockList) {\n            result = result.mock(root, args, context, info, fieldType, mockType);\n          }\n        } else {\n          result = root[fieldName];\n        } // Now we merge the result with the default mock for this type.\n        // This allows overriding defaults while writing very little code.\n\n\n        if (mockFunctionMap.has(namedFieldType.name)) {\n          result = mergeMocks(mockFunctionMap.get(namedFieldType.name).bind(null, root, args, context, info), result);\n        }\n\n        return result;\n      }\n\n      if (fieldType instanceof graphql_1.GraphQLList || fieldType instanceof graphql_1.GraphQLNonNull) {\n        return [mockType(fieldType.ofType)(root, args, context, info), mockType(fieldType.ofType)(root, args, context, info)];\n      }\n\n      if (mockFunctionMap.has(fieldType.name) && !(fieldType instanceof graphql_1.GraphQLUnionType || fieldType instanceof graphql_1.GraphQLInterfaceType)) {\n        // the object passed doesn't have this field, so we apply the default mock\n        return mockFunctionMap.get(fieldType.name)(root, args, context, info);\n      }\n\n      if (fieldType instanceof graphql_1.GraphQLObjectType) {\n        // objects don't return actual data, we only need to mock scalars!\n        return {};\n      } // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n      // otherwise randomly pick a type from all implementation types\n\n\n      if (fieldType instanceof graphql_1.GraphQLUnionType || fieldType instanceof graphql_1.GraphQLInterfaceType) {\n        var implementationType = void 0;\n\n        if (mockFunctionMap.has(fieldType.name)) {\n          var interfaceMockObj = mockFunctionMap.get(fieldType.name)(root, args, context, info);\n\n          if (!interfaceMockObj || !interfaceMockObj.__typename) {\n            return Error(\"Please return a __typename in \\\"\" + fieldType.name + \"\\\"\");\n          }\n\n          implementationType = schema.getType(interfaceMockObj.__typename);\n        } else {\n          var possibleTypes = schema.getPossibleTypes(fieldType);\n          implementationType = getRandomElement(possibleTypes);\n        }\n\n        return Object.assign({\n          __typename: implementationType\n        }, mockType(implementationType)(root, args, context, info));\n      }\n\n      if (fieldType instanceof graphql_1.GraphQLEnumType) {\n        return getRandomElement(fieldType.getValues()).value;\n      }\n\n      if (defaultMockMap.has(fieldType.name)) {\n        return defaultMockMap.get(fieldType.name)(root, args, context, info);\n      } // if we get to here, we don't have a value, and we don't have a mock for this type,\n      // we could return undefined, but that would be hard to debug, so we throw instead.\n      // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n\n\n      return Error(\"No mock defined for type \\\"\" + fieldType.name + \"\\\"\");\n    };\n  };\n\n  makeExecutableSchema_1.forEachField(schema, function (field, typeName, fieldName) {\n    assignResolveType(field.type, preserveResolvers);\n    var mockResolver; // we have to handle the root mutation and root query types differently,\n    // because no resolver is called at the root.\n\n    /* istanbul ignore next: Must provide schema DefinitionNode with query type or a type named Query. */\n\n    var isOnQueryType = schema.getQueryType() && schema.getQueryType().name === typeName;\n    var isOnMutationType = schema.getMutationType() && schema.getMutationType().name === typeName;\n\n    if (isOnQueryType || isOnMutationType) {\n      if (mockFunctionMap.has(typeName)) {\n        var rootMock_1 = mockFunctionMap.get(typeName); // XXX: BUG in here, need to provide proper signature for rootMock.\n\n        if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] === 'function') {\n          mockResolver = function (root, args, context, info) {\n            var updatedRoot = root || {}; // TODO: should we clone instead?\n\n            updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName]; // XXX this is a bit of a hack to still use mockType, which\n            // lets you mock lists etc. as well\n            // otherwise we could just set field.resolve to rootMock()[fieldName]\n            // it's like pretending there was a resolve function that ran before\n            // the root resolve function.\n\n            return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);\n          };\n        }\n      }\n    }\n\n    if (!mockResolver) {\n      mockResolver = mockType(field.type, typeName, fieldName);\n    }\n\n    if (!preserveResolvers || !field.resolve) {\n      field.resolve = mockResolver;\n    } else {\n      var oldResolver_1 = field.resolve;\n\n      field.resolve = function (rootObject, args, context, info) {\n        return Promise.all([mockResolver(rootObject, args, context, info), oldResolver_1(rootObject, args, context, info)]).then(function (values) {\n          var mockedValue = values[0],\n              resolvedValue = values[1]; // In case we couldn't mock\n\n          if (mockedValue instanceof Error) {\n            // only if value was not resolved, populate the error.\n            if (undefined === resolvedValue) {\n              throw mockedValue;\n            }\n\n            return resolvedValue;\n          }\n\n          if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n            return undefined !== resolvedValue ? resolvedValue : mockedValue;\n          }\n\n          if (isObject(mockedValue) && isObject(resolvedValue)) {\n            // Object.assign() won't do here, as we need to all properties, including\n            // the non-enumerable ones and defined using Object.defineProperty\n            var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n            return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n          }\n\n          return undefined !== resolvedValue ? resolvedValue : mockedValue;\n        });\n      };\n    }\n  });\n}\n\nexports.addMockFunctionsToSchema = addMockFunctionsToSchema;\n\nfunction isObject(thing) {\n  return thing === Object(thing) && !Array.isArray(thing);\n} // returns a random element from that ary\n\n\nfunction getRandomElement(ary) {\n  var sample = Math.floor(Math.random() * ary.length);\n  return ary[sample];\n}\n\nfunction mergeObjects(a, b) {\n  return Object.assign(a, b);\n}\n\nfunction copyOwnPropsIfNotPresent(target, source) {\n  Object.getOwnPropertyNames(source).forEach(function (prop) {\n    if (!Object.getOwnPropertyDescriptor(target, prop)) {\n      Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));\n    }\n  });\n}\n\nfunction copyOwnProps(target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  sources.forEach(function (source) {\n    var chain = source;\n\n    while (chain) {\n      copyOwnPropsIfNotPresent(target, chain);\n      chain = Object.getPrototypeOf(chain);\n    }\n  });\n  return target;\n} // takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\n\n\nfunction mergeMocks(genericMockFunction, customMock) {\n  if (Array.isArray(customMock)) {\n    return customMock.map(function (el) {\n      return mergeMocks(genericMockFunction, el);\n    });\n  }\n\n  if (isObject(customMock)) {\n    return mergeObjects(genericMockFunction(), customMock);\n  }\n\n  return customMock;\n}\n\nfunction getResolveType(namedFieldType) {\n  if (namedFieldType instanceof graphql_1.GraphQLInterfaceType || namedFieldType instanceof graphql_1.GraphQLUnionType) {\n    return namedFieldType.resolveType;\n  } else {\n    return undefined;\n  }\n}\n\nfunction assignResolveType(type, preserveResolvers) {\n  var fieldType = graphql_1.getNullableType(type);\n  var namedFieldType = graphql_1.getNamedType(fieldType);\n  var oldResolveType = getResolveType(namedFieldType);\n\n  if (preserveResolvers && oldResolveType && oldResolveType.length) {\n    return;\n  }\n\n  if (namedFieldType instanceof graphql_1.GraphQLUnionType || namedFieldType instanceof graphql_1.GraphQLInterfaceType) {\n    // the default `resolveType` always returns null. We add a fallback\n    // resolution that works with how unions and interface are mocked\n    namedFieldType.resolveType = function (data, context, info) {\n      return info.schema.getType(data.__typename);\n    };\n  }\n}\n\nvar MockList =\n/** @class */\nfunction () {\n  // wrappedFunction can return another MockList or a value\n  function MockList(len, wrappedFunction) {\n    this.len = len;\n\n    if (typeof wrappedFunction !== 'undefined') {\n      if (typeof wrappedFunction !== 'function') {\n        throw new Error('Second argument to MockList must be a function or undefined');\n      }\n\n      this.wrappedFunction = wrappedFunction;\n    }\n  }\n\n  MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {\n    var arr;\n\n    if (Array.isArray(this.len)) {\n      arr = new Array(this.randint(this.len[0], this.len[1]));\n    } else {\n      arr = new Array(this.len);\n    }\n\n    for (var i = 0; i < arr.length; i++) {\n      if (typeof this.wrappedFunction === 'function') {\n        var res = this.wrappedFunction(root, args, context, info);\n\n        if (res instanceof MockList) {\n          var nullableType = graphql_1.getNullableType(fieldType.ofType);\n          arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);\n        } else {\n          arr[i] = res;\n        }\n      } else {\n        arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n      }\n    }\n\n    return arr;\n  };\n\n  MockList.prototype.randint = function (low, high) {\n    return Math.floor(Math.random() * (high - low + 1) + low);\n  };\n\n  return MockList;\n}();\n\nexports.MockList = MockList;","map":{"version":3,"sources":["../src/mock.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\nvar uuid = require(\"uuid\");\nvar makeExecutableSchema_1 = require(\"./makeExecutableSchema\");\n// This function wraps addMockFunctionsToSchema for more convenience\nfunction mockServer(schema, mocks, preserveResolvers) {\n    if (preserveResolvers === void 0) { preserveResolvers = false; }\n    var mySchema;\n    if (!(schema instanceof graphql_1.GraphQLSchema)) {\n        // TODO: provide useful error messages here if this fails\n        mySchema = makeExecutableSchema_1.buildSchemaFromTypeDefinitions(schema);\n    }\n    else {\n        mySchema = schema;\n    }\n    addMockFunctionsToSchema({ schema: mySchema, mocks: mocks, preserveResolvers: preserveResolvers });\n    return { query: function (query, vars) { return graphql_1.graphql(mySchema, query, {}, {}, vars); } };\n}\nexports.mockServer = mockServer;\nvar defaultMockMap = new Map();\ndefaultMockMap.set('Int', function () { return Math.round(Math.random() * 200) - 100; });\ndefaultMockMap.set('Float', function () { return Math.random() * 200 - 100; });\ndefaultMockMap.set('String', function () { return 'Hello World'; });\ndefaultMockMap.set('Boolean', function () { return Math.random() > 0.5; });\ndefaultMockMap.set('ID', function () { return uuid.v4(); });\n// TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\nfunction addMockFunctionsToSchema(_a) {\n    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;\n    if (!schema) {\n        throw new Error('Must provide schema to mock');\n    }\n    if (!(schema instanceof graphql_1.GraphQLSchema)) {\n        throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n    }\n    if (!isObject(mocks)) {\n        throw new Error('mocks must be of type Object');\n    }\n    // use Map internally, because that API is nicer.\n    var mockFunctionMap = new Map();\n    Object.keys(mocks).forEach(function (typeName) {\n        mockFunctionMap.set(typeName, mocks[typeName]);\n    });\n    mockFunctionMap.forEach(function (mockFunction, mockTypeName) {\n        if (typeof mockFunction !== 'function') {\n            throw new Error(\"mockFunctionMap[\" + mockTypeName + \"] must be a function\");\n        }\n    });\n    var mockType = function (type, typeName, fieldName) {\n        // order of precendence for mocking:\n        // 1. if the object passed in already has fieldName, just use that\n        // --> if it's a function, that becomes your resolver\n        // --> if it's a value, the mock resolver will return that\n        // 2. if the nullableType is a list, recurse\n        // 2. if there's a mock defined for this typeName, that will be used\n        // 3. if there's no mock defined, use the default mocks for this type\n        return function (root, args, context, info) {\n            // nullability doesn't matter for the purpose of mocking.\n            var fieldType = graphql_1.getNullableType(type);\n            var namedFieldType = graphql_1.getNamedType(fieldType);\n            if (root && typeof root[fieldName] !== 'undefined') {\n                var result = void 0;\n                // if we're here, the field is already defined\n                if (typeof root[fieldName] === 'function') {\n                    result = root[fieldName](root, args, context, info);\n                    if (result instanceof MockList) {\n                        result = result.mock(root, args, context, info, fieldType, mockType);\n                    }\n                }\n                else {\n                    result = root[fieldName];\n                }\n                // Now we merge the result with the default mock for this type.\n                // This allows overriding defaults while writing very little code.\n                if (mockFunctionMap.has(namedFieldType.name)) {\n                    result = mergeMocks(mockFunctionMap\n                        .get(namedFieldType.name)\n                        .bind(null, root, args, context, info), result);\n                }\n                return result;\n            }\n            if (fieldType instanceof graphql_1.GraphQLList ||\n                fieldType instanceof graphql_1.GraphQLNonNull) {\n                return [\n                    mockType(fieldType.ofType)(root, args, context, info),\n                    mockType(fieldType.ofType)(root, args, context, info),\n                ];\n            }\n            if (mockFunctionMap.has(fieldType.name) &&\n                !(fieldType instanceof graphql_1.GraphQLUnionType ||\n                    fieldType instanceof graphql_1.GraphQLInterfaceType)) {\n                // the object passed doesn't have this field, so we apply the default mock\n                return mockFunctionMap.get(fieldType.name)(root, args, context, info);\n            }\n            if (fieldType instanceof graphql_1.GraphQLObjectType) {\n                // objects don't return actual data, we only need to mock scalars!\n                return {};\n            }\n            // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n            // otherwise randomly pick a type from all implementation types\n            if (fieldType instanceof graphql_1.GraphQLUnionType ||\n                fieldType instanceof graphql_1.GraphQLInterfaceType) {\n                var implementationType = void 0;\n                if (mockFunctionMap.has(fieldType.name)) {\n                    var interfaceMockObj = mockFunctionMap.get(fieldType.name)(root, args, context, info);\n                    if (!interfaceMockObj || !interfaceMockObj.__typename) {\n                        return Error(\"Please return a __typename in \\\"\" + fieldType.name + \"\\\"\");\n                    }\n                    implementationType = schema.getType(interfaceMockObj.__typename);\n                }\n                else {\n                    var possibleTypes = schema.getPossibleTypes(fieldType);\n                    implementationType = getRandomElement(possibleTypes);\n                }\n                return Object.assign({ __typename: implementationType }, mockType(implementationType)(root, args, context, info));\n            }\n            if (fieldType instanceof graphql_1.GraphQLEnumType) {\n                return getRandomElement(fieldType.getValues()).value;\n            }\n            if (defaultMockMap.has(fieldType.name)) {\n                return defaultMockMap.get(fieldType.name)(root, args, context, info);\n            }\n            // if we get to here, we don't have a value, and we don't have a mock for this type,\n            // we could return undefined, but that would be hard to debug, so we throw instead.\n            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n            return Error(\"No mock defined for type \\\"\" + fieldType.name + \"\\\"\");\n        };\n    };\n    makeExecutableSchema_1.forEachField(schema, function (field, typeName, fieldName) {\n        assignResolveType(field.type, preserveResolvers);\n        var mockResolver;\n        // we have to handle the root mutation and root query types differently,\n        // because no resolver is called at the root.\n        /* istanbul ignore next: Must provide schema DefinitionNode with query type or a type named Query. */\n        var isOnQueryType = schema.getQueryType() && schema.getQueryType().name === typeName;\n        var isOnMutationType = schema.getMutationType() && schema.getMutationType().name === typeName;\n        if (isOnQueryType || isOnMutationType) {\n            if (mockFunctionMap.has(typeName)) {\n                var rootMock_1 = mockFunctionMap.get(typeName);\n                // XXX: BUG in here, need to provide proper signature for rootMock.\n                if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] === 'function') {\n                    mockResolver = function (root, args, context, info) {\n                        var updatedRoot = root || {}; // TODO: should we clone instead?\n                        updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName];\n                        // XXX this is a bit of a hack to still use mockType, which\n                        // lets you mock lists etc. as well\n                        // otherwise we could just set field.resolve to rootMock()[fieldName]\n                        // it's like pretending there was a resolve function that ran before\n                        // the root resolve function.\n                        return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);\n                    };\n                }\n            }\n        }\n        if (!mockResolver) {\n            mockResolver = mockType(field.type, typeName, fieldName);\n        }\n        if (!preserveResolvers || !field.resolve) {\n            field.resolve = mockResolver;\n        }\n        else {\n            var oldResolver_1 = field.resolve;\n            field.resolve = function (rootObject, args, context, info) {\n                return Promise.all([\n                    mockResolver(rootObject, args, context, info),\n                    oldResolver_1(rootObject, args, context, info),\n                ]).then(function (values) {\n                    var mockedValue = values[0], resolvedValue = values[1];\n                    // In case we couldn't mock\n                    if (mockedValue instanceof Error) {\n                        // only if value was not resolved, populate the error.\n                        if (undefined === resolvedValue) {\n                            throw mockedValue;\n                        }\n                        return resolvedValue;\n                    }\n                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n                        return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                    }\n                    if (isObject(mockedValue) && isObject(resolvedValue)) {\n                        // Object.assign() won't do here, as we need to all properties, including\n                        // the non-enumerable ones and defined using Object.defineProperty\n                        var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n                    }\n                    return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                });\n            };\n        }\n    });\n}\nexports.addMockFunctionsToSchema = addMockFunctionsToSchema;\nfunction isObject(thing) {\n    return thing === Object(thing) && !Array.isArray(thing);\n}\n// returns a random element from that ary\nfunction getRandomElement(ary) {\n    var sample = Math.floor(Math.random() * ary.length);\n    return ary[sample];\n}\nfunction mergeObjects(a, b) {\n    return Object.assign(a, b);\n}\nfunction copyOwnPropsIfNotPresent(target, source) {\n    Object.getOwnPropertyNames(source).forEach(function (prop) {\n        if (!Object.getOwnPropertyDescriptor(target, prop)) {\n            Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));\n        }\n    });\n}\nfunction copyOwnProps(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    sources.forEach(function (source) {\n        var chain = source;\n        while (chain) {\n            copyOwnPropsIfNotPresent(target, chain);\n            chain = Object.getPrototypeOf(chain);\n        }\n    });\n    return target;\n}\n// takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\nfunction mergeMocks(genericMockFunction, customMock) {\n    if (Array.isArray(customMock)) {\n        return customMock.map(function (el) { return mergeMocks(genericMockFunction, el); });\n    }\n    if (isObject(customMock)) {\n        return mergeObjects(genericMockFunction(), customMock);\n    }\n    return customMock;\n}\nfunction getResolveType(namedFieldType) {\n    if (namedFieldType instanceof graphql_1.GraphQLInterfaceType ||\n        namedFieldType instanceof graphql_1.GraphQLUnionType) {\n        return namedFieldType.resolveType;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction assignResolveType(type, preserveResolvers) {\n    var fieldType = graphql_1.getNullableType(type);\n    var namedFieldType = graphql_1.getNamedType(fieldType);\n    var oldResolveType = getResolveType(namedFieldType);\n    if (preserveResolvers && oldResolveType && oldResolveType.length) {\n        return;\n    }\n    if (namedFieldType instanceof graphql_1.GraphQLUnionType ||\n        namedFieldType instanceof graphql_1.GraphQLInterfaceType) {\n        // the default `resolveType` always returns null. We add a fallback\n        // resolution that works with how unions and interface are mocked\n        namedFieldType.resolveType = function (data, context, info) {\n            return info.schema.getType(data.__typename);\n        };\n    }\n}\nvar MockList = /** @class */ (function () {\n    // wrappedFunction can return another MockList or a value\n    function MockList(len, wrappedFunction) {\n        this.len = len;\n        if (typeof wrappedFunction !== 'undefined') {\n            if (typeof wrappedFunction !== 'function') {\n                throw new Error('Second argument to MockList must be a function or undefined');\n            }\n            this.wrappedFunction = wrappedFunction;\n        }\n    }\n    MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {\n        var arr;\n        if (Array.isArray(this.len)) {\n            arr = new Array(this.randint(this.len[0], this.len[1]));\n        }\n        else {\n            arr = new Array(this.len);\n        }\n        for (var i = 0; i < arr.length; i++) {\n            if (typeof this.wrappedFunction === 'function') {\n                var res = this.wrappedFunction(root, args, context, info);\n                if (res instanceof MockList) {\n                    var nullableType = graphql_1.getNullableType(fieldType.ofType);\n                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);\n                }\n                else {\n                    arr[i] = res;\n                }\n            }\n            else {\n                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n            }\n        }\n        return arr;\n    };\n    MockList.prototype.randint = function (low, high) {\n        return Math.floor(Math.random() * (high - low + 1) + low);\n    };\n    return MockList;\n}());\nexports.MockList = MockList;\n//# sourceMappingURL=mock.js.map"]},"metadata":{},"sourceType":"script"}