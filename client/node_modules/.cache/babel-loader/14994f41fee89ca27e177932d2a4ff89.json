{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar ReplaceFieldWithFragment =\n/** @class */\nfunction () {\n  function ReplaceFieldWithFragment(targetSchema, fragments) {\n    this.targetSchema = targetSchema;\n    this.mapping = {};\n\n    for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {\n      var _a = fragments_1[_i],\n          field = _a.field,\n          fragment = _a.fragment;\n      var parsedFragment = parseFragmentToInlineFragment(fragment);\n      var actualTypeName = parsedFragment.typeCondition.name.value;\n      this.mapping[actualTypeName] = this.mapping[actualTypeName] || {};\n\n      if (this.mapping[actualTypeName][field]) {\n        this.mapping[actualTypeName][field].push(parsedFragment);\n      } else {\n        this.mapping[actualTypeName][field] = [parsedFragment];\n      }\n    }\n  }\n\n  ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {\n    var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);\n    return __assign(__assign({}, originalRequest), {\n      document: document\n    });\n  };\n\n  return ReplaceFieldWithFragment;\n}();\n\nexports.default = ReplaceFieldWithFragment;\n\nfunction replaceFieldsWithFragments(targetSchema, document, mapping) {\n  var _a;\n\n  var typeInfo = new graphql_1.TypeInfo(targetSchema);\n  return graphql_1.visit(document, graphql_1.visitWithTypeInfo(typeInfo, (_a = {}, _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n    var parentType = typeInfo.getParentType();\n\n    if (parentType) {\n      var parentTypeName_1 = parentType.name;\n      var selections_1 = node.selections;\n\n      if (mapping[parentTypeName_1]) {\n        node.selections.forEach(function (selection) {\n          if (selection.kind === graphql_1.Kind.FIELD) {\n            var name_1 = selection.name.value;\n            var fragments = mapping[parentTypeName_1][name_1];\n\n            if (fragments && fragments.length > 0) {\n              var fragment = concatInlineFragments(parentTypeName_1, fragments);\n              selections_1 = selections_1.concat(fragment);\n            }\n          }\n        });\n      }\n\n      if (selections_1 !== node.selections) {\n        return __assign(__assign({}, node), {\n          selections: selections_1\n        });\n      }\n    }\n  }, _a)));\n}\n\nfunction parseFragmentToInlineFragment(definitions) {\n  if (definitions.trim().startsWith('fragment')) {\n    var document_1 = graphql_1.parse(definitions);\n\n    for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\n      var definition = _a[_i];\n\n      if (definition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {\n        return {\n          kind: graphql_1.Kind.INLINE_FRAGMENT,\n          typeCondition: definition.typeCondition,\n          selectionSet: definition.selectionSet\n        };\n      }\n    }\n  }\n\n  var query = graphql_1.parse(\"{\" + definitions + \"}\").definitions[0];\n\n  for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\n    var selection = _c[_b];\n\n    if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n      return selection;\n    }\n  }\n\n  throw new Error('Could not parse fragment');\n}\n\nfunction concatInlineFragments(type, fragments) {\n  var fragmentSelections = fragments.reduce(function (selections, fragment) {\n    return selections.concat(fragment.selectionSet.selections);\n  }, []);\n  var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);\n  return {\n    kind: graphql_1.Kind.INLINE_FRAGMENT,\n    typeCondition: {\n      kind: graphql_1.Kind.NAMED_TYPE,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: type\n      }\n    },\n    selectionSet: {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: deduplicatedFragmentSelection\n    }\n  };\n}\n\nfunction deduplicateSelection(nodes) {\n  var selectionMap = nodes.reduce(function (map, node) {\n    var _a, _b, _c;\n\n    switch (node.kind) {\n      case 'Field':\n        {\n          if (node.alias) {\n            if (map.hasOwnProperty(node.alias.value)) {\n              return map;\n            } else {\n              return __assign(__assign({}, map), (_a = {}, _a[node.alias.value] = node, _a));\n            }\n          } else {\n            if (map.hasOwnProperty(node.name.value)) {\n              return map;\n            } else {\n              return __assign(__assign({}, map), (_b = {}, _b[node.name.value] = node, _b));\n            }\n          }\n        }\n\n      case 'FragmentSpread':\n        {\n          if (map.hasOwnProperty(node.name.value)) {\n            return map;\n          } else {\n            return __assign(__assign({}, map), (_c = {}, _c[node.name.value] = node, _c));\n          }\n        }\n\n      case 'InlineFragment':\n        {\n          if (map.__fragment) {\n            var fragment = map.__fragment;\n            return __assign(__assign({}, map), {\n              __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node])\n            });\n          } else {\n            return __assign(__assign({}, map), {\n              __fragment: node\n            });\n          }\n        }\n\n      default:\n        {\n          return map;\n        }\n    }\n  }, {});\n  var selection = Object.keys(selectionMap).reduce(function (selectionList, node) {\n    return selectionList.concat(selectionMap[node]);\n  }, []);\n  return selection;\n}","map":{"version":3,"sources":["../../src/transforms/ReplaceFieldWithFragment.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\nvar ReplaceFieldWithFragment = /** @class */ (function () {\n    function ReplaceFieldWithFragment(targetSchema, fragments) {\n        this.targetSchema = targetSchema;\n        this.mapping = {};\n        for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {\n            var _a = fragments_1[_i], field = _a.field, fragment = _a.fragment;\n            var parsedFragment = parseFragmentToInlineFragment(fragment);\n            var actualTypeName = parsedFragment.typeCondition.name.value;\n            this.mapping[actualTypeName] = this.mapping[actualTypeName] || {};\n            if (this.mapping[actualTypeName][field]) {\n                this.mapping[actualTypeName][field].push(parsedFragment);\n            }\n            else {\n                this.mapping[actualTypeName][field] = [parsedFragment];\n            }\n        }\n    }\n    ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {\n        var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);\n        return __assign(__assign({}, originalRequest), { document: document });\n    };\n    return ReplaceFieldWithFragment;\n}());\nexports.default = ReplaceFieldWithFragment;\nfunction replaceFieldsWithFragments(targetSchema, document, mapping) {\n    var _a;\n    var typeInfo = new graphql_1.TypeInfo(targetSchema);\n    return graphql_1.visit(document, graphql_1.visitWithTypeInfo(typeInfo, (_a = {},\n        _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n            var parentType = typeInfo.getParentType();\n            if (parentType) {\n                var parentTypeName_1 = parentType.name;\n                var selections_1 = node.selections;\n                if (mapping[parentTypeName_1]) {\n                    node.selections.forEach(function (selection) {\n                        if (selection.kind === graphql_1.Kind.FIELD) {\n                            var name_1 = selection.name.value;\n                            var fragments = mapping[parentTypeName_1][name_1];\n                            if (fragments && fragments.length > 0) {\n                                var fragment = concatInlineFragments(parentTypeName_1, fragments);\n                                selections_1 = selections_1.concat(fragment);\n                            }\n                        }\n                    });\n                }\n                if (selections_1 !== node.selections) {\n                    return __assign(__assign({}, node), { selections: selections_1 });\n                }\n            }\n        },\n        _a)));\n}\nfunction parseFragmentToInlineFragment(definitions) {\n    if (definitions.trim().startsWith('fragment')) {\n        var document_1 = graphql_1.parse(definitions);\n        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\n            var definition = _a[_i];\n            if (definition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {\n                return {\n                    kind: graphql_1.Kind.INLINE_FRAGMENT,\n                    typeCondition: definition.typeCondition,\n                    selectionSet: definition.selectionSet,\n                };\n            }\n        }\n    }\n    var query = graphql_1.parse(\"{\" + definitions + \"}\")\n        .definitions[0];\n    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\n        var selection = _c[_b];\n        if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n            return selection;\n        }\n    }\n    throw new Error('Could not parse fragment');\n}\nfunction concatInlineFragments(type, fragments) {\n    var fragmentSelections = fragments.reduce(function (selections, fragment) {\n        return selections.concat(fragment.selectionSet.selections);\n    }, []);\n    var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);\n    return {\n        kind: graphql_1.Kind.INLINE_FRAGMENT,\n        typeCondition: {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: type,\n            },\n        },\n        selectionSet: {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: deduplicatedFragmentSelection,\n        },\n    };\n}\nfunction deduplicateSelection(nodes) {\n    var selectionMap = nodes.reduce(function (map, node) {\n        var _a, _b, _c;\n        switch (node.kind) {\n            case 'Field': {\n                if (node.alias) {\n                    if (map.hasOwnProperty(node.alias.value)) {\n                        return map;\n                    }\n                    else {\n                        return __assign(__assign({}, map), (_a = {}, _a[node.alias.value] = node, _a));\n                    }\n                }\n                else {\n                    if (map.hasOwnProperty(node.name.value)) {\n                        return map;\n                    }\n                    else {\n                        return __assign(__assign({}, map), (_b = {}, _b[node.name.value] = node, _b));\n                    }\n                }\n            }\n            case 'FragmentSpread': {\n                if (map.hasOwnProperty(node.name.value)) {\n                    return map;\n                }\n                else {\n                    return __assign(__assign({}, map), (_c = {}, _c[node.name.value] = node, _c));\n                }\n            }\n            case 'InlineFragment': {\n                if (map.__fragment) {\n                    var fragment = map.__fragment;\n                    return __assign(__assign({}, map), { __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node]) });\n                }\n                else {\n                    return __assign(__assign({}, map), { __fragment: node });\n                }\n            }\n            default: {\n                return map;\n            }\n        }\n    }, {});\n    var selection = Object.keys(selectionMap).reduce(function (selectionList, node) { return selectionList.concat(selectionMap[node]); }, []);\n    return selection;\n}\n//# sourceMappingURL=ReplaceFieldWithFragment.js.map"]},"metadata":{},"sourceType":"script"}