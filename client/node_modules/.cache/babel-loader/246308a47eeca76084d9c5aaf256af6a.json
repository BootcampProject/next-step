{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n/*\n * fn: The function to decorate with the logger\n * logger: an object instance of type Logger\n * hint: an optional hint to add to the error's message\n */\n\n\nfunction decorateWithLogger(fn, logger, hint) {\n  if (typeof fn === 'undefined') {\n    fn = graphql_1.defaultFieldResolver;\n  }\n\n  var logError = function (e) {\n    // TODO: clone the error properly\n    var newE = new Error();\n    newE.stack = e.stack;\n    /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n\n    if (hint) {\n      newE['originalMessage'] = e.message;\n      newE['message'] = \"Error in resolver \" + hint + \"\\n\" + e.message;\n    }\n\n    logger.log(newE);\n  };\n\n  return function (root, args, ctx, info) {\n    try {\n      var result = fn(root, args, ctx, info); // If the resolve function returns a Promise log any Promise rejects.\n\n      if (result && typeof result.then === 'function' && typeof result.catch === 'function') {\n        result.catch(function (reason) {\n          // make sure that it's an error we're logging.\n          var error = reason instanceof Error ? reason : new Error(reason);\n          logError(error); // We don't want to leave an unhandled exception so pass on error.\n\n          return reason;\n        });\n      }\n\n      return result;\n    } catch (e) {\n      logError(e); // we want to pass on the error, just in case.\n\n      throw e;\n    }\n  };\n}\n\nexports.default = decorateWithLogger;","map":{"version":3,"sources":["../../src/generate/decorateWithLogger.ts"],"names":[],"mappings":";;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAGA;;;;AAIG;;;AACH,SAAS,kBAAT,CACE,EADF,EAEE,MAFF,EAGE,IAHF,EAGc;AAEZ,MAAI,OAAO,EAAP,KAAc,WAAlB,EAA+B;AAC7B,IAAA,EAAE,GAAG,SAAA,CAAA,oBAAL;AACD;;AAED,MAAM,QAAQ,GAAG,UAAC,CAAD,EAAS;AACxB;AACA,QAAM,IAAI,GAAG,IAAI,KAAJ,EAAb;AACA,IAAA,IAAI,CAAC,KAAL,GAAa,CAAC,CAAC,KAAf;AACA;;AACA,QAAI,IAAJ,EAAU;AACR,MAAA,IAAI,CAAC,iBAAD,CAAJ,GAA0B,CAAC,CAAC,OAA5B;AACA,MAAA,IAAI,CAAC,SAAD,CAAJ,GAAkB,uBAAqB,IAArB,GAAyB,IAAzB,GAA8B,CAAC,CAAC,OAAlD;AACD;;AACD,IAAA,MAAM,CAAC,GAAP,CAAW,IAAX;AACD,GAVD;;AAYA,SAAO,UAAC,IAAD,EAAO,IAAP,EAAa,GAAb,EAAkB,IAAlB,EAAsB;AAC3B,QAAI;AACF,UAAM,MAAM,GAAG,EAAE,CAAC,IAAD,EAAO,IAAP,EAAa,GAAb,EAAkB,IAAlB,CAAjB,CADE,CAEF;;AACA,UACE,MAAM,IACN,OAAO,MAAM,CAAC,IAAd,KAAuB,UADvB,IAEA,OAAO,MAAM,CAAC,KAAd,KAAwB,UAH1B,EAIE;AACA,QAAA,MAAM,CAAC,KAAP,CAAa,UAAC,MAAD,EAAuB;AAClC;AACA,cAAM,KAAK,GAAG,MAAM,YAAY,KAAlB,GAA0B,MAA1B,GAAmC,IAAI,KAAJ,CAAU,MAAV,CAAjD;AACA,UAAA,QAAQ,CAAC,KAAD,CAAR,CAHkC,CAKlC;;AACA,iBAAO,MAAP;AACD,SAPD;AAQD;;AACD,aAAO,MAAP;AACD,KAlBD,CAkBE,OAAO,CAAP,EAAU;AACV,MAAA,QAAQ,CAAC,CAAD,CAAR,CADU,CAEV;;AACA,YAAM,CAAN;AACD;AACF,GAxBD;AAyBD;;AAED,OAAA,CAAA,OAAA,GAAe,kBAAf","sourceRoot":"","sourcesContent":["Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\n/*\n * fn: The function to decorate with the logger\n * logger: an object instance of type Logger\n * hint: an optional hint to add to the error's message\n */\nfunction decorateWithLogger(fn, logger, hint) {\n    if (typeof fn === 'undefined') {\n        fn = graphql_1.defaultFieldResolver;\n    }\n    var logError = function (e) {\n        // TODO: clone the error properly\n        var newE = new Error();\n        newE.stack = e.stack;\n        /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n        if (hint) {\n            newE['originalMessage'] = e.message;\n            newE['message'] = \"Error in resolver \" + hint + \"\\n\" + e.message;\n        }\n        logger.log(newE);\n    };\n    return function (root, args, ctx, info) {\n        try {\n            var result = fn(root, args, ctx, info);\n            // If the resolve function returns a Promise log any Promise rejects.\n            if (result &&\n                typeof result.then === 'function' &&\n                typeof result.catch === 'function') {\n                result.catch(function (reason) {\n                    // make sure that it's an error we're logging.\n                    var error = reason instanceof Error ? reason : new Error(reason);\n                    logError(error);\n                    // We don't want to leave an unhandled exception so pass on error.\n                    return reason;\n                });\n            }\n            return result;\n        }\n        catch (e) {\n            logError(e);\n            // we want to pass on the error, just in case.\n            throw e;\n        }\n    };\n}\nexports.default = decorateWithLogger;\n//# sourceMappingURL=decorateWithLogger.js.map"]},"metadata":{},"sourceType":"script"}