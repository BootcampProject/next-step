{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\"); // wraps all resolve functions of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolve funciton\n\n\nfunction addSchemaLevelResolveFunction(schema, fn) {\n  // TODO test that schema is a schema, fn is a function\n  var rootTypes = [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()].filter(function (x) {\n    return !!x;\n  });\n  rootTypes.forEach(function (type) {\n    // XXX this should run at most once per request to simulate a true root resolver\n    // for graphql-js this is an approximation that works with queries but not mutations\n    var rootResolveFn = runAtMostOncePerRequest(fn);\n    var fields = type.getFields();\n    Object.keys(fields).forEach(function (fieldName) {\n      // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n      // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n      if (type === schema.getSubscriptionType()) {\n        fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, fn);\n      } else {\n        fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, rootResolveFn);\n      }\n    });\n  });\n} // XXX badly named function. this doesn't really wrap, it just chains resolvers...\n\n\nfunction wrapResolver(innerResolver, outerResolver) {\n  return function (obj, args, ctx, info) {\n    return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {\n      if (innerResolver) {\n        return innerResolver(root, args, ctx, info);\n      }\n\n      return graphql_1.defaultFieldResolver(root, args, ctx, info);\n    });\n  };\n} // XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\n\n\nfunction runAtMostOncePerRequest(fn) {\n  var value;\n  var randomNumber = Math.random();\n  return function (root, args, ctx, info) {\n    if (!info.operation['__runAtMostOnce']) {\n      info.operation['__runAtMostOnce'] = {};\n    }\n\n    if (!info.operation['__runAtMostOnce'][randomNumber]) {\n      info.operation['__runAtMostOnce'][randomNumber] = true;\n      value = fn(root, args, ctx, info);\n    }\n\n    return value;\n  };\n}\n\nexports.default = addSchemaLevelResolveFunction;","map":{"version":3,"sources":["../../src/generate/addSchemaLevelResolveFunction.ts"],"names":[],"mappings":";;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA,C,CAMA;AACA;;;AACA,SAAS,6BAAT,CACE,MADF,EAEE,EAFF,EAEoC;AAElC;AACA,MAAM,SAAS,GAAG,CAChB,MAAM,CAAC,YAAP,EADgB,EAEhB,MAAM,CAAC,eAAP,EAFgB,EAGhB,MAAM,CAAC,mBAAP,EAHgB,EAIhB,MAJgB,CAIT,UAAA,CAAA,EAAC;AAAI,WAAA,CAAC,CAAD,CAAA;AAAG,GAJC,CAAlB;AAKA,EAAA,SAAS,CAAC,OAAV,CAAkB,UAAA,IAAA,EAAI;AACpB;AACA;AACA,QAAM,aAAa,GAAG,uBAAuB,CAAC,EAAD,CAA7C;AACA,QAAM,MAAM,GAAG,IAAI,CAAC,SAAL,EAAf;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,OAApB,CAA4B,UAAA,SAAA,EAAS;AACnC;AACA;AACA,UAAI,IAAI,KAAK,MAAM,CAAC,mBAAP,EAAb,EAA2C;AACzC,QAAA,MAAM,CAAC,SAAD,CAAN,CAAkB,OAAlB,GAA4B,YAAY,CAAC,MAAM,CAAC,SAAD,CAAN,CAAkB,OAAnB,EAA4B,EAA5B,CAAxC;AACD,OAFD,MAEO;AACL,QAAA,MAAM,CAAC,SAAD,CAAN,CAAkB,OAAlB,GAA4B,YAAY,CACtC,MAAM,CAAC,SAAD,CAAN,CAAkB,OADoB,EAEtC,aAFsC,CAAxC;AAID;AACF,KAXD;AAYD,GAjBD;AAkBD,C,CAED;;;AACA,SAAS,YAAT,CACE,aADF,EAEE,aAFF,EAE+C;AAE7C,SAAO,UAAC,GAAD,EAAM,IAAN,EAAY,GAAZ,EAAiB,IAAjB,EAAqB;AAC1B,WAAO,OAAO,CAAC,OAAR,CAAgB,aAAa,CAAC,GAAD,EAAM,IAAN,EAAY,GAAZ,EAAiB,IAAjB,CAA7B,EAAqD,IAArD,CAA0D,UAAA,IAAA,EAAI;AACnE,UAAI,aAAJ,EAAmB;AACjB,eAAO,aAAa,CAAC,IAAD,EAAO,IAAP,EAAa,GAAb,EAAkB,IAAlB,CAApB;AACD;;AACD,aAAO,SAAA,CAAA,oBAAA,CAAqB,IAArB,EAA2B,IAA3B,EAAiC,GAAjC,EAAsC,IAAtC,CAAP;AACD,KALM,CAAP;AAMD,GAPD;AAQD,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS,uBAAT,CACE,EADF,EACoC;AAElC,MAAI,KAAJ;AACA,MAAM,YAAY,GAAG,IAAI,CAAC,MAAL,EAArB;AACA,SAAO,UAAC,IAAD,EAAO,IAAP,EAAa,GAAb,EAAkB,IAAlB,EAAsB;AAC3B,QAAI,CAAC,IAAI,CAAC,SAAL,CAAe,iBAAf,CAAL,EAAwC;AACtC,MAAA,IAAI,CAAC,SAAL,CAAe,iBAAf,IAAoC,EAApC;AACD;;AACD,QAAI,CAAC,IAAI,CAAC,SAAL,CAAe,iBAAf,EAAkC,YAAlC,CAAL,EAAsD;AACpD,MAAA,IAAI,CAAC,SAAL,CAAe,iBAAf,EAAkC,YAAlC,IAAkD,IAAlD;AACA,MAAA,KAAK,GAAG,EAAE,CAAC,IAAD,EAAO,IAAP,EAAa,GAAb,EAAkB,IAAlB,CAAV;AACD;;AACD,WAAO,KAAP;AACD,GATD;AAUD;;AAED,OAAA,CAAA,OAAA,GAAe,6BAAf","sourceRoot":"","sourcesContent":["Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\n// wraps all resolve functions of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolve funciton\nfunction addSchemaLevelResolveFunction(schema, fn) {\n    // TODO test that schema is a schema, fn is a function\n    var rootTypes = [\n        schema.getQueryType(),\n        schema.getMutationType(),\n        schema.getSubscriptionType(),\n    ].filter(function (x) { return !!x; });\n    rootTypes.forEach(function (type) {\n        // XXX this should run at most once per request to simulate a true root resolver\n        // for graphql-js this is an approximation that works with queries but not mutations\n        var rootResolveFn = runAtMostOncePerRequest(fn);\n        var fields = type.getFields();\n        Object.keys(fields).forEach(function (fieldName) {\n            // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n            // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n            if (type === schema.getSubscriptionType()) {\n                fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, fn);\n            }\n            else {\n                fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, rootResolveFn);\n            }\n        });\n    });\n}\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(innerResolver, outerResolver) {\n    return function (obj, args, ctx, info) {\n        return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {\n            if (innerResolver) {\n                return innerResolver(root, args, ctx, info);\n            }\n            return graphql_1.defaultFieldResolver(root, args, ctx, info);\n        });\n    };\n}\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(fn) {\n    var value;\n    var randomNumber = Math.random();\n    return function (root, args, ctx, info) {\n        if (!info.operation['__runAtMostOnce']) {\n            info.operation['__runAtMostOnce'] = {};\n        }\n        if (!info.operation['__runAtMostOnce'][randomNumber]) {\n            info.operation['__runAtMostOnce'][randomNumber] = true;\n            value = fn(root, args, ctx, info);\n        }\n        return value;\n    };\n}\nexports.default = addSchemaLevelResolveFunction;\n//# sourceMappingURL=addSchemaLevelResolveFunction.js.map"]},"metadata":{},"sourceType":"script"}