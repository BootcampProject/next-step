{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.iterateOverTrace = void 0;\n\nfunction iterateOverTrace(trace, f, includePath) {\n  const rootPath = includePath ? new RootCollectingPathsResponseNamePath() : notCollectingPathsResponseNamePath;\n\n  if (trace.root) {\n    if (iterateOverTraceNode(trace.root, rootPath, f)) return;\n  }\n\n  if (trace.queryPlan) {\n    if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;\n  }\n}\n\nexports.iterateOverTrace = iterateOverTrace;\n\nfunction iterateOverQueryPlan(node, rootPath, f) {\n  var _a, _b, _c, _d, _e;\n\n  if (!node) return false;\n\n  if (((_b = (_a = node.fetch) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.root) && node.fetch.serviceName) {\n    return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);\n  }\n\n  if ((_c = node.flatten) === null || _c === void 0 ? void 0 : _c.node) {\n    return iterateOverQueryPlan(node.flatten.node, rootPath, f);\n  }\n\n  if ((_d = node.parallel) === null || _d === void 0 ? void 0 : _d.nodes) {\n    return node.parallel.nodes.some(node => iterateOverQueryPlan(node, rootPath, f));\n  }\n\n  if ((_e = node.sequence) === null || _e === void 0 ? void 0 : _e.nodes) {\n    return node.sequence.nodes.some(node => iterateOverQueryPlan(node, rootPath, f));\n  }\n\n  return false;\n}\n\nfunction iterateOverTraceNode(node, path, f) {\n  var _a, _b;\n\n  if (f(node, path)) {\n    return true;\n  }\n\n  return (_b = (_a = node.child) === null || _a === void 0 ? void 0 : _a.some(child => {\n    const childPath = child.responseName ? path.child(child.responseName) : path;\n    return iterateOverTraceNode(child, childPath, f);\n  })) !== null && _b !== void 0 ? _b : false;\n}\n\nconst notCollectingPathsResponseNamePath = {\n  toArray() {\n    throw Error('not collecting paths!');\n  },\n\n  child() {\n    return this;\n  }\n\n};\n\nclass RootCollectingPathsResponseNamePath {\n  toArray() {\n    return [];\n  }\n\n  child(responseName) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n\n}\n\nclass ChildCollectingPathsResponseNamePath {\n  constructor(responseName, prev) {\n    this.responseName = responseName;\n    this.prev = prev;\n  }\n\n  toArray() {\n    const out = [];\n    let curr = this;\n\n    while (curr instanceof ChildCollectingPathsResponseNamePath) {\n      out.push(curr.responseName);\n      curr = curr.prev;\n    }\n\n    return out.reverse();\n  }\n\n  child(responseName) {\n    return new ChildCollectingPathsResponseNamePath(responseName, this);\n  }\n\n}","map":{"version":3,"sources":["../../../src/plugin/usageReporting/iterateOverTrace.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.iterateOverTrace = void 0;\nfunction iterateOverTrace(trace, f, includePath) {\n    const rootPath = includePath\n        ? new RootCollectingPathsResponseNamePath()\n        : notCollectingPathsResponseNamePath;\n    if (trace.root) {\n        if (iterateOverTraceNode(trace.root, rootPath, f))\n            return;\n    }\n    if (trace.queryPlan) {\n        if (iterateOverQueryPlan(trace.queryPlan, rootPath, f))\n            return;\n    }\n}\nexports.iterateOverTrace = iterateOverTrace;\nfunction iterateOverQueryPlan(node, rootPath, f) {\n    var _a, _b, _c, _d, _e;\n    if (!node)\n        return false;\n    if (((_b = (_a = node.fetch) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.root) && node.fetch.serviceName) {\n        return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);\n    }\n    if ((_c = node.flatten) === null || _c === void 0 ? void 0 : _c.node) {\n        return iterateOverQueryPlan(node.flatten.node, rootPath, f);\n    }\n    if ((_d = node.parallel) === null || _d === void 0 ? void 0 : _d.nodes) {\n        return node.parallel.nodes.some((node) => iterateOverQueryPlan(node, rootPath, f));\n    }\n    if ((_e = node.sequence) === null || _e === void 0 ? void 0 : _e.nodes) {\n        return node.sequence.nodes.some((node) => iterateOverQueryPlan(node, rootPath, f));\n    }\n    return false;\n}\nfunction iterateOverTraceNode(node, path, f) {\n    var _a, _b;\n    if (f(node, path)) {\n        return true;\n    }\n    return ((_b = (_a = node.child) === null || _a === void 0 ? void 0 : _a.some((child) => {\n        const childPath = child.responseName\n            ? path.child(child.responseName)\n            : path;\n        return iterateOverTraceNode(child, childPath, f);\n    })) !== null && _b !== void 0 ? _b : false);\n}\nconst notCollectingPathsResponseNamePath = {\n    toArray() {\n        throw Error('not collecting paths!');\n    },\n    child() {\n        return this;\n    },\n};\nclass RootCollectingPathsResponseNamePath {\n    toArray() {\n        return [];\n    }\n    child(responseName) {\n        return new ChildCollectingPathsResponseNamePath(responseName, this);\n    }\n}\nclass ChildCollectingPathsResponseNamePath {\n    constructor(responseName, prev) {\n        this.responseName = responseName;\n        this.prev = prev;\n    }\n    toArray() {\n        const out = [];\n        let curr = this;\n        while (curr instanceof ChildCollectingPathsResponseNamePath) {\n            out.push(curr.responseName);\n            curr = curr.prev;\n        }\n        return out.reverse();\n    }\n    child(responseName) {\n        return new ChildCollectingPathsResponseNamePath(responseName, this);\n    }\n}\n//# sourceMappingURL=iterateOverTrace.js.map"]},"metadata":{},"sourceType":"script"}