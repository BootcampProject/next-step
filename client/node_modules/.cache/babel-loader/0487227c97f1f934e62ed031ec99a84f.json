{"ast":null,"code":"\"use strict\";\n\nmodule.exports = asPromise;\n/**\n * Callback as used by {@link util.asPromise}.\n * @typedef asPromiseCallback\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {...*} params Additional arguments\n * @returns {undefined}\n */\n\n/**\n * Returns a promise from a node-style callback function.\n * @memberof util\n * @param {asPromiseCallback} fn Function to call\n * @param {*} ctx Function context\n * @param {...*} params Function arguments\n * @returns {Promise<*>} Promisified function\n */\n\nfunction asPromise(fn, ctx\n/*, varargs */\n) {\n  var params = new Array(arguments.length - 1),\n      offset = 0,\n      index = 2,\n      pending = true;\n\n  while (index < arguments.length) params[offset++] = arguments[index++];\n\n  return new Promise(function executor(resolve, reject) {\n    params[offset] = function callback(err\n    /*, varargs */\n    ) {\n      if (pending) {\n        pending = false;\n        if (err) reject(err);else {\n          var params = new Array(arguments.length - 1),\n              offset = 0;\n\n          while (offset < params.length) params[offset++] = arguments[offset];\n\n          resolve.apply(null, params);\n        }\n      }\n    };\n\n    try {\n      fn.apply(ctx || null, params);\n    } catch (err) {\n      if (pending) {\n        pending = false;\n        reject(err);\n      }\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/Sallam/Desktop/projects/next-step/server/node_modules/@protobufjs/aspromise/index.js"],"names":["module","exports","asPromise","fn","ctx","params","Array","arguments","length","offset","index","pending","Promise","executor","resolve","reject","callback","err","apply"],"mappings":"AAAA;;AACAA,MAAM,CAACC,OAAP,GAAiBC,SAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,SAAT,CAAmBC,EAAnB,EAAuBC;AAAG;AAA1B,EAA0C;AACtC,MAAIC,MAAM,GAAI,IAAIC,KAAJ,CAAUC,SAAS,CAACC,MAAV,GAAmB,CAA7B,CAAd;AAAA,MACIC,MAAM,GAAI,CADd;AAAA,MAEIC,KAAK,GAAK,CAFd;AAAA,MAGIC,OAAO,GAAG,IAHd;;AAIA,SAAOD,KAAK,GAAGH,SAAS,CAACC,MAAzB,EACIH,MAAM,CAACI,MAAM,EAAP,CAAN,GAAmBF,SAAS,CAACG,KAAK,EAAN,CAA5B;;AACJ,SAAO,IAAIE,OAAJ,CAAY,SAASC,QAAT,CAAkBC,OAAlB,EAA2BC,MAA3B,EAAmC;AAClDV,IAAAA,MAAM,CAACI,MAAD,CAAN,GAAiB,SAASO,QAAT,CAAkBC;AAAG;AAArB,MAAqC;AAClD,UAAIN,OAAJ,EAAa;AACTA,QAAAA,OAAO,GAAG,KAAV;AACA,YAAIM,GAAJ,EACIF,MAAM,CAACE,GAAD,CAAN,CADJ,KAEK;AACD,cAAIZ,MAAM,GAAG,IAAIC,KAAJ,CAAUC,SAAS,CAACC,MAAV,GAAmB,CAA7B,CAAb;AAAA,cACIC,MAAM,GAAG,CADb;;AAEA,iBAAOA,MAAM,GAAGJ,MAAM,CAACG,MAAvB,EACIH,MAAM,CAACI,MAAM,EAAP,CAAN,GAAmBF,SAAS,CAACE,MAAD,CAA5B;;AACJK,UAAAA,OAAO,CAACI,KAAR,CAAc,IAAd,EAAoBb,MAApB;AACH;AACJ;AACJ,KAbD;;AAcA,QAAI;AACAF,MAAAA,EAAE,CAACe,KAAH,CAASd,GAAG,IAAI,IAAhB,EAAsBC,MAAtB;AACH,KAFD,CAEE,OAAOY,GAAP,EAAY;AACV,UAAIN,OAAJ,EAAa;AACTA,QAAAA,OAAO,GAAG,KAAV;AACAI,QAAAA,MAAM,CAACE,GAAD,CAAN;AACH;AACJ;AACJ,GAvBM,CAAP;AAwBH","sourcesContent":["\"use strict\";\nmodule.exports = asPromise;\n\n/**\n * Callback as used by {@link util.asPromise}.\n * @typedef asPromiseCallback\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {...*} params Additional arguments\n * @returns {undefined}\n */\n\n/**\n * Returns a promise from a node-style callback function.\n * @memberof util\n * @param {asPromiseCallback} fn Function to call\n * @param {*} ctx Function context\n * @param {...*} params Function arguments\n * @returns {Promise<*>} Promisified function\n */\nfunction asPromise(fn, ctx/*, varargs */) {\n    var params  = new Array(arguments.length - 1),\n        offset  = 0,\n        index   = 2,\n        pending = true;\n    while (index < arguments.length)\n        params[offset++] = arguments[index++];\n    return new Promise(function executor(resolve, reject) {\n        params[offset] = function callback(err/*, varargs */) {\n            if (pending) {\n                pending = false;\n                if (err)\n                    reject(err);\n                else {\n                    var params = new Array(arguments.length - 1),\n                        offset = 0;\n                    while (offset < params.length)\n                        params[offset++] = arguments[offset];\n                    resolve.apply(null, params);\n                }\n            }\n        };\n        try {\n            fn.apply(ctx || null, params);\n        } catch (err) {\n            if (pending) {\n                pending = false;\n                reject(err);\n            }\n        }\n    });\n}\n"]},"metadata":{},"sourceType":"script"}