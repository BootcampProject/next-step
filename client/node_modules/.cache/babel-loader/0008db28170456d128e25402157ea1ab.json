{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultSendOperationsAsTrace = void 0;\n\nconst lru_cache_1 = __importDefault(require(\"lru-cache\"));\n\nconst iterateOverTrace_1 = require(\"./iterateOverTrace\");\n\nconst durationHistogram_1 = require(\"./durationHistogram\");\n\nfunction defaultSendOperationsAsTrace() {\n  const cache = new lru_cache_1.default({\n    max: Math.pow(2, 20),\n    length: (_val, key) => {\n      return key && Buffer.byteLength(key) || 0;\n    }\n  });\n  return (trace, statsReportKey) => {\n    var _a;\n\n    const endTimeSeconds = (_a = trace.endTime) === null || _a === void 0 ? void 0 : _a.seconds;\n\n    if (endTimeSeconds == null) {\n      throw Error('programming error: endTime not set on trace');\n    }\n\n    const hasErrors = traceHasErrors(trace);\n    const cacheKey = JSON.stringify([statsReportKey, durationHistogram_1.DurationHistogram.durationToBucket(trace.durationNs), Math.floor(endTimeSeconds / 60), hasErrors ? Math.floor(endTimeSeconds / 5) : '']);\n\n    if (cache.get(cacheKey)) {\n      return false;\n    }\n\n    cache.set(cacheKey, true);\n    return true;\n  };\n}\n\nexports.defaultSendOperationsAsTrace = defaultSendOperationsAsTrace;\n\nfunction traceHasErrors(trace) {\n  let hasErrors = false;\n\n  function traceNodeStats(node) {\n    var _a, _b;\n\n    if (((_b = (_a = node.error) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {\n      hasErrors = true;\n    }\n\n    return hasErrors;\n  }\n\n  iterateOverTrace_1.iterateOverTrace(trace, traceNodeStats, false);\n  return hasErrors;\n}","map":{"version":3,"sources":["../../../src/plugin/usageReporting/defaultSendOperationsAsTrace.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAEA,MAAA,kBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AACA,MAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAEA,SAAgB,4BAAhB,GAA4C;AAO1C,QAAM,KAAK,GAAG,IAAI,WAAA,CAAA,OAAJ,CAA2B;AAWvC,IAAA,GAAG,EAAE,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,EAAZ,CAXkC;AAYvC,IAAA,MAAM,EAAE,CAAC,IAAD,EAAO,GAAP,KAAc;AACpB,aAAQ,GAAG,IAAI,MAAM,CAAC,UAAP,CAAkB,GAAlB,CAAR,IAAmC,CAA1C;AACD;AAdsC,GAA3B,CAAd;AAiBA,SAAO,CAAC,KAAD,EAAe,cAAf,KAAkD;;;AACvD,UAAM,cAAc,GAAA,CAAA,EAAA,GAAG,KAAK,CAAC,OAAT,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAgB,EAAA,CAAE,OAAtC;;AACA,QAAI,cAAc,IAAI,IAAtB,EAA4B;AAC1B,YAAM,KAAK,CAAC,6CAAD,CAAX;AACD;;AAED,UAAM,SAAS,GAAG,cAAc,CAAC,KAAD,CAAhC;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,SAAL,CAAe,CAC9B,cAD8B,EAE9B,mBAAA,CAAA,iBAAA,CAAkB,gBAAlB,CAAmC,KAAK,CAAC,UAAzC,CAF8B,EAI9B,IAAI,CAAC,KAAL,CAAW,cAAc,GAAG,EAA5B,CAJ8B,EAO9B,SAAS,GAAG,IAAI,CAAC,KAAL,CAAW,cAAc,GAAG,CAA5B,CAAH,GAAoC,EAPf,CAAf,CAAjB;;AAWA,QAAI,KAAK,CAAC,GAAN,CAAU,QAAV,CAAJ,EAAyB;AACvB,aAAO,KAAP;AACD;;AAED,IAAA,KAAK,CAAC,GAAN,CAAU,QAAV,EAAoB,IAApB;AACA,WAAO,IAAP;AACD,GAxBD;AAyBD;;AAjDD,OAAA,CAAA,4BAAA,GAAA,4BAAA;;AAqDA,SAAS,cAAT,CAAwB,KAAxB,EAAoC;AAClC,MAAI,SAAS,GAAG,KAAhB;;AAEA,WAAS,cAAT,CAAwB,IAAxB,EAAyC;;;AACvC,QAAI,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAC,IAAI,CAAC,KAAN,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,MAAb,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,EAAnB,GAAuB,CAAvB,IAA4B,CAAhC,EAAmC;AACjC,MAAA,SAAS,GAAG,IAAZ;AACD;;AACD,WAAO,SAAP;AACD;;AAED,EAAA,kBAAA,CAAA,gBAAA,CAAiB,KAAjB,EAAwB,cAAxB,EAAwC,KAAxC;AACA,SAAO,SAAP;AACD","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultSendOperationsAsTrace = void 0;\nconst lru_cache_1 = __importDefault(require(\"lru-cache\"));\nconst iterateOverTrace_1 = require(\"./iterateOverTrace\");\nconst durationHistogram_1 = require(\"./durationHistogram\");\nfunction defaultSendOperationsAsTrace() {\n    const cache = new lru_cache_1.default({\n        max: Math.pow(2, 20),\n        length: (_val, key) => {\n            return (key && Buffer.byteLength(key)) || 0;\n        },\n    });\n    return (trace, statsReportKey) => {\n        var _a;\n        const endTimeSeconds = (_a = trace.endTime) === null || _a === void 0 ? void 0 : _a.seconds;\n        if (endTimeSeconds == null) {\n            throw Error('programming error: endTime not set on trace');\n        }\n        const hasErrors = traceHasErrors(trace);\n        const cacheKey = JSON.stringify([\n            statsReportKey,\n            durationHistogram_1.DurationHistogram.durationToBucket(trace.durationNs),\n            Math.floor(endTimeSeconds / 60),\n            hasErrors ? Math.floor(endTimeSeconds / 5) : '',\n        ]);\n        if (cache.get(cacheKey)) {\n            return false;\n        }\n        cache.set(cacheKey, true);\n        return true;\n    };\n}\nexports.defaultSendOperationsAsTrace = defaultSendOperationsAsTrace;\nfunction traceHasErrors(trace) {\n    let hasErrors = false;\n    function traceNodeStats(node) {\n        var _a, _b;\n        if (((_b = (_a = node.error) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {\n            hasErrors = true;\n        }\n        return hasErrors;\n    }\n    iterateOverTrace_1.iterateOverTrace(trace, traceNodeStats, false);\n    return hasErrors;\n}\n//# sourceMappingURL=defaultSendOperationsAsTrace.js.map"]},"metadata":{},"sourceType":"script"}