{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar error_1 = require(\"graphql/error\");\n\nvar errors_1 = require(\"./errors\");\n\nvar getResponseKeyFromInfo_1 = require(\"./getResponseKeyFromInfo\"); // Resolver that knows how to:\n// a) handle aliases for proxied schemas\n// b) handle errors from proxied schemas\n\n\nvar defaultMergedResolver = function (parent, args, context, info) {\n  if (!parent) {\n    return null;\n  }\n\n  var responseKey = getResponseKeyFromInfo_1.getResponseKeyFromInfo(info);\n  var errorResult = errors_1.getErrorsFromParent(parent, responseKey);\n\n  if (errorResult.kind === 'OWN') {\n    throw error_1.locatedError(new Error(errorResult.error.message), info.fieldNodes, graphql_1.responsePathAsArray(info.path));\n  }\n\n  var result = parent[responseKey];\n\n  if (result == null) {\n    result = parent[info.fieldName];\n  } // subscription result mapping\n\n\n  if (!result && parent.data && parent.data[responseKey]) {\n    result = parent.data[responseKey];\n  }\n\n  if (errorResult.errors) {\n    result = errors_1.annotateWithChildrenErrors(result, errorResult.errors);\n  }\n\n  return result;\n};\n\nexports.default = defaultMergedResolver;","map":{"version":3,"sources":["../../src/stitching/defaultMergedResolver.ts"],"names":[],"mappings":";;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,wBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA,C,CAEA;AACA;AACA;;;AACA,IAAM,qBAAqB,GAAmC,UAAC,MAAD,EAAS,IAAT,EAAe,OAAf,EAAwB,IAAxB,EAA4B;AACxF,MAAI,CAAC,MAAL,EAAa;AACX,WAAO,IAAP;AACD;;AAED,MAAM,WAAW,GAAG,wBAAA,CAAA,sBAAA,CAAuB,IAAvB,CAApB;AACA,MAAM,WAAW,GAAG,QAAA,CAAA,mBAAA,CAAoB,MAApB,EAA4B,WAA5B,CAApB;;AAEA,MAAI,WAAW,CAAC,IAAZ,KAAqB,KAAzB,EAAgC;AAC9B,UAAM,OAAA,CAAA,YAAA,CAAa,IAAI,KAAJ,CAAU,WAAW,CAAC,KAAZ,CAAkB,OAA5B,CAAb,EAAmD,IAAI,CAAC,UAAxD,EAAoE,SAAA,CAAA,mBAAA,CAAoB,IAAI,CAAC,IAAzB,CAApE,CAAN;AACD;;AAED,MAAI,MAAM,GAAG,MAAM,CAAC,WAAD,CAAnB;;AAEA,MAAI,MAAM,IAAI,IAAd,EAAoB;AAClB,IAAA,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,SAAN,CAAf;AACD,GAhBuF,CAkBxF;;;AACA,MAAI,CAAC,MAAD,IAAW,MAAM,CAAC,IAAlB,IAA0B,MAAM,CAAC,IAAP,CAAY,WAAZ,CAA9B,EAAwD;AACtD,IAAA,MAAM,GAAG,MAAM,CAAC,IAAP,CAAY,WAAZ,CAAT;AACD;;AAED,MAAI,WAAW,CAAC,MAAhB,EAAwB;AACtB,IAAA,MAAM,GAAG,QAAA,CAAA,0BAAA,CAA2B,MAA3B,EAAmC,WAAW,CAAC,MAA/C,CAAT;AACD;;AACD,SAAO,MAAP;AACD,CA3BD;;AA6BA,OAAA,CAAA,OAAA,GAAe,qBAAf","sourceRoot":"","sourcesContent":["Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\nvar error_1 = require(\"graphql/error\");\nvar errors_1 = require(\"./errors\");\nvar getResponseKeyFromInfo_1 = require(\"./getResponseKeyFromInfo\");\n// Resolver that knows how to:\n// a) handle aliases for proxied schemas\n// b) handle errors from proxied schemas\nvar defaultMergedResolver = function (parent, args, context, info) {\n    if (!parent) {\n        return null;\n    }\n    var responseKey = getResponseKeyFromInfo_1.getResponseKeyFromInfo(info);\n    var errorResult = errors_1.getErrorsFromParent(parent, responseKey);\n    if (errorResult.kind === 'OWN') {\n        throw error_1.locatedError(new Error(errorResult.error.message), info.fieldNodes, graphql_1.responsePathAsArray(info.path));\n    }\n    var result = parent[responseKey];\n    if (result == null) {\n        result = parent[info.fieldName];\n    }\n    // subscription result mapping\n    if (!result && parent.data && parent.data[responseKey]) {\n        result = parent.data[responseKey];\n    }\n    if (errorResult.errors) {\n        result = errors_1.annotateWithChildrenErrors(result, errorResult.errors);\n    }\n    return result;\n};\nexports.default = defaultMergedResolver;\n//# sourceMappingURL=defaultMergedResolver.js.map"]},"metadata":{},"sourceType":"script"}