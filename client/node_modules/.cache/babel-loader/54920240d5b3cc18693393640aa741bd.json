{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OurContextualizedStats = exports.OurReport = exports.SizeEstimator = void 0;\n\nconst durationHistogram_1 = require(\"./durationHistogram\");\n\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\n\nconst iterateOverTrace_1 = require(\"./iterateOverTrace\");\n\nclass SizeEstimator {\n  constructor() {\n    this.bytes = 0;\n  }\n\n}\n\nexports.SizeEstimator = SizeEstimator;\n\nclass OurReport {\n  constructor(header) {\n    this.header = header;\n    this.tracesPerQuery = Object.create(null);\n    this.endTime = null;\n    this.sizeEstimator = new SizeEstimator();\n  }\n\n  addTrace(_ref) {\n    let {\n      statsReportKey,\n      trace,\n      asTrace,\n      includeTracesContributingToStats\n    } = _ref;\n    const tracesAndStats = this.getTracesAndStats(statsReportKey);\n\n    if (asTrace) {\n      const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n      tracesAndStats.trace.push(encodedTrace);\n      this.sizeEstimator.bytes += 2 + encodedTrace.length;\n    } else {\n      tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);\n\n      if (includeTracesContributingToStats) {\n        const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n        tracesAndStats.internalTracesContributingToStats.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    }\n  }\n\n  getTracesAndStats(statsReportKey) {\n    const existing = this.tracesPerQuery[statsReportKey];\n\n    if (existing) {\n      return existing;\n    }\n\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n    return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats();\n  }\n\n}\n\nexports.OurReport = OurReport;\n\nclass OurTracesAndStats {\n  constructor() {\n    this.trace = [];\n    this.statsWithContext = new StatsByContext();\n    this.internalTracesContributingToStats = [];\n  }\n\n}\n\nclass StatsByContext {\n  constructor() {\n    this.map = Object.create(null);\n  }\n\n  toArray() {\n    return Object.values(this.map);\n  }\n\n  addTrace(trace, sizeEstimator) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);\n  }\n\n  getContextualizedStats(trace, sizeEstimator) {\n    const statsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion,\n      clientReferenceId: trace.clientReferenceId\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n    const existing = this.map[statsContextKey];\n\n    if (existing) {\n      return existing;\n    }\n\n    sizeEstimator.bytes += 20 + estimatedBytesForString(trace.clientName) + estimatedBytesForString(trace.clientVersion) + estimatedBytesForString(trace.clientReferenceId);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n\n}\n\nclass OurContextualizedStats {\n  constructor(context) {\n    this.context = context;\n    this.queryLatencyStats = new OurQueryLatencyStats();\n    this.perTypeStat = Object.create(null);\n  }\n\n  addTrace(trace, sizeEstimator) {\n    var _a;\n\n    this.queryLatencyStats.requestCount++;\n\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n\n    if (!trace.fullQueryCacheHit && ((_a = trace.cachePolicy) === null || _a === void 0 ? void 0 : _a.maxAgeNs) != null) {\n      switch (trace.cachePolicy.scope) {\n        case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n          break;\n\n        case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n          break;\n      }\n    }\n\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n\n    let hasError = false;\n\n    const traceNodeStats = (node, path) => {\n      var _a, _b, _c, _d, _e;\n\n      if ((_a = node.error) === null || _a === void 0 ? void 0 : _a.length) {\n        hasError = true;\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach(subPath => {\n          currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);\n        });\n        currPathErrorStats.requestsWithErrorsCount += 1;\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n\n      const fieldName = node.originalFieldName || node.responseName;\n\n      if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {\n        const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n        const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);\n        fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\n        fieldStat.count++;\n        fieldStat.requestsWithErrorsCount += ((_e = (_d = node.error) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ? 1 : 0;\n        fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime);\n      }\n\n      return false;\n    };\n\n    iterateOverTrace_1.iterateOverTrace(trace, traceNodeStats, true);\n\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n\n  getTypeStat(parentType, sizeEstimator) {\n    const existing = this.perTypeStat[parentType];\n\n    if (existing) {\n      return existing;\n    }\n\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n\n}\n\nexports.OurContextualizedStats = OurContextualizedStats;\n\nclass OurQueryLatencyStats {\n  constructor() {\n    this.latencyCount = new durationHistogram_1.DurationHistogram();\n    this.requestCount = 0;\n    this.cacheHits = 0;\n    this.persistedQueryHits = 0;\n    this.persistedQueryMisses = 0;\n    this.cacheLatencyCount = new durationHistogram_1.DurationHistogram();\n    this.rootErrorStats = new OurPathErrorStats();\n    this.requestsWithErrorsCount = 0;\n    this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram();\n    this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram();\n    this.registeredOperationCount = 0;\n    this.forbiddenOperationCount = 0;\n  }\n\n}\n\nclass OurPathErrorStats {\n  constructor() {\n    this.children = Object.create(null);\n    this.errorsCount = 0;\n    this.requestsWithErrorsCount = 0;\n  }\n\n  getChild(subPath, sizeEstimator) {\n    const existing = this.children[subPath];\n\n    if (existing) {\n      return existing;\n    }\n\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n\n}\n\nclass OurTypeStat {\n  constructor() {\n    this.perFieldStat = Object.create(null);\n  }\n\n  getFieldStat(fieldName, returnType, sizeEstimator) {\n    const existing = this.perFieldStat[fieldName];\n\n    if (existing) {\n      return existing;\n    }\n\n    sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n\n}\n\nclass OurFieldStat {\n  constructor(returnType) {\n    this.returnType = returnType;\n    this.errorsCount = 0;\n    this.count = 0;\n    this.requestsWithErrorsCount = 0;\n    this.latencyCount = new durationHistogram_1.DurationHistogram();\n  }\n\n}\n\nfunction estimatedBytesForString(s) {\n  return 2 + Buffer.byteLength(s);\n}","map":{"version":3,"sources":["../../../src/plugin/usageReporting/stats.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OurContextualizedStats = exports.OurReport = exports.SizeEstimator = void 0;\nconst durationHistogram_1 = require(\"./durationHistogram\");\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\nconst iterateOverTrace_1 = require(\"./iterateOverTrace\");\nclass SizeEstimator {\n    constructor() {\n        this.bytes = 0;\n    }\n}\nexports.SizeEstimator = SizeEstimator;\nclass OurReport {\n    constructor(header) {\n        this.header = header;\n        this.tracesPerQuery = Object.create(null);\n        this.endTime = null;\n        this.sizeEstimator = new SizeEstimator();\n    }\n    addTrace({ statsReportKey, trace, asTrace, includeTracesContributingToStats, }) {\n        const tracesAndStats = this.getTracesAndStats(statsReportKey);\n        if (asTrace) {\n            const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n            tracesAndStats.trace.push(encodedTrace);\n            this.sizeEstimator.bytes += 2 + encodedTrace.length;\n        }\n        else {\n            tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);\n            if (includeTracesContributingToStats) {\n                const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n                tracesAndStats.internalTracesContributingToStats.push(encodedTrace);\n                this.sizeEstimator.bytes += 2 + encodedTrace.length;\n            }\n        }\n    }\n    getTracesAndStats(statsReportKey) {\n        const existing = this.tracesPerQuery[statsReportKey];\n        if (existing) {\n            return existing;\n        }\n        this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n        return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats());\n    }\n}\nexports.OurReport = OurReport;\nclass OurTracesAndStats {\n    constructor() {\n        this.trace = [];\n        this.statsWithContext = new StatsByContext();\n        this.internalTracesContributingToStats = [];\n    }\n}\nclass StatsByContext {\n    constructor() {\n        this.map = Object.create(null);\n    }\n    toArray() {\n        return Object.values(this.map);\n    }\n    addTrace(trace, sizeEstimator) {\n        this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);\n    }\n    getContextualizedStats(trace, sizeEstimator) {\n        const statsContext = {\n            clientName: trace.clientName,\n            clientVersion: trace.clientVersion,\n            clientReferenceId: trace.clientReferenceId,\n        };\n        const statsContextKey = JSON.stringify(statsContext);\n        const existing = this.map[statsContextKey];\n        if (existing) {\n            return existing;\n        }\n        sizeEstimator.bytes +=\n            20 +\n                estimatedBytesForString(trace.clientName) +\n                estimatedBytesForString(trace.clientVersion) +\n                estimatedBytesForString(trace.clientReferenceId);\n        const contextualizedStats = new OurContextualizedStats(statsContext);\n        this.map[statsContextKey] = contextualizedStats;\n        return contextualizedStats;\n    }\n}\nclass OurContextualizedStats {\n    constructor(context) {\n        this.context = context;\n        this.queryLatencyStats = new OurQueryLatencyStats();\n        this.perTypeStat = Object.create(null);\n    }\n    addTrace(trace, sizeEstimator) {\n        var _a;\n        this.queryLatencyStats.requestCount++;\n        if (trace.fullQueryCacheHit) {\n            this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);\n            this.queryLatencyStats.cacheHits++;\n        }\n        else {\n            this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n        }\n        if (!trace.fullQueryCacheHit && ((_a = trace.cachePolicy) === null || _a === void 0 ? void 0 : _a.maxAgeNs) != null) {\n            switch (trace.cachePolicy.scope) {\n                case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:\n                    this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n                    break;\n                case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:\n                    this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n                    break;\n            }\n        }\n        if (trace.persistedQueryHit) {\n            this.queryLatencyStats.persistedQueryHits++;\n        }\n        if (trace.persistedQueryRegister) {\n            this.queryLatencyStats.persistedQueryMisses++;\n        }\n        if (trace.forbiddenOperation) {\n            this.queryLatencyStats.forbiddenOperationCount++;\n        }\n        if (trace.registeredOperation) {\n            this.queryLatencyStats.registeredOperationCount++;\n        }\n        let hasError = false;\n        const traceNodeStats = (node, path) => {\n            var _a, _b, _c, _d, _e;\n            if ((_a = node.error) === null || _a === void 0 ? void 0 : _a.length) {\n                hasError = true;\n                let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n                path.toArray().forEach((subPath) => {\n                    currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);\n                });\n                currPathErrorStats.requestsWithErrorsCount += 1;\n                currPathErrorStats.errorsCount += node.error.length;\n            }\n            const fieldName = node.originalFieldName || node.responseName;\n            if (node.parentType &&\n                fieldName &&\n                node.type &&\n                node.endTime != null &&\n                node.startTime != null &&\n                node.endTime >= node.startTime) {\n                const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n                const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);\n                fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\n                fieldStat.count++;\n                fieldStat.requestsWithErrorsCount +=\n                    ((_e = (_d = node.error) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ? 1 : 0;\n                fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime);\n            }\n            return false;\n        };\n        iterateOverTrace_1.iterateOverTrace(trace, traceNodeStats, true);\n        if (hasError) {\n            this.queryLatencyStats.requestsWithErrorsCount++;\n        }\n    }\n    getTypeStat(parentType, sizeEstimator) {\n        const existing = this.perTypeStat[parentType];\n        if (existing) {\n            return existing;\n        }\n        sizeEstimator.bytes += estimatedBytesForString(parentType);\n        const typeStat = new OurTypeStat();\n        this.perTypeStat[parentType] = typeStat;\n        return typeStat;\n    }\n}\nexports.OurContextualizedStats = OurContextualizedStats;\nclass OurQueryLatencyStats {\n    constructor() {\n        this.latencyCount = new durationHistogram_1.DurationHistogram();\n        this.requestCount = 0;\n        this.cacheHits = 0;\n        this.persistedQueryHits = 0;\n        this.persistedQueryMisses = 0;\n        this.cacheLatencyCount = new durationHistogram_1.DurationHistogram();\n        this.rootErrorStats = new OurPathErrorStats();\n        this.requestsWithErrorsCount = 0;\n        this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram();\n        this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram();\n        this.registeredOperationCount = 0;\n        this.forbiddenOperationCount = 0;\n    }\n}\nclass OurPathErrorStats {\n    constructor() {\n        this.children = Object.create(null);\n        this.errorsCount = 0;\n        this.requestsWithErrorsCount = 0;\n    }\n    getChild(subPath, sizeEstimator) {\n        const existing = this.children[subPath];\n        if (existing) {\n            return existing;\n        }\n        const child = new OurPathErrorStats();\n        this.children[subPath] = child;\n        sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n        return child;\n    }\n}\nclass OurTypeStat {\n    constructor() {\n        this.perFieldStat = Object.create(null);\n    }\n    getFieldStat(fieldName, returnType, sizeEstimator) {\n        const existing = this.perFieldStat[fieldName];\n        if (existing) {\n            return existing;\n        }\n        sizeEstimator.bytes +=\n            estimatedBytesForString(fieldName) +\n                estimatedBytesForString(returnType) +\n                10;\n        const fieldStat = new OurFieldStat(returnType);\n        this.perFieldStat[fieldName] = fieldStat;\n        return fieldStat;\n    }\n}\nclass OurFieldStat {\n    constructor(returnType) {\n        this.returnType = returnType;\n        this.errorsCount = 0;\n        this.count = 0;\n        this.requestsWithErrorsCount = 0;\n        this.latencyCount = new durationHistogram_1.DurationHistogram();\n    }\n}\nfunction estimatedBytesForString(s) {\n    return 2 + Buffer.byteLength(s);\n}\n//# sourceMappingURL=stats.js.map"]},"metadata":{},"sourceType":"script"}