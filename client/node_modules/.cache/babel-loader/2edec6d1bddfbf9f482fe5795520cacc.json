{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addResolversToSchema = exports.buildSchemaFromSDL = exports.modulesFromSDL = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst validate_1 = require(\"graphql/validation/validate\");\n\nconst graphql_2 = require(\"../utilities/graphql\");\n\nconst GraphQLSchemaValidationError_1 = require(\"./GraphQLSchemaValidationError\");\n\nconst specifiedRules_1 = require(\"graphql/validation/specifiedRules\");\n\nconst flat_1 = __importDefault(require(\"core-js-pure/features/array/flat\"));\n\nconst validation_1 = require(\"graphql/validation\");\n\nconst mapValues_1 = require(\"../utilities/mapValues\");\n\nconst skippedSDLRules = [validation_1.KnownTypeNamesRule, validation_1.UniqueDirectivesPerLocationRule];\n\ntry {\n  const PossibleTypeExtensions = require(\"graphql/validation/rules/PossibleTypeExtensions\").PossibleTypeExtensions;\n\n  if (PossibleTypeExtensions) {\n    skippedSDLRules.push(PossibleTypeExtensions);\n  }\n} catch (e) {}\n\nconst sdlRules = specifiedRules_1.specifiedSDLRules.filter(rule => !skippedSDLRules.includes(rule));\n\nfunction modulesFromSDL(modulesOrSDL) {\n  if (Array.isArray(modulesOrSDL)) {\n    return modulesOrSDL.map(moduleOrSDL => {\n      if (graphql_2.isNode(moduleOrSDL) && graphql_2.isDocumentNode(moduleOrSDL)) {\n        return {\n          typeDefs: moduleOrSDL\n        };\n      } else {\n        return moduleOrSDL;\n      }\n    });\n  } else {\n    return [{\n      typeDefs: modulesOrSDL\n    }];\n  }\n}\n\nexports.modulesFromSDL = modulesFromSDL;\n\nfunction buildSchemaFromSDL(modulesOrSDL, schemaToExtend) {\n  const modules = modulesFromSDL(modulesOrSDL);\n  const documentAST = graphql_1.concatAST(modules.map(module => module.typeDefs));\n  const errors = validate_1.validateSDL(documentAST, schemaToExtend, sdlRules);\n\n  if (errors.length > 0) {\n    throw new GraphQLSchemaValidationError_1.GraphQLSchemaValidationError(errors);\n  }\n\n  const definitionsMap = Object.create(null);\n  const extensionsMap = Object.create(null);\n  const directiveDefinitions = [];\n  const schemaDefinitions = [];\n  const schemaExtensions = [];\n  const schemaDirectives = [];\n\n  for (const definition of documentAST.definitions) {\n    if (graphql_1.isTypeDefinitionNode(definition)) {\n      const typeName = definition.name.value;\n\n      if (definitionsMap[typeName]) {\n        definitionsMap[typeName].push(definition);\n      } else {\n        definitionsMap[typeName] = [definition];\n      }\n    } else if (graphql_1.isTypeExtensionNode(definition)) {\n      const typeName = definition.name.value;\n\n      if (extensionsMap[typeName]) {\n        extensionsMap[typeName].push(definition);\n      } else {\n        extensionsMap[typeName] = [definition];\n      }\n    } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n      directiveDefinitions.push(definition);\n    } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n      schemaDefinitions.push(definition);\n      schemaDirectives.push(...(definition.directives ? definition.directives : []));\n    } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n      schemaExtensions.push(definition);\n    }\n  }\n\n  let schema = schemaToExtend ? schemaToExtend : new graphql_1.GraphQLSchema({\n    query: undefined\n  });\n  const missingTypeDefinitions = [];\n\n  for (const [extendedTypeName, extensions] of Object.entries(extensionsMap)) {\n    if (!definitionsMap[extendedTypeName]) {\n      const extension = extensions[0];\n      const kind = extension.kind;\n      const definition = {\n        kind: extKindToDefKind[kind],\n        name: extension.name\n      };\n      missingTypeDefinitions.push(definition);\n    }\n  }\n\n  schema = graphql_1.extendSchema(schema, {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: [...flat_1.default(Object.values(definitionsMap)), ...missingTypeDefinitions, ...directiveDefinitions]\n  }, {\n    assumeValidSDL: true\n  });\n  schema = graphql_1.extendSchema(schema, {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: flat_1.default(Object.values(extensionsMap))\n  }, {\n    assumeValidSDL: true\n  });\n  let operationTypeMap;\n\n  if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n    operationTypeMap = {};\n    const operationTypes = flat_1.default([...schemaDefinitions, ...schemaExtensions].map(node => node.operationTypes).filter(isNotNullOrUndefined));\n\n    for (const {\n      operation,\n      type\n    } of operationTypes) {\n      operationTypeMap[operation] = type.name.value;\n    }\n  } else {\n    operationTypeMap = {\n      query: \"Query\",\n      mutation: \"Mutation\",\n      subscription: \"Subscription\"\n    };\n  }\n\n  schema = new graphql_1.GraphQLSchema(Object.assign(Object.assign(Object.assign({}, schema.toConfig()), mapValues_1.mapValues(operationTypeMap, typeName => typeName ? schema.getType(typeName) : undefined)), {\n    astNode: {\n      kind: graphql_1.Kind.SCHEMA_DEFINITION,\n      directives: schemaDirectives,\n      operationTypes: []\n    }\n  }));\n\n  for (const module of modules) {\n    if (!module.resolvers) continue;\n    addResolversToSchema(schema, module.resolvers);\n  }\n\n  return schema;\n}\n\nexports.buildSchemaFromSDL = buildSchemaFromSDL;\nconst extKindToDefKind = {\n  [graphql_1.Kind.SCALAR_TYPE_EXTENSION]: graphql_1.Kind.SCALAR_TYPE_DEFINITION,\n  [graphql_1.Kind.OBJECT_TYPE_EXTENSION]: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n  [graphql_1.Kind.INTERFACE_TYPE_EXTENSION]: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,\n  [graphql_1.Kind.UNION_TYPE_EXTENSION]: graphql_1.Kind.UNION_TYPE_DEFINITION,\n  [graphql_1.Kind.ENUM_TYPE_EXTENSION]: graphql_1.Kind.ENUM_TYPE_DEFINITION,\n  [graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION]: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION\n};\n\nfunction addResolversToSchema(schema, resolvers) {\n  for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n    const type = schema.getType(typeName);\n\n    if (graphql_1.isAbstractType(type)) {\n      for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n        if (fieldName.startsWith(\"__\")) {\n          type[fieldName.substring(2)] = fieldConfig;\n        }\n      }\n    }\n\n    if (graphql_1.isScalarType(type)) {\n      for (const fn in fieldConfigs) {\n        type[fn] = fieldConfigs[fn];\n      }\n    }\n\n    if (graphql_1.isEnumType(type)) {\n      const values = type.getValues();\n      const newValues = {};\n      values.forEach(value => {\n        let newValue = fieldConfigs[value.name];\n\n        if (newValue === undefined) {\n          newValue = value.name;\n        }\n\n        newValues[value.name] = {\n          value: newValue,\n          deprecationReason: value.deprecationReason,\n          description: value.description,\n          astNode: value.astNode,\n          extensions: undefined\n        };\n      });\n      Object.assign(type, new graphql_1.GraphQLEnumType(Object.assign(Object.assign({}, type.toConfig()), {\n        values: newValues\n      })));\n    }\n\n    if (!graphql_1.isObjectType(type)) continue;\n    const fieldMap = type.getFields();\n\n    for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n      if (fieldName.startsWith(\"__\")) {\n        type[fieldName.substring(2)] = fieldConfig;\n        continue;\n      }\n\n      const field = fieldMap[fieldName];\n      if (!field) continue;\n\n      if (typeof fieldConfig === \"function\") {\n        field.resolve = fieldConfig;\n      } else {\n        field.resolve = fieldConfig.resolve;\n      }\n    }\n  }\n}\n\nexports.addResolversToSchema = addResolversToSchema;\n\nfunction isNotNullOrUndefined(value) {\n  return value !== null && typeof value !== \"undefined\";\n}","map":{"version":3,"sources":["../../src/schema/buildSchemaFromSDL.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addResolversToSchema = exports.buildSchemaFromSDL = exports.modulesFromSDL = void 0;\nconst graphql_1 = require(\"graphql\");\nconst validate_1 = require(\"graphql/validation/validate\");\nconst graphql_2 = require(\"../utilities/graphql\");\nconst GraphQLSchemaValidationError_1 = require(\"./GraphQLSchemaValidationError\");\nconst specifiedRules_1 = require(\"graphql/validation/specifiedRules\");\nconst flat_1 = __importDefault(require(\"core-js-pure/features/array/flat\"));\nconst validation_1 = require(\"graphql/validation\");\nconst mapValues_1 = require(\"../utilities/mapValues\");\nconst skippedSDLRules = [\n    validation_1.KnownTypeNamesRule,\n    validation_1.UniqueDirectivesPerLocationRule\n];\ntry {\n    const PossibleTypeExtensions = require(\"graphql/validation/rules/PossibleTypeExtensions\")\n        .PossibleTypeExtensions;\n    if (PossibleTypeExtensions) {\n        skippedSDLRules.push(PossibleTypeExtensions);\n    }\n}\ncatch (e) {\n}\nconst sdlRules = specifiedRules_1.specifiedSDLRules.filter(rule => !skippedSDLRules.includes(rule));\nfunction modulesFromSDL(modulesOrSDL) {\n    if (Array.isArray(modulesOrSDL)) {\n        return modulesOrSDL.map(moduleOrSDL => {\n            if (graphql_2.isNode(moduleOrSDL) && graphql_2.isDocumentNode(moduleOrSDL)) {\n                return { typeDefs: moduleOrSDL };\n            }\n            else {\n                return moduleOrSDL;\n            }\n        });\n    }\n    else {\n        return [{ typeDefs: modulesOrSDL }];\n    }\n}\nexports.modulesFromSDL = modulesFromSDL;\nfunction buildSchemaFromSDL(modulesOrSDL, schemaToExtend) {\n    const modules = modulesFromSDL(modulesOrSDL);\n    const documentAST = graphql_1.concatAST(modules.map(module => module.typeDefs));\n    const errors = validate_1.validateSDL(documentAST, schemaToExtend, sdlRules);\n    if (errors.length > 0) {\n        throw new GraphQLSchemaValidationError_1.GraphQLSchemaValidationError(errors);\n    }\n    const definitionsMap = Object.create(null);\n    const extensionsMap = Object.create(null);\n    const directiveDefinitions = [];\n    const schemaDefinitions = [];\n    const schemaExtensions = [];\n    const schemaDirectives = [];\n    for (const definition of documentAST.definitions) {\n        if (graphql_1.isTypeDefinitionNode(definition)) {\n            const typeName = definition.name.value;\n            if (definitionsMap[typeName]) {\n                definitionsMap[typeName].push(definition);\n            }\n            else {\n                definitionsMap[typeName] = [definition];\n            }\n        }\n        else if (graphql_1.isTypeExtensionNode(definition)) {\n            const typeName = definition.name.value;\n            if (extensionsMap[typeName]) {\n                extensionsMap[typeName].push(definition);\n            }\n            else {\n                extensionsMap[typeName] = [definition];\n            }\n        }\n        else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n            directiveDefinitions.push(definition);\n        }\n        else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n            schemaDefinitions.push(definition);\n            schemaDirectives.push(...(definition.directives ? definition.directives : []));\n        }\n        else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n            schemaExtensions.push(definition);\n        }\n    }\n    let schema = schemaToExtend\n        ? schemaToExtend\n        : new graphql_1.GraphQLSchema({\n            query: undefined\n        });\n    const missingTypeDefinitions = [];\n    for (const [extendedTypeName, extensions] of Object.entries(extensionsMap)) {\n        if (!definitionsMap[extendedTypeName]) {\n            const extension = extensions[0];\n            const kind = extension.kind;\n            const definition = {\n                kind: extKindToDefKind[kind],\n                name: extension.name\n            };\n            missingTypeDefinitions.push(definition);\n        }\n    }\n    schema = graphql_1.extendSchema(schema, {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: [\n            ...flat_1.default(Object.values(definitionsMap)),\n            ...missingTypeDefinitions,\n            ...directiveDefinitions\n        ]\n    }, {\n        assumeValidSDL: true\n    });\n    schema = graphql_1.extendSchema(schema, {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: flat_1.default(Object.values(extensionsMap))\n    }, {\n        assumeValidSDL: true\n    });\n    let operationTypeMap;\n    if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n        operationTypeMap = {};\n        const operationTypes = flat_1.default([...schemaDefinitions, ...schemaExtensions]\n            .map(node => node.operationTypes)\n            .filter(isNotNullOrUndefined));\n        for (const { operation, type } of operationTypes) {\n            operationTypeMap[operation] = type.name.value;\n        }\n    }\n    else {\n        operationTypeMap = {\n            query: \"Query\",\n            mutation: \"Mutation\",\n            subscription: \"Subscription\"\n        };\n    }\n    schema = new graphql_1.GraphQLSchema(Object.assign(Object.assign(Object.assign({}, schema.toConfig()), mapValues_1.mapValues(operationTypeMap, typeName => typeName\n        ? schema.getType(typeName)\n        : undefined)), { astNode: {\n            kind: graphql_1.Kind.SCHEMA_DEFINITION,\n            directives: schemaDirectives,\n            operationTypes: []\n        } }));\n    for (const module of modules) {\n        if (!module.resolvers)\n            continue;\n        addResolversToSchema(schema, module.resolvers);\n    }\n    return schema;\n}\nexports.buildSchemaFromSDL = buildSchemaFromSDL;\nconst extKindToDefKind = {\n    [graphql_1.Kind.SCALAR_TYPE_EXTENSION]: graphql_1.Kind.SCALAR_TYPE_DEFINITION,\n    [graphql_1.Kind.OBJECT_TYPE_EXTENSION]: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n    [graphql_1.Kind.INTERFACE_TYPE_EXTENSION]: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,\n    [graphql_1.Kind.UNION_TYPE_EXTENSION]: graphql_1.Kind.UNION_TYPE_DEFINITION,\n    [graphql_1.Kind.ENUM_TYPE_EXTENSION]: graphql_1.Kind.ENUM_TYPE_DEFINITION,\n    [graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION]: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION\n};\nfunction addResolversToSchema(schema, resolvers) {\n    for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n        const type = schema.getType(typeName);\n        if (graphql_1.isAbstractType(type)) {\n            for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n                if (fieldName.startsWith(\"__\")) {\n                    type[fieldName.substring(2)] = fieldConfig;\n                }\n            }\n        }\n        if (graphql_1.isScalarType(type)) {\n            for (const fn in fieldConfigs) {\n                type[fn] = fieldConfigs[fn];\n            }\n        }\n        if (graphql_1.isEnumType(type)) {\n            const values = type.getValues();\n            const newValues = {};\n            values.forEach(value => {\n                let newValue = fieldConfigs[value.name];\n                if (newValue === undefined) {\n                    newValue = value.name;\n                }\n                newValues[value.name] = {\n                    value: newValue,\n                    deprecationReason: value.deprecationReason,\n                    description: value.description,\n                    astNode: value.astNode,\n                    extensions: undefined\n                };\n            });\n            Object.assign(type, new graphql_1.GraphQLEnumType(Object.assign(Object.assign({}, type.toConfig()), { values: newValues })));\n        }\n        if (!graphql_1.isObjectType(type))\n            continue;\n        const fieldMap = type.getFields();\n        for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n            if (fieldName.startsWith(\"__\")) {\n                type[fieldName.substring(2)] = fieldConfig;\n                continue;\n            }\n            const field = fieldMap[fieldName];\n            if (!field)\n                continue;\n            if (typeof fieldConfig === \"function\") {\n                field.resolve = fieldConfig;\n            }\n            else {\n                field.resolve = fieldConfig.resolve;\n            }\n        }\n    }\n}\nexports.addResolversToSchema = addResolversToSchema;\nfunction isNotNullOrUndefined(value) {\n    return value !== null && typeof value !== \"undefined\";\n}\n//# sourceMappingURL=buildSchemaFromSDL.js.map"]},"metadata":{},"sourceType":"script"}