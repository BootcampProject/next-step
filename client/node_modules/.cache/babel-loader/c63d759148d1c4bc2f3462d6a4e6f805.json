{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _1 = require(\".\");\n\nvar graphql_1 = require(\"graphql\");\n\nvar transforms_1 = require(\"../transforms/transforms\");\n\nvar _2 = require(\".\");\n\nvar ConvertEnumValues_1 = require(\"../transforms/ConvertEnumValues\");\n\nfunction addResolveFunctionsToSchema(options, legacyInputResolvers, legacyInputValidationOptions) {\n  if (options instanceof graphql_1.GraphQLSchema) {\n    console.warn('The addResolveFunctionsToSchema function takes named options now; see IAddResolveFunctionsToSchemaOptions');\n    options = {\n      schema: options,\n      resolvers: legacyInputResolvers,\n      resolverValidationOptions: legacyInputValidationOptions\n    };\n  }\n\n  var schema = options.schema,\n      inputResolvers = options.resolvers,\n      _a = options.resolverValidationOptions,\n      resolverValidationOptions = _a === void 0 ? {} : _a,\n      _b = options.inheritResolversFromInterfaces,\n      inheritResolversFromInterfaces = _b === void 0 ? false : _b;\n  var _c = resolverValidationOptions.allowResolversNotInSchema,\n      allowResolversNotInSchema = _c === void 0 ? false : _c,\n      requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;\n  var resolvers = inheritResolversFromInterfaces ? _2.extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers; // Used to map the external value of an enum to its internal value, when\n  // that internal value is provided by a resolver.\n\n  var enumValueMap = Object.create(null);\n  Object.keys(resolvers).forEach(function (typeName) {\n    var resolverValue = resolvers[typeName];\n    var resolverType = typeof resolverValue;\n\n    if (resolverType !== 'object' && resolverType !== 'function') {\n      throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but has invalid value \\\"\" + resolverValue + \"\\\". A resolver's value \" + \"must be of type object or function.\");\n    }\n\n    var type = schema.getType(typeName);\n\n    if (!type && typeName !== '__schema') {\n      if (allowResolversNotInSchema) {\n        return;\n      }\n\n      throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but not in schema\");\n    }\n\n    Object.keys(resolverValue).forEach(function (fieldName) {\n      if (fieldName.startsWith('__')) {\n        // this is for isTypeOf and resolveType and all the other stuff.\n        type[fieldName.substring(2)] = resolverValue[fieldName];\n        return;\n      }\n\n      if (type instanceof graphql_1.GraphQLScalarType) {\n        type[fieldName] = resolverValue[fieldName];\n        return;\n      }\n\n      if (type instanceof graphql_1.GraphQLEnumType) {\n        if (!type.getValue(fieldName)) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n\n          throw new _1.SchemaError(typeName + \".\" + fieldName + \" was defined in resolvers, but enum is not in schema\");\n        } // We've encountered an enum resolver that is being used to provide an\n        // internal enum value.\n        // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\n        //\n        // We're storing a map of the current enums external facing value to\n        // its resolver provided internal value. This map is used to transform\n        // the current schema to a new schema that includes enums with the new\n        // internal value.\n\n\n        enumValueMap[type.name] = enumValueMap[type.name] || {};\n        enumValueMap[type.name][fieldName] = resolverValue[fieldName];\n        return;\n      } // object type\n\n\n      var fields = getFieldsForType(type);\n\n      if (!fields) {\n        if (allowResolversNotInSchema) {\n          return;\n        }\n\n        throw new _1.SchemaError(typeName + \" was defined in resolvers, but it's not an object\");\n      }\n\n      if (!fields[fieldName]) {\n        if (allowResolversNotInSchema) {\n          return;\n        }\n\n        throw new _1.SchemaError(typeName + \".\" + fieldName + \" defined in resolvers, but not in schema\");\n      }\n\n      var field = fields[fieldName];\n      var fieldResolve = resolverValue[fieldName];\n\n      if (typeof fieldResolve === 'function') {\n        // for convenience. Allows shorter syntax in resolver definition file\n        setFieldProperties(field, {\n          resolve: fieldResolve\n        });\n      } else {\n        if (typeof fieldResolve !== 'object') {\n          throw new _1.SchemaError(\"Resolver \" + typeName + \".\" + fieldName + \" must be object or function\");\n        }\n\n        setFieldProperties(field, fieldResolve);\n      }\n    });\n  });\n\n  _2.checkForResolveTypeResolver(schema, requireResolversForResolveType); // If there are any enum resolver functions (that are used to return\n  // internal enum values), create a new schema that includes enums with the\n  // new internal facing values.\n\n\n  var updatedSchema = transforms_1.applySchemaTransforms(schema, [new ConvertEnumValues_1.default(enumValueMap)]);\n  return updatedSchema;\n}\n\nfunction getFieldsForType(type) {\n  if (type instanceof graphql_1.GraphQLObjectType || type instanceof graphql_1.GraphQLInterfaceType) {\n    return type.getFields();\n  } else {\n    return undefined;\n  }\n}\n\nfunction setFieldProperties(field, propertiesObj) {\n  Object.keys(propertiesObj).forEach(function (propertyName) {\n    field[propertyName] = propertiesObj[propertyName];\n  });\n}\n\nexports.default = addResolveFunctionsToSchema;","map":{"version":3,"sources":["../../src/generate/addResolveFunctionsToSchema.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["Object.defineProperty(exports, \"__esModule\", { value: true });\nvar _1 = require(\".\");\nvar graphql_1 = require(\"graphql\");\nvar transforms_1 = require(\"../transforms/transforms\");\nvar _2 = require(\".\");\nvar ConvertEnumValues_1 = require(\"../transforms/ConvertEnumValues\");\nfunction addResolveFunctionsToSchema(options, legacyInputResolvers, legacyInputValidationOptions) {\n    if (options instanceof graphql_1.GraphQLSchema) {\n        console.warn('The addResolveFunctionsToSchema function takes named options now; see IAddResolveFunctionsToSchemaOptions');\n        options = {\n            schema: options,\n            resolvers: legacyInputResolvers,\n            resolverValidationOptions: legacyInputValidationOptions,\n        };\n    }\n    var schema = options.schema, inputResolvers = options.resolvers, _a = options.resolverValidationOptions, resolverValidationOptions = _a === void 0 ? {} : _a, _b = options.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _b === void 0 ? false : _b;\n    var _c = resolverValidationOptions.allowResolversNotInSchema, allowResolversNotInSchema = _c === void 0 ? false : _c, requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;\n    var resolvers = inheritResolversFromInterfaces\n        ? _2.extendResolversFromInterfaces(schema, inputResolvers)\n        : inputResolvers;\n    // Used to map the external value of an enum to its internal value, when\n    // that internal value is provided by a resolver.\n    var enumValueMap = Object.create(null);\n    Object.keys(resolvers).forEach(function (typeName) {\n        var resolverValue = resolvers[typeName];\n        var resolverType = typeof resolverValue;\n        if (resolverType !== 'object' && resolverType !== 'function') {\n            throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but has invalid value \\\"\" + resolverValue + \"\\\". A resolver's value \" +\n                \"must be of type object or function.\");\n        }\n        var type = schema.getType(typeName);\n        if (!type && typeName !== '__schema') {\n            if (allowResolversNotInSchema) {\n                return;\n            }\n            throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but not in schema\");\n        }\n        Object.keys(resolverValue).forEach(function (fieldName) {\n            if (fieldName.startsWith('__')) {\n                // this is for isTypeOf and resolveType and all the other stuff.\n                type[fieldName.substring(2)] = resolverValue[fieldName];\n                return;\n            }\n            if (type instanceof graphql_1.GraphQLScalarType) {\n                type[fieldName] = resolverValue[fieldName];\n                return;\n            }\n            if (type instanceof graphql_1.GraphQLEnumType) {\n                if (!type.getValue(fieldName)) {\n                    if (allowResolversNotInSchema) {\n                        return;\n                    }\n                    throw new _1.SchemaError(typeName + \".\" + fieldName + \" was defined in resolvers, but enum is not in schema\");\n                }\n                // We've encountered an enum resolver that is being used to provide an\n                // internal enum value.\n                // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\n                //\n                // We're storing a map of the current enums external facing value to\n                // its resolver provided internal value. This map is used to transform\n                // the current schema to a new schema that includes enums with the new\n                // internal value.\n                enumValueMap[type.name] = enumValueMap[type.name] || {};\n                enumValueMap[type.name][fieldName] = resolverValue[fieldName];\n                return;\n            }\n            // object type\n            var fields = getFieldsForType(type);\n            if (!fields) {\n                if (allowResolversNotInSchema) {\n                    return;\n                }\n                throw new _1.SchemaError(typeName + \" was defined in resolvers, but it's not an object\");\n            }\n            if (!fields[fieldName]) {\n                if (allowResolversNotInSchema) {\n                    return;\n                }\n                throw new _1.SchemaError(typeName + \".\" + fieldName + \" defined in resolvers, but not in schema\");\n            }\n            var field = fields[fieldName];\n            var fieldResolve = resolverValue[fieldName];\n            if (typeof fieldResolve === 'function') {\n                // for convenience. Allows shorter syntax in resolver definition file\n                setFieldProperties(field, { resolve: fieldResolve });\n            }\n            else {\n                if (typeof fieldResolve !== 'object') {\n                    throw new _1.SchemaError(\"Resolver \" + typeName + \".\" + fieldName + \" must be object or function\");\n                }\n                setFieldProperties(field, fieldResolve);\n            }\n        });\n    });\n    _2.checkForResolveTypeResolver(schema, requireResolversForResolveType);\n    // If there are any enum resolver functions (that are used to return\n    // internal enum values), create a new schema that includes enums with the\n    // new internal facing values.\n    var updatedSchema = transforms_1.applySchemaTransforms(schema, [\n        new ConvertEnumValues_1.default(enumValueMap),\n    ]);\n    return updatedSchema;\n}\nfunction getFieldsForType(type) {\n    if (type instanceof graphql_1.GraphQLObjectType ||\n        type instanceof graphql_1.GraphQLInterfaceType) {\n        return type.getFields();\n    }\n    else {\n        return undefined;\n    }\n}\nfunction setFieldProperties(field, propertiesObj) {\n    Object.keys(propertiesObj).forEach(function (propertyName) {\n        field[propertyName] = propertiesObj[propertyName];\n    });\n}\nexports.default = addResolveFunctionsToSchema;\n//# sourceMappingURL=addResolveFunctionsToSchema.js.map"]},"metadata":{},"sourceType":"script"}