{"ast":null,"code":"function __export(m) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar schemaVisitor_1 = require(\"./schemaVisitor\");\n\nvar mergeDeep_1 = require(\"./mergeDeep\");\n\nvar generate_1 = require(\"./generate\");\n\nfunction makeExecutableSchema(_a) {\n  var typeDefs = _a.typeDefs,\n      _b = _a.resolvers,\n      resolvers = _b === void 0 ? {} : _b,\n      connectors = _a.connectors,\n      logger = _a.logger,\n      _c = _a.allowUndefinedInResolve,\n      allowUndefinedInResolve = _c === void 0 ? true : _c,\n      _d = _a.resolverValidationOptions,\n      resolverValidationOptions = _d === void 0 ? {} : _d,\n      _e = _a.directiveResolvers,\n      directiveResolvers = _e === void 0 ? null : _e,\n      _f = _a.schemaDirectives,\n      schemaDirectives = _f === void 0 ? null : _f,\n      _g = _a.parseOptions,\n      parseOptions = _g === void 0 ? {} : _g,\n      _h = _a.inheritResolversFromInterfaces,\n      inheritResolversFromInterfaces = _h === void 0 ? false : _h; // Validate and clean up arguments\n\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new generate_1.SchemaError('Expected `resolverValidationOptions` to be an object');\n  }\n\n  if (!typeDefs) {\n    throw new generate_1.SchemaError('Must provide typeDefs');\n  }\n\n  if (!resolvers) {\n    throw new generate_1.SchemaError('Must provide resolvers');\n  } // We allow passing in an array of resolver maps, in which case we merge them\n\n\n  var resolverMap = Array.isArray(resolvers) ? resolvers.filter(function (resolverObj) {\n    return typeof resolverObj === 'object';\n  }).reduce(mergeDeep_1.default, {}) : resolvers; // Arguments are now validated and cleaned up\n\n  var schema = generate_1.buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\n  schema = generate_1.addResolveFunctionsToSchema({\n    schema: schema,\n    resolvers: resolverMap,\n    resolverValidationOptions: resolverValidationOptions,\n    inheritResolversFromInterfaces: inheritResolversFromInterfaces\n  });\n  generate_1.assertResolveFunctionsPresent(schema, resolverValidationOptions);\n\n  if (!allowUndefinedInResolve) {\n    addCatchUndefinedToSchema(schema);\n  }\n\n  if (logger) {\n    addErrorLoggingToSchema(schema, logger);\n  }\n\n  if (typeof resolvers['__schema'] === 'function') {\n    // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n    // not doing that now, because I'd have to rewrite a lot of tests.\n    generate_1.addSchemaLevelResolveFunction(schema, resolvers['__schema']);\n  }\n\n  if (connectors) {\n    // connectors are optional, at least for now. That means you can just import them in the resolve\n    // function if you want.\n    generate_1.attachConnectorsToContext(schema, connectors);\n  }\n\n  if (directiveResolvers) {\n    generate_1.attachDirectiveResolvers(schema, directiveResolvers);\n  }\n\n  if (schemaDirectives) {\n    schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n  }\n\n  return schema;\n}\n\nexports.makeExecutableSchema = makeExecutableSchema;\n\nfunction decorateToCatchUndefined(fn, hint) {\n  if (typeof fn === 'undefined') {\n    fn = graphql_1.defaultFieldResolver;\n  }\n\n  return function (root, args, ctx, info) {\n    var result = fn(root, args, ctx, info);\n\n    if (typeof result === 'undefined') {\n      throw new Error(\"Resolve function for \\\"\" + hint + \"\\\" returned undefined\");\n    }\n\n    return result;\n  };\n}\n\nfunction addCatchUndefinedToSchema(schema) {\n  generate_1.forEachField(schema, function (field, typeName, fieldName) {\n    var errorHint = typeName + \".\" + fieldName;\n    field.resolve = decorateToCatchUndefined(field.resolve, errorHint);\n  });\n}\n\nexports.addCatchUndefinedToSchema = addCatchUndefinedToSchema;\n\nfunction addErrorLoggingToSchema(schema, logger) {\n  if (!logger) {\n    throw new Error('Must provide a logger');\n  }\n\n  if (typeof logger.log !== 'function') {\n    throw new Error('Logger.log must be a function');\n  }\n\n  generate_1.forEachField(schema, function (field, typeName, fieldName) {\n    var errorHint = typeName + \".\" + fieldName;\n    field.resolve = generate_1.decorateWithLogger(field.resolve, logger, errorHint);\n  });\n}\n\nexports.addErrorLoggingToSchema = addErrorLoggingToSchema;\n\n__export(require(\"./generate\"));","map":{"version":3,"sources":["../src/makeExecutableSchema.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["function __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\nvar schemaVisitor_1 = require(\"./schemaVisitor\");\nvar mergeDeep_1 = require(\"./mergeDeep\");\nvar generate_1 = require(\"./generate\");\nfunction makeExecutableSchema(_a) {\n    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d, _e = _a.directiveResolvers, directiveResolvers = _e === void 0 ? null : _e, _f = _a.schemaDirectives, schemaDirectives = _f === void 0 ? null : _f, _g = _a.parseOptions, parseOptions = _g === void 0 ? {} : _g, _h = _a.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _h === void 0 ? false : _h;\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new generate_1.SchemaError('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new generate_1.SchemaError('Must provide typeDefs');\n    }\n    if (!resolvers) {\n        throw new generate_1.SchemaError('Must provide resolvers');\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    var resolverMap = Array.isArray(resolvers)\n        ? resolvers.filter(function (resolverObj) { return typeof resolverObj === 'object'; }).reduce(mergeDeep_1.default, {})\n        : resolvers;\n    // Arguments are now validated and cleaned up\n    var schema = generate_1.buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\n    schema = generate_1.addResolveFunctionsToSchema({\n        schema: schema,\n        resolvers: resolverMap,\n        resolverValidationOptions: resolverValidationOptions,\n        inheritResolversFromInterfaces: inheritResolversFromInterfaces\n    });\n    generate_1.assertResolveFunctionsPresent(schema, resolverValidationOptions);\n    if (!allowUndefinedInResolve) {\n        addCatchUndefinedToSchema(schema);\n    }\n    if (logger) {\n        addErrorLoggingToSchema(schema, logger);\n    }\n    if (typeof resolvers['__schema'] === 'function') {\n        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n        // not doing that now, because I'd have to rewrite a lot of tests.\n        generate_1.addSchemaLevelResolveFunction(schema, resolvers['__schema']);\n    }\n    if (connectors) {\n        // connectors are optional, at least for now. That means you can just import them in the resolve\n        // function if you want.\n        generate_1.attachConnectorsToContext(schema, connectors);\n    }\n    if (directiveResolvers) {\n        generate_1.attachDirectiveResolvers(schema, directiveResolvers);\n    }\n    if (schemaDirectives) {\n        schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n    }\n    return schema;\n}\nexports.makeExecutableSchema = makeExecutableSchema;\nfunction decorateToCatchUndefined(fn, hint) {\n    if (typeof fn === 'undefined') {\n        fn = graphql_1.defaultFieldResolver;\n    }\n    return function (root, args, ctx, info) {\n        var result = fn(root, args, ctx, info);\n        if (typeof result === 'undefined') {\n            throw new Error(\"Resolve function for \\\"\" + hint + \"\\\" returned undefined\");\n        }\n        return result;\n    };\n}\nfunction addCatchUndefinedToSchema(schema) {\n    generate_1.forEachField(schema, function (field, typeName, fieldName) {\n        var errorHint = typeName + \".\" + fieldName;\n        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);\n    });\n}\nexports.addCatchUndefinedToSchema = addCatchUndefinedToSchema;\nfunction addErrorLoggingToSchema(schema, logger) {\n    if (!logger) {\n        throw new Error('Must provide a logger');\n    }\n    if (typeof logger.log !== 'function') {\n        throw new Error('Logger.log must be a function');\n    }\n    generate_1.forEachField(schema, function (field, typeName, fieldName) {\n        var errorHint = typeName + \".\" + fieldName;\n        field.resolve = generate_1.decorateWithLogger(field.resolve, logger, errorHint);\n    });\n}\nexports.addErrorLoggingToSchema = addErrorLoggingToSchema;\n__export(require(\"./generate\"));\n//# sourceMappingURL=makeExecutableSchema.js.map"]},"metadata":{},"sourceType":"script"}