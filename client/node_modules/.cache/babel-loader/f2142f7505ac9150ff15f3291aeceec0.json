{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar implementsAbstractType_1 = require(\"../implementsAbstractType\");\n\nvar ExpandAbstractTypes =\n/** @class */\nfunction () {\n  function ExpandAbstractTypes(transformedSchema, targetSchema) {\n    this.targetSchema = targetSchema;\n    this.mapping = extractPossibleTypes(transformedSchema, targetSchema);\n    this.reverseMapping = flipMapping(this.mapping);\n  }\n\n  ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {\n    var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);\n    return __assign(__assign({}, originalRequest), {\n      document: document\n    });\n  };\n\n  return ExpandAbstractTypes;\n}();\n\nexports.default = ExpandAbstractTypes;\n\nfunction extractPossibleTypes(transformedSchema, targetSchema) {\n  var typeMap = transformedSchema.getTypeMap();\n  var mapping = {};\n  Object.keys(typeMap).forEach(function (typeName) {\n    var type = typeMap[typeName];\n\n    if (graphql_1.isAbstractType(type)) {\n      var targetType = targetSchema.getType(typeName);\n\n      if (!graphql_1.isAbstractType(targetType)) {\n        var implementations = transformedSchema.getPossibleTypes(type) || [];\n        mapping[typeName] = implementations.filter(function (impl) {\n          return targetSchema.getType(impl.name);\n        }).map(function (impl) {\n          return impl.name;\n        });\n      }\n    }\n  });\n  return mapping;\n}\n\nfunction flipMapping(mapping) {\n  var result = {};\n  Object.keys(mapping).forEach(function (typeName) {\n    var toTypeNames = mapping[typeName];\n    toTypeNames.forEach(function (toTypeName) {\n      if (!result[toTypeName]) {\n        result[toTypeName] = [];\n      }\n\n      result[toTypeName].push(typeName);\n    });\n  });\n  return result;\n}\n\nfunction expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {\n  var _a;\n\n  var operations = document.definitions.filter(function (def) {\n    return def.kind === graphql_1.Kind.OPERATION_DEFINITION;\n  });\n  var fragments = document.definitions.filter(function (def) {\n    return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION;\n  });\n  var existingFragmentNames = fragments.map(function (fragment) {\n    return fragment.name.value;\n  });\n  var fragmentCounter = 0;\n\n  var generateFragmentName = function (typeName) {\n    var fragmentName;\n\n    do {\n      fragmentName = \"_\" + typeName + \"_Fragment\" + fragmentCounter;\n      fragmentCounter++;\n    } while (existingFragmentNames.indexOf(fragmentName) !== -1);\n\n    return fragmentName;\n  };\n\n  var newFragments = [];\n  var fragmentReplacements = {};\n  fragments.forEach(function (fragment) {\n    newFragments.push(fragment);\n    var possibleTypes = mapping[fragment.typeCondition.name.value];\n\n    if (possibleTypes) {\n      fragmentReplacements[fragment.name.value] = [];\n      possibleTypes.forEach(function (possibleTypeName) {\n        var name = generateFragmentName(possibleTypeName);\n        existingFragmentNames.push(name);\n        var newFragment = {\n          kind: graphql_1.Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: name\n          },\n          typeCondition: {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n              kind: graphql_1.Kind.NAME,\n              value: possibleTypeName\n            }\n          },\n          selectionSet: fragment.selectionSet\n        };\n        newFragments.push(newFragment);\n        fragmentReplacements[fragment.name.value].push({\n          fragmentName: name,\n          typeName: possibleTypeName\n        });\n      });\n    }\n  });\n\n  var newDocument = __assign(__assign({}, document), {\n    definitions: __spreadArrays(operations, newFragments)\n  });\n\n  var typeInfo = new graphql_1.TypeInfo(targetSchema);\n  return graphql_1.visit(newDocument, graphql_1.visitWithTypeInfo(typeInfo, (_a = {}, _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n    var newSelections = __spreadArrays(node.selections);\n\n    var parentType = graphql_1.getNamedType(typeInfo.getParentType());\n    node.selections.forEach(function (selection) {\n      if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n        var possibleTypes = mapping[selection.typeCondition.name.value];\n\n        if (possibleTypes) {\n          possibleTypes.forEach(function (possibleType) {\n            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(possibleType))) {\n              newSelections.push({\n                kind: graphql_1.Kind.INLINE_FRAGMENT,\n                typeCondition: {\n                  kind: graphql_1.Kind.NAMED_TYPE,\n                  name: {\n                    kind: graphql_1.Kind.NAME,\n                    value: possibleType\n                  }\n                },\n                selectionSet: selection.selectionSet\n              });\n            }\n          });\n        }\n      } else if (selection.kind === graphql_1.Kind.FRAGMENT_SPREAD) {\n        var fragmentName = selection.name.value;\n        var replacements = fragmentReplacements[fragmentName];\n\n        if (replacements) {\n          replacements.forEach(function (replacement) {\n            var typeName = replacement.typeName;\n\n            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(typeName))) {\n              newSelections.push({\n                kind: graphql_1.Kind.FRAGMENT_SPREAD,\n                name: {\n                  kind: graphql_1.Kind.NAME,\n                  value: replacement.fragmentName\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n\n    if (parentType && reverseMapping[parentType.name]) {\n      newSelections.push({\n        kind: graphql_1.Kind.FIELD,\n        name: {\n          kind: graphql_1.Kind.NAME,\n          value: '__typename'\n        }\n      });\n    }\n\n    if (newSelections.length !== node.selections.length) {\n      return __assign(__assign({}, node), {\n        selections: newSelections\n      });\n    }\n  }, _a)));\n}","map":{"version":3,"sources":["../../src/transforms/ExpandAbstractTypes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\nvar implementsAbstractType_1 = require(\"../implementsAbstractType\");\nvar ExpandAbstractTypes = /** @class */ (function () {\n    function ExpandAbstractTypes(transformedSchema, targetSchema) {\n        this.targetSchema = targetSchema;\n        this.mapping = extractPossibleTypes(transformedSchema, targetSchema);\n        this.reverseMapping = flipMapping(this.mapping);\n    }\n    ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {\n        var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);\n        return __assign(__assign({}, originalRequest), { document: document });\n    };\n    return ExpandAbstractTypes;\n}());\nexports.default = ExpandAbstractTypes;\nfunction extractPossibleTypes(transformedSchema, targetSchema) {\n    var typeMap = transformedSchema.getTypeMap();\n    var mapping = {};\n    Object.keys(typeMap).forEach(function (typeName) {\n        var type = typeMap[typeName];\n        if (graphql_1.isAbstractType(type)) {\n            var targetType = targetSchema.getType(typeName);\n            if (!graphql_1.isAbstractType(targetType)) {\n                var implementations = transformedSchema.getPossibleTypes(type) || [];\n                mapping[typeName] = implementations\n                    .filter(function (impl) { return targetSchema.getType(impl.name); })\n                    .map(function (impl) { return impl.name; });\n            }\n        }\n    });\n    return mapping;\n}\nfunction flipMapping(mapping) {\n    var result = {};\n    Object.keys(mapping).forEach(function (typeName) {\n        var toTypeNames = mapping[typeName];\n        toTypeNames.forEach(function (toTypeName) {\n            if (!result[toTypeName]) {\n                result[toTypeName] = [];\n            }\n            result[toTypeName].push(typeName);\n        });\n    });\n    return result;\n}\nfunction expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {\n    var _a;\n    var operations = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });\n    var fragments = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });\n    var existingFragmentNames = fragments.map(function (fragment) { return fragment.name.value; });\n    var fragmentCounter = 0;\n    var generateFragmentName = function (typeName) {\n        var fragmentName;\n        do {\n            fragmentName = \"_\" + typeName + \"_Fragment\" + fragmentCounter;\n            fragmentCounter++;\n        } while (existingFragmentNames.indexOf(fragmentName) !== -1);\n        return fragmentName;\n    };\n    var newFragments = [];\n    var fragmentReplacements = {};\n    fragments.forEach(function (fragment) {\n        newFragments.push(fragment);\n        var possibleTypes = mapping[fragment.typeCondition.name.value];\n        if (possibleTypes) {\n            fragmentReplacements[fragment.name.value] = [];\n            possibleTypes.forEach(function (possibleTypeName) {\n                var name = generateFragmentName(possibleTypeName);\n                existingFragmentNames.push(name);\n                var newFragment = {\n                    kind: graphql_1.Kind.FRAGMENT_DEFINITION,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: name,\n                    },\n                    typeCondition: {\n                        kind: graphql_1.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: possibleTypeName,\n                        },\n                    },\n                    selectionSet: fragment.selectionSet,\n                };\n                newFragments.push(newFragment);\n                fragmentReplacements[fragment.name.value].push({\n                    fragmentName: name,\n                    typeName: possibleTypeName,\n                });\n            });\n        }\n    });\n    var newDocument = __assign(__assign({}, document), { definitions: __spreadArrays(operations, newFragments) });\n    var typeInfo = new graphql_1.TypeInfo(targetSchema);\n    return graphql_1.visit(newDocument, graphql_1.visitWithTypeInfo(typeInfo, (_a = {},\n        _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n            var newSelections = __spreadArrays(node.selections);\n            var parentType = graphql_1.getNamedType(typeInfo.getParentType());\n            node.selections.forEach(function (selection) {\n                if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n                    var possibleTypes = mapping[selection.typeCondition.name.value];\n                    if (possibleTypes) {\n                        possibleTypes.forEach(function (possibleType) {\n                            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(possibleType))) {\n                                newSelections.push({\n                                    kind: graphql_1.Kind.INLINE_FRAGMENT,\n                                    typeCondition: {\n                                        kind: graphql_1.Kind.NAMED_TYPE,\n                                        name: {\n                                            kind: graphql_1.Kind.NAME,\n                                            value: possibleType,\n                                        },\n                                    },\n                                    selectionSet: selection.selectionSet,\n                                });\n                            }\n                        });\n                    }\n                }\n                else if (selection.kind === graphql_1.Kind.FRAGMENT_SPREAD) {\n                    var fragmentName = selection.name.value;\n                    var replacements = fragmentReplacements[fragmentName];\n                    if (replacements) {\n                        replacements.forEach(function (replacement) {\n                            var typeName = replacement.typeName;\n                            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(typeName))) {\n                                newSelections.push({\n                                    kind: graphql_1.Kind.FRAGMENT_SPREAD,\n                                    name: {\n                                        kind: graphql_1.Kind.NAME,\n                                        value: replacement.fragmentName,\n                                    },\n                                });\n                            }\n                        });\n                    }\n                }\n            });\n            if (parentType && reverseMapping[parentType.name]) {\n                newSelections.push({\n                    kind: graphql_1.Kind.FIELD,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: '__typename',\n                    },\n                });\n            }\n            if (newSelections.length !== node.selections.length) {\n                return __assign(__assign({}, node), { selections: newSelections });\n            }\n        },\n        _a)));\n}\n//# sourceMappingURL=ExpandAbstractTypes.js.map"]},"metadata":{},"sourceType":"script"}