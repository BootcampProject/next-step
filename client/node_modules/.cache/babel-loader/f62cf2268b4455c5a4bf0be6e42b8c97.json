{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar values_1 = require(\"graphql/execution/values\");\n\nvar hasOwn = Object.prototype.hasOwnProperty; // Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\n\nvar SchemaVisitor =\n/** @class */\nfunction () {\n  function SchemaVisitor() {} // Determine if this SchemaVisitor (sub)class implements a particular\n  // visitor method.\n\n\n  SchemaVisitor.implementsVisitorMethod = function (methodName) {\n    if (!methodName.startsWith('visit')) {\n      return false;\n    }\n\n    var method = this.prototype[methodName];\n\n    if (typeof method !== 'function') {\n      return false;\n    }\n\n    if (this === SchemaVisitor) {\n      // The SchemaVisitor class implements every visitor method.\n      return true;\n    }\n\n    var stub = SchemaVisitor.prototype[methodName];\n\n    if (method === stub) {\n      // If this.prototype[methodName] was just inherited from SchemaVisitor,\n      // then this class does not really implement the method.\n      return false;\n    }\n\n    return true;\n  }; // Concrete subclasses of SchemaVisitor should override one or more of these\n  // visitor methods, in order to express their interest in handling certain\n  // schema types/locations. Each method may return null to remove the given\n  // type from the schema, a non-null value of the same type to update the\n  // type in the schema, or nothing to leave the type as it was.\n\n  /* tslint:disable:no-empty */\n\n\n  SchemaVisitor.prototype.visitSchema = function (schema) {};\n\n  SchemaVisitor.prototype.visitScalar = function (scalar) {};\n\n  SchemaVisitor.prototype.visitObject = function (object) {};\n\n  SchemaVisitor.prototype.visitFieldDefinition = function (field, details) {};\n\n  SchemaVisitor.prototype.visitArgumentDefinition = function (argument, details) {};\n\n  SchemaVisitor.prototype.visitInterface = function (iface) {};\n\n  SchemaVisitor.prototype.visitUnion = function (union) {};\n\n  SchemaVisitor.prototype.visitEnum = function (type) {};\n\n  SchemaVisitor.prototype.visitEnumValue = function (value, details) {};\n\n  SchemaVisitor.prototype.visitInputObject = function (object) {};\n\n  SchemaVisitor.prototype.visitInputFieldDefinition = function (field, details) {};\n\n  return SchemaVisitor;\n}();\n\nexports.SchemaVisitor = SchemaVisitor; // Generic function for visiting GraphQLSchema objects.\n\nfunction visitSchema(schema, // To accommodate as many different visitor patterns as possible, the\n// visitSchema function does not simply accept a single instance of the\n// SchemaVisitor class, but instead accepts a function that takes the\n// current VisitableSchemaType object and the name of a visitor method and\n// returns an array of SchemaVisitor instances that implement the visitor\n// method and have an interest in handling the given VisitableSchemaType\n// object. In the simplest case, this function can always return an array\n// containing a single visitor object, without even looking at the type or\n// methodName parameters. In other cases, this function might sometimes\n// return an empty array to indicate there are no visitors that should be\n// applied to the given VisitableSchemaType object. For an example of a\n// visitor pattern that benefits from this abstraction, see the\n// SchemaDirectiveVisitor class below.\nvisitorSelector) {\n  // Helper function that calls visitorSelector and applies the resulting\n  // visitors to the given type, with arguments [type, ...args].\n  function callMethod(methodName, type) {\n    var args = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      args[_i - 2] = arguments[_i];\n    }\n\n    visitorSelector(type, methodName).every(function (visitor) {\n      var newType = visitor[methodName].apply(visitor, __spreadArrays([type], args));\n\n      if (typeof newType === 'undefined') {\n        // Keep going without modifying type.\n        return true;\n      }\n\n      if (methodName === 'visitSchema' || type instanceof graphql_1.GraphQLSchema) {\n        throw new Error(\"Method \" + methodName + \" cannot replace schema with \" + newType);\n      }\n\n      if (newType === null) {\n        // Stop the loop and return null form callMethod, which will cause\n        // the type to be removed from the schema.\n        type = null;\n        return false;\n      } // Update type to the new type returned by the visitor method, so that\n      // later directives will see the new type, and callMethod will return\n      // the final type.\n\n\n      type = newType;\n      return true;\n    }); // If there were no directives for this type object, or if all visitor\n    // methods returned nothing, type will be returned unmodified.\n\n    return type;\n  } // Recursive helper function that calls any appropriate visitor methods for\n  // each object in the schema, then traverses the object's children (if any).\n\n\n  function visit(type) {\n    if (type instanceof graphql_1.GraphQLSchema) {\n      // Unlike the other types, the root GraphQLSchema object cannot be\n      // replaced by visitor methods, because that would make life very hard\n      // for SchemaVisitor subclasses that rely on the original schema object.\n      callMethod('visitSchema', type);\n      updateEachKey(type.getTypeMap(), function (namedType, typeName) {\n        if (!typeName.startsWith('__')) {\n          // Call visit recursively to let it determine which concrete\n          // subclass of GraphQLNamedType we found in the type map. Because\n          // we're using updateEachKey, the result of visit(namedType) may\n          // cause the type to be removed or replaced.\n          return visit(namedType);\n        }\n      });\n      return type;\n    }\n\n    if (type instanceof graphql_1.GraphQLObjectType) {\n      // Note that callMethod('visitObject', type) may not actually call any\n      // methods, if there are no @directive annotations associated with this\n      // type, or if this SchemaDirectiveVisitor subclass does not override\n      // the visitObject method.\n      var newObject = callMethod('visitObject', type);\n\n      if (newObject) {\n        visitFields(newObject);\n      }\n\n      return newObject;\n    }\n\n    if (type instanceof graphql_1.GraphQLInterfaceType) {\n      var newInterface = callMethod('visitInterface', type);\n\n      if (newInterface) {\n        visitFields(newInterface);\n      }\n\n      return newInterface;\n    }\n\n    if (type instanceof graphql_1.GraphQLInputObjectType) {\n      var newInputObject_1 = callMethod('visitInputObject', type);\n\n      if (newInputObject_1) {\n        updateEachKey(newInputObject_1.getFields(), function (field) {\n          // Since we call a different method for input object fields, we\n          // can't reuse the visitFields function here.\n          return callMethod('visitInputFieldDefinition', field, {\n            objectType: newInputObject_1\n          });\n        });\n      }\n\n      return newInputObject_1;\n    }\n\n    if (type instanceof graphql_1.GraphQLScalarType) {\n      return callMethod('visitScalar', type);\n    }\n\n    if (type instanceof graphql_1.GraphQLUnionType) {\n      return callMethod('visitUnion', type);\n    }\n\n    if (type instanceof graphql_1.GraphQLEnumType) {\n      var newEnum_1 = callMethod('visitEnum', type);\n\n      if (newEnum_1) {\n        updateEachKey(newEnum_1.getValues(), function (value) {\n          return callMethod('visitEnumValue', value, {\n            enumType: newEnum_1\n          });\n        });\n      }\n\n      return newEnum_1;\n    }\n\n    throw new Error(\"Unexpected schema type: \" + type);\n  }\n\n  function visitFields(type) {\n    updateEachKey(type.getFields(), function (field) {\n      // It would be nice if we could call visit(field) recursively here, but\n      // GraphQLField is merely a type, not a value that can be detected using\n      // an instanceof check, so we have to visit the fields in this lexical\n      // context, so that TypeScript can validate the call to\n      // visitFieldDefinition.\n      var newField = callMethod('visitFieldDefinition', field, {\n        // While any field visitor needs a reference to the field object, some\n        // field visitors may also need to know the enclosing (parent) type,\n        // perhaps to determine if the parent is a GraphQLObjectType or a\n        // GraphQLInterfaceType. To obtain a reference to the parent, a\n        // visitor method can have a second parameter, which will be an object\n        // with an .objectType property referring to the parent.\n        objectType: type\n      });\n\n      if (newField && newField.args) {\n        updateEachKey(newField.args, function (arg) {\n          return callMethod('visitArgumentDefinition', arg, {\n            // Like visitFieldDefinition, visitArgumentDefinition takes a\n            // second parameter that provides additional context, namely the\n            // parent .field and grandparent .objectType. Remember that the\n            // current GraphQLSchema is always available via this.schema.\n            field: newField,\n            objectType: type\n          });\n        });\n      }\n\n      return newField;\n    });\n  }\n\n  visit(schema); // Return the original schema for convenience, even though it cannot have\n  // been replaced or removed by the code above.\n\n  return schema;\n}\n\nexports.visitSchema = visitSchema; // Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n\nfunction healSchema(schema) {\n  heal(schema);\n  return schema;\n\n  function heal(type) {\n    if (type instanceof graphql_1.GraphQLSchema) {\n      var originalTypeMap_1 = type.getTypeMap();\n      var actualNamedTypeMap_1 = Object.create(null); // If any of the .name properties of the GraphQLNamedType objects in\n      // schema.getTypeMap() have changed, the keys of the type map need to\n      // be updated accordingly.\n\n      each(originalTypeMap_1, function (namedType, typeName) {\n        if (typeName.startsWith('__')) {\n          return;\n        }\n\n        var actualName = namedType.name;\n\n        if (actualName.startsWith('__')) {\n          return;\n        }\n\n        if (hasOwn.call(actualNamedTypeMap_1, actualName)) {\n          throw new Error(\"Duplicate schema type name \" + actualName);\n        }\n\n        actualNamedTypeMap_1[actualName] = namedType; // Note: we are deliberately leaving namedType in the schema by its\n        // original name (which might be different from actualName), so that\n        // references by that name can be healed.\n      }); // Now add back every named type by its actual name.\n\n      each(actualNamedTypeMap_1, function (namedType, typeName) {\n        originalTypeMap_1[typeName] = namedType;\n      }); // Directive declaration argument types can refer to named types.\n\n      each(type.getDirectives(), function (decl) {\n        if (decl.args) {\n          each(decl.args, function (arg) {\n            arg.type = healType(arg.type);\n          });\n        }\n      });\n      each(originalTypeMap_1, function (namedType, typeName) {\n        if (!typeName.startsWith('__')) {\n          heal(namedType);\n        }\n      });\n      updateEachKey(originalTypeMap_1, function (namedType, typeName) {\n        // Dangling references to renamed types should remain in the schema\n        // during healing, but must be removed now, so that the following\n        // invariant holds for all names: schema.getType(name).name === name\n        if (!typeName.startsWith('__') && !hasOwn.call(actualNamedTypeMap_1, typeName)) {\n          return null;\n        }\n      });\n    } else if (type instanceof graphql_1.GraphQLObjectType) {\n      healFields(type);\n      each(type.getInterfaces(), function (iface) {\n        return heal(iface);\n      });\n    } else if (type instanceof graphql_1.GraphQLInterfaceType) {\n      healFields(type);\n    } else if (type instanceof graphql_1.GraphQLInputObjectType) {\n      each(type.getFields(), function (field) {\n        field.type = healType(field.type);\n      });\n    } else if (type instanceof graphql_1.GraphQLScalarType) {// Nothing to do.\n    } else if (type instanceof graphql_1.GraphQLUnionType) {\n      updateEachKey(type.getTypes(), function (t) {\n        return healType(t);\n      });\n    } else if (type instanceof graphql_1.GraphQLEnumType) {// Nothing to do.\n    } else {\n      throw new Error(\"Unexpected schema type: \" + type);\n    }\n  }\n\n  function healFields(type) {\n    each(type.getFields(), function (field) {\n      field.type = healType(field.type);\n\n      if (field.args) {\n        each(field.args, function (arg) {\n          arg.type = healType(arg.type);\n        });\n      }\n    });\n  }\n\n  function healType(type) {\n    // Unwrap the two known wrapper types\n    if (type instanceof graphql_1.GraphQLList) {\n      type = new graphql_1.GraphQLList(healType(type.ofType));\n    } else if (type instanceof graphql_1.GraphQLNonNull) {\n      type = new graphql_1.GraphQLNonNull(healType(type.ofType));\n    } else if (graphql_1.isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      var namedType = type;\n      var officialType = schema.getType(namedType.name);\n\n      if (officialType && namedType !== officialType) {\n        return officialType;\n      }\n    }\n\n    return type;\n  }\n}\n\nexports.healSchema = healSchema; // This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\n\nvar SchemaDirectiveVisitor =\n/** @class */\nfunction (_super) {\n  __extends(SchemaDirectiveVisitor, _super); // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n  // subclasses (not instances) to visitSchemaDirectives.\n\n\n  function SchemaDirectiveVisitor(config) {\n    var _this = _super.call(this) || this;\n\n    _this.name = config.name;\n    _this.args = config.args;\n    _this.visitedType = config.visitedType;\n    _this.schema = config.schema;\n    _this.context = config.context;\n    return _this;\n  } // Override this method to return a custom GraphQLDirective (or modify one\n  // already present in the schema) to enforce argument types, provide default\n  // argument values, or specify schema locations where this @directive may\n  // appear. By default, any declaration found in the schema will be returned.\n\n\n  SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {\n    return schema.getDirective(directiveName);\n  }; // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n  // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n  // instance to visit the object decorated by the @directive.\n\n\n  SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, directiveVisitors, // Optional context object that will be available to all visitor instances\n  // via this.context. Defaults to an empty null-prototype object.\n  context) {\n    if (context === void 0) {\n      context = Object.create(null);\n    } // If the schema declares any directives for public consumption, record\n    // them here so that we can properly coerce arguments when/if we encounter\n    // an occurrence of the directive while walking the schema below.\n\n\n    var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors); // Map from directive names to lists of SchemaDirectiveVisitor instances\n    // created while visiting the schema.\n\n    var createdVisitors = Object.create(null);\n    Object.keys(directiveVisitors).forEach(function (directiveName) {\n      createdVisitors[directiveName] = [];\n    });\n\n    function visitorSelector(type, methodName) {\n      var visitors = [];\n      var directiveNodes = type.astNode && type.astNode.directives;\n\n      if (!directiveNodes) {\n        return visitors;\n      }\n\n      directiveNodes.forEach(function (directiveNode) {\n        var directiveName = directiveNode.name.value;\n\n        if (!hasOwn.call(directiveVisitors, directiveName)) {\n          return;\n        }\n\n        var visitorClass = directiveVisitors[directiveName]; // Avoid creating visitor objects if visitorClass does not override\n        // the visitor method named by methodName.\n\n        if (!visitorClass.implementsVisitorMethod(methodName)) {\n          return;\n        }\n\n        var decl = declaredDirectives[directiveName];\n        var args;\n\n        if (decl) {\n          // If this directive was explicitly declared, use the declared\n          // argument types (and any default values) to check, coerce, and/or\n          // supply default values for the given arguments.\n          args = values_1.getArgumentValues(decl, directiveNode);\n        } else {\n          // If this directive was not explicitly declared, just convert the\n          // argument nodes to their corresponding JavaScript values.\n          args = Object.create(null);\n          directiveNode.arguments.forEach(function (arg) {\n            args[arg.name.value] = valueFromASTUntyped(arg.value);\n          });\n        } // As foretold in comments near the top of the visitSchemaDirectives\n        // method, this is where instances of the SchemaDirectiveVisitor class\n        // get created and assigned names. While subclasses could override the\n        // constructor method, the constructor is marked as protected, so\n        // these are the only arguments that will ever be passed.\n\n\n        visitors.push(new visitorClass({\n          name: directiveName,\n          args: args,\n          visitedType: type,\n          schema: schema,\n          context: context\n        }));\n      });\n\n      if (visitors.length > 0) {\n        visitors.forEach(function (visitor) {\n          createdVisitors[visitor.name].push(visitor);\n        });\n      }\n\n      return visitors;\n    }\n\n    visitSchema(schema, visitorSelector); // Automatically update any references to named schema types replaced\n    // during the traversal, so implementors don't have to worry about that.\n\n    healSchema(schema);\n    return createdVisitors;\n  };\n\n  SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {\n    var declaredDirectives = Object.create(null);\n    each(schema.getDirectives(), function (decl) {\n      declaredDirectives[decl.name] = decl;\n    }); // If the visitor subclass overrides getDirectiveDeclaration, and it\n    // returns a non-null GraphQLDirective, use that instead of any directive\n    // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n    // goes to the trouble of implementing getDirectiveDeclaration, it should\n    // be able to rely on that implementation.\n\n    each(directiveVisitors, function (visitorClass, directiveName) {\n      var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\n\n      if (decl) {\n        declaredDirectives[directiveName] = decl;\n      }\n    });\n    each(declaredDirectives, function (decl, name) {\n      if (!hasOwn.call(directiveVisitors, name)) {\n        // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n        // multiple times with partial directiveVisitors maps, so it's not\n        // necessarily an error for directiveVisitors to be missing an\n        // implementation of a directive that was declared in the schema.\n        return;\n      }\n\n      var visitorClass = directiveVisitors[name];\n      each(decl.locations, function (loc) {\n        var visitorMethodName = directiveLocationToVisitorMethodName(loc);\n\n        if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) && !visitorClass.implementsVisitorMethod(visitorMethodName)) {\n          // While visitor subclasses may implement extra visitor methods,\n          // it's definitely a mistake if the GraphQLDirective declares itself\n          // applicable to certain schema locations, and the visitor subclass\n          // does not implement all the corresponding methods.\n          throw new Error(\"SchemaDirectiveVisitor for @\" + name + \" must implement \" + visitorMethodName + \" method\");\n        }\n      });\n    });\n    return declaredDirectives;\n  };\n\n  return SchemaDirectiveVisitor;\n}(SchemaVisitor);\n\nexports.SchemaDirectiveVisitor = SchemaDirectiveVisitor; // Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\n\nfunction directiveLocationToVisitorMethodName(loc) {\n  return 'visit' + loc.replace(/([^_]*)_?/g, function (wholeMatch, part) {\n    return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n  });\n}\n\nfunction each(arrayOrObject, callback) {\n  Object.keys(arrayOrObject).forEach(function (key) {\n    callback(arrayOrObject[key], key);\n  });\n} // A more powerful version of each that has the ability to replace or remove\n// array or object keys.\n\n\nfunction updateEachKey(arrayOrObject, // The callback can return nothing to leave the key untouched, null to remove\n// the key from the array or object, or a non-null V to replace the value.\ncallback) {\n  var deletedCount = 0;\n  Object.keys(arrayOrObject).forEach(function (key) {\n    var result = callback(arrayOrObject[key], key);\n\n    if (typeof result === 'undefined') {\n      return;\n    }\n\n    if (result === null) {\n      delete arrayOrObject[key];\n      deletedCount++;\n      return;\n    }\n\n    arrayOrObject[key] = result;\n  });\n\n  if (deletedCount > 0 && Array.isArray(arrayOrObject)) {\n    // Remove any holes from the array due to deleted elements.\n    arrayOrObject.splice(0).forEach(function (elem) {\n      arrayOrObject.push(elem);\n    });\n  }\n} // Similar to the graphql-js function of the same name, slightly simplified:\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\n\n\nfunction valueFromASTUntyped(valueNode) {\n  switch (valueNode.kind) {\n    case graphql_1.Kind.NULL:\n      return null;\n\n    case graphql_1.Kind.INT:\n      return parseInt(valueNode.value, 10);\n\n    case graphql_1.Kind.FLOAT:\n      return parseFloat(valueNode.value);\n\n    case graphql_1.Kind.STRING:\n    case graphql_1.Kind.ENUM:\n    case graphql_1.Kind.BOOLEAN:\n      return valueNode.value;\n\n    case graphql_1.Kind.LIST:\n      return valueNode.values.map(valueFromASTUntyped);\n\n    case graphql_1.Kind.OBJECT:\n      var obj_1 = Object.create(null);\n      valueNode.fields.forEach(function (field) {\n        obj_1[field.name.value] = valueFromASTUntyped(field.value);\n      });\n      return obj_1;\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error('Unexpected value kind: ' + valueNode.kind);\n  }\n}","map":{"version":3,"sources":["../src/schemaVisitor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\nvar values_1 = require(\"graphql/execution/values\");\nvar hasOwn = Object.prototype.hasOwnProperty;\n// Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\nvar SchemaVisitor = /** @class */ (function () {\n    function SchemaVisitor() {\n    }\n    // Determine if this SchemaVisitor (sub)class implements a particular\n    // visitor method.\n    SchemaVisitor.implementsVisitorMethod = function (methodName) {\n        if (!methodName.startsWith('visit')) {\n            return false;\n        }\n        var method = this.prototype[methodName];\n        if (typeof method !== 'function') {\n            return false;\n        }\n        if (this === SchemaVisitor) {\n            // The SchemaVisitor class implements every visitor method.\n            return true;\n        }\n        var stub = SchemaVisitor.prototype[methodName];\n        if (method === stub) {\n            // If this.prototype[methodName] was just inherited from SchemaVisitor,\n            // then this class does not really implement the method.\n            return false;\n        }\n        return true;\n    };\n    // Concrete subclasses of SchemaVisitor should override one or more of these\n    // visitor methods, in order to express their interest in handling certain\n    // schema types/locations. Each method may return null to remove the given\n    // type from the schema, a non-null value of the same type to update the\n    // type in the schema, or nothing to leave the type as it was.\n    /* tslint:disable:no-empty */\n    SchemaVisitor.prototype.visitSchema = function (schema) { };\n    SchemaVisitor.prototype.visitScalar = function (scalar) { };\n    SchemaVisitor.prototype.visitObject = function (object) { };\n    SchemaVisitor.prototype.visitFieldDefinition = function (field, details) { };\n    SchemaVisitor.prototype.visitArgumentDefinition = function (argument, details) { };\n    SchemaVisitor.prototype.visitInterface = function (iface) { };\n    SchemaVisitor.prototype.visitUnion = function (union) { };\n    SchemaVisitor.prototype.visitEnum = function (type) { };\n    SchemaVisitor.prototype.visitEnumValue = function (value, details) { };\n    SchemaVisitor.prototype.visitInputObject = function (object) { };\n    SchemaVisitor.prototype.visitInputFieldDefinition = function (field, details) { };\n    return SchemaVisitor;\n}());\nexports.SchemaVisitor = SchemaVisitor;\n// Generic function for visiting GraphQLSchema objects.\nfunction visitSchema(schema, \n// To accommodate as many different visitor patterns as possible, the\n// visitSchema function does not simply accept a single instance of the\n// SchemaVisitor class, but instead accepts a function that takes the\n// current VisitableSchemaType object and the name of a visitor method and\n// returns an array of SchemaVisitor instances that implement the visitor\n// method and have an interest in handling the given VisitableSchemaType\n// object. In the simplest case, this function can always return an array\n// containing a single visitor object, without even looking at the type or\n// methodName parameters. In other cases, this function might sometimes\n// return an empty array to indicate there are no visitors that should be\n// applied to the given VisitableSchemaType object. For an example of a\n// visitor pattern that benefits from this abstraction, see the\n// SchemaDirectiveVisitor class below.\nvisitorSelector) {\n    // Helper function that calls visitorSelector and applies the resulting\n    // visitors to the given type, with arguments [type, ...args].\n    function callMethod(methodName, type) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        visitorSelector(type, methodName).every(function (visitor) {\n            var newType = visitor[methodName].apply(visitor, __spreadArrays([type], args));\n            if (typeof newType === 'undefined') {\n                // Keep going without modifying type.\n                return true;\n            }\n            if (methodName === 'visitSchema' ||\n                type instanceof graphql_1.GraphQLSchema) {\n                throw new Error(\"Method \" + methodName + \" cannot replace schema with \" + newType);\n            }\n            if (newType === null) {\n                // Stop the loop and return null form callMethod, which will cause\n                // the type to be removed from the schema.\n                type = null;\n                return false;\n            }\n            // Update type to the new type returned by the visitor method, so that\n            // later directives will see the new type, and callMethod will return\n            // the final type.\n            type = newType;\n            return true;\n        });\n        // If there were no directives for this type object, or if all visitor\n        // methods returned nothing, type will be returned unmodified.\n        return type;\n    }\n    // Recursive helper function that calls any appropriate visitor methods for\n    // each object in the schema, then traverses the object's children (if any).\n    function visit(type) {\n        if (type instanceof graphql_1.GraphQLSchema) {\n            // Unlike the other types, the root GraphQLSchema object cannot be\n            // replaced by visitor methods, because that would make life very hard\n            // for SchemaVisitor subclasses that rely on the original schema object.\n            callMethod('visitSchema', type);\n            updateEachKey(type.getTypeMap(), function (namedType, typeName) {\n                if (!typeName.startsWith('__')) {\n                    // Call visit recursively to let it determine which concrete\n                    // subclass of GraphQLNamedType we found in the type map. Because\n                    // we're using updateEachKey, the result of visit(namedType) may\n                    // cause the type to be removed or replaced.\n                    return visit(namedType);\n                }\n            });\n            return type;\n        }\n        if (type instanceof graphql_1.GraphQLObjectType) {\n            // Note that callMethod('visitObject', type) may not actually call any\n            // methods, if there are no @directive annotations associated with this\n            // type, or if this SchemaDirectiveVisitor subclass does not override\n            // the visitObject method.\n            var newObject = callMethod('visitObject', type);\n            if (newObject) {\n                visitFields(newObject);\n            }\n            return newObject;\n        }\n        if (type instanceof graphql_1.GraphQLInterfaceType) {\n            var newInterface = callMethod('visitInterface', type);\n            if (newInterface) {\n                visitFields(newInterface);\n            }\n            return newInterface;\n        }\n        if (type instanceof graphql_1.GraphQLInputObjectType) {\n            var newInputObject_1 = callMethod('visitInputObject', type);\n            if (newInputObject_1) {\n                updateEachKey(newInputObject_1.getFields(), function (field) {\n                    // Since we call a different method for input object fields, we\n                    // can't reuse the visitFields function here.\n                    return callMethod('visitInputFieldDefinition', field, {\n                        objectType: newInputObject_1,\n                    });\n                });\n            }\n            return newInputObject_1;\n        }\n        if (type instanceof graphql_1.GraphQLScalarType) {\n            return callMethod('visitScalar', type);\n        }\n        if (type instanceof graphql_1.GraphQLUnionType) {\n            return callMethod('visitUnion', type);\n        }\n        if (type instanceof graphql_1.GraphQLEnumType) {\n            var newEnum_1 = callMethod('visitEnum', type);\n            if (newEnum_1) {\n                updateEachKey(newEnum_1.getValues(), function (value) {\n                    return callMethod('visitEnumValue', value, {\n                        enumType: newEnum_1,\n                    });\n                });\n            }\n            return newEnum_1;\n        }\n        throw new Error(\"Unexpected schema type: \" + type);\n    }\n    function visitFields(type) {\n        updateEachKey(type.getFields(), function (field) {\n            // It would be nice if we could call visit(field) recursively here, but\n            // GraphQLField is merely a type, not a value that can be detected using\n            // an instanceof check, so we have to visit the fields in this lexical\n            // context, so that TypeScript can validate the call to\n            // visitFieldDefinition.\n            var newField = callMethod('visitFieldDefinition', field, {\n                // While any field visitor needs a reference to the field object, some\n                // field visitors may also need to know the enclosing (parent) type,\n                // perhaps to determine if the parent is a GraphQLObjectType or a\n                // GraphQLInterfaceType. To obtain a reference to the parent, a\n                // visitor method can have a second parameter, which will be an object\n                // with an .objectType property referring to the parent.\n                objectType: type,\n            });\n            if (newField && newField.args) {\n                updateEachKey(newField.args, function (arg) {\n                    return callMethod('visitArgumentDefinition', arg, {\n                        // Like visitFieldDefinition, visitArgumentDefinition takes a\n                        // second parameter that provides additional context, namely the\n                        // parent .field and grandparent .objectType. Remember that the\n                        // current GraphQLSchema is always available via this.schema.\n                        field: newField,\n                        objectType: type,\n                    });\n                });\n            }\n            return newField;\n        });\n    }\n    visit(schema);\n    // Return the original schema for convenience, even though it cannot have\n    // been replaced or removed by the code above.\n    return schema;\n}\nexports.visitSchema = visitSchema;\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\nfunction healSchema(schema) {\n    heal(schema);\n    return schema;\n    function heal(type) {\n        if (type instanceof graphql_1.GraphQLSchema) {\n            var originalTypeMap_1 = type.getTypeMap();\n            var actualNamedTypeMap_1 = Object.create(null);\n            // If any of the .name properties of the GraphQLNamedType objects in\n            // schema.getTypeMap() have changed, the keys of the type map need to\n            // be updated accordingly.\n            each(originalTypeMap_1, function (namedType, typeName) {\n                if (typeName.startsWith('__')) {\n                    return;\n                }\n                var actualName = namedType.name;\n                if (actualName.startsWith('__')) {\n                    return;\n                }\n                if (hasOwn.call(actualNamedTypeMap_1, actualName)) {\n                    throw new Error(\"Duplicate schema type name \" + actualName);\n                }\n                actualNamedTypeMap_1[actualName] = namedType;\n                // Note: we are deliberately leaving namedType in the schema by its\n                // original name (which might be different from actualName), so that\n                // references by that name can be healed.\n            });\n            // Now add back every named type by its actual name.\n            each(actualNamedTypeMap_1, function (namedType, typeName) {\n                originalTypeMap_1[typeName] = namedType;\n            });\n            // Directive declaration argument types can refer to named types.\n            each(type.getDirectives(), function (decl) {\n                if (decl.args) {\n                    each(decl.args, function (arg) {\n                        arg.type = healType(arg.type);\n                    });\n                }\n            });\n            each(originalTypeMap_1, function (namedType, typeName) {\n                if (!typeName.startsWith('__')) {\n                    heal(namedType);\n                }\n            });\n            updateEachKey(originalTypeMap_1, function (namedType, typeName) {\n                // Dangling references to renamed types should remain in the schema\n                // during healing, but must be removed now, so that the following\n                // invariant holds for all names: schema.getType(name).name === name\n                if (!typeName.startsWith('__') &&\n                    !hasOwn.call(actualNamedTypeMap_1, typeName)) {\n                    return null;\n                }\n            });\n        }\n        else if (type instanceof graphql_1.GraphQLObjectType) {\n            healFields(type);\n            each(type.getInterfaces(), function (iface) { return heal(iface); });\n        }\n        else if (type instanceof graphql_1.GraphQLInterfaceType) {\n            healFields(type);\n        }\n        else if (type instanceof graphql_1.GraphQLInputObjectType) {\n            each(type.getFields(), function (field) {\n                field.type = healType(field.type);\n            });\n        }\n        else if (type instanceof graphql_1.GraphQLScalarType) {\n            // Nothing to do.\n        }\n        else if (type instanceof graphql_1.GraphQLUnionType) {\n            updateEachKey(type.getTypes(), function (t) { return healType(t); });\n        }\n        else if (type instanceof graphql_1.GraphQLEnumType) {\n            // Nothing to do.\n        }\n        else {\n            throw new Error(\"Unexpected schema type: \" + type);\n        }\n    }\n    function healFields(type) {\n        each(type.getFields(), function (field) {\n            field.type = healType(field.type);\n            if (field.args) {\n                each(field.args, function (arg) {\n                    arg.type = healType(arg.type);\n                });\n            }\n        });\n    }\n    function healType(type) {\n        // Unwrap the two known wrapper types\n        if (type instanceof graphql_1.GraphQLList) {\n            type = new graphql_1.GraphQLList(healType(type.ofType));\n        }\n        else if (type instanceof graphql_1.GraphQLNonNull) {\n            type = new graphql_1.GraphQLNonNull(healType(type.ofType));\n        }\n        else if (graphql_1.isNamedType(type)) {\n            // If a type annotation on a field or an argument or a union member is\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n            // of truth for all named schema types.\n            var namedType = type;\n            var officialType = schema.getType(namedType.name);\n            if (officialType && namedType !== officialType) {\n                return officialType;\n            }\n        }\n        return type;\n    }\n}\nexports.healSchema = healSchema;\n// This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\nvar SchemaDirectiveVisitor = /** @class */ (function (_super) {\n    __extends(SchemaDirectiveVisitor, _super);\n    // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n    // subclasses (not instances) to visitSchemaDirectives.\n    function SchemaDirectiveVisitor(config) {\n        var _this = _super.call(this) || this;\n        _this.name = config.name;\n        _this.args = config.args;\n        _this.visitedType = config.visitedType;\n        _this.schema = config.schema;\n        _this.context = config.context;\n        return _this;\n    }\n    // Override this method to return a custom GraphQLDirective (or modify one\n    // already present in the schema) to enforce argument types, provide default\n    // argument values, or specify schema locations where this @directive may\n    // appear. By default, any declaration found in the schema will be returned.\n    SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {\n        return schema.getDirective(directiveName);\n    };\n    // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n    // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n    // instance to visit the object decorated by the @directive.\n    SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, directiveVisitors, \n    // Optional context object that will be available to all visitor instances\n    // via this.context. Defaults to an empty null-prototype object.\n    context) {\n        if (context === void 0) { context = Object.create(null); }\n        // If the schema declares any directives for public consumption, record\n        // them here so that we can properly coerce arguments when/if we encounter\n        // an occurrence of the directive while walking the schema below.\n        var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors);\n        // Map from directive names to lists of SchemaDirectiveVisitor instances\n        // created while visiting the schema.\n        var createdVisitors = Object.create(null);\n        Object.keys(directiveVisitors).forEach(function (directiveName) {\n            createdVisitors[directiveName] = [];\n        });\n        function visitorSelector(type, methodName) {\n            var visitors = [];\n            var directiveNodes = type.astNode && type.astNode.directives;\n            if (!directiveNodes) {\n                return visitors;\n            }\n            directiveNodes.forEach(function (directiveNode) {\n                var directiveName = directiveNode.name.value;\n                if (!hasOwn.call(directiveVisitors, directiveName)) {\n                    return;\n                }\n                var visitorClass = directiveVisitors[directiveName];\n                // Avoid creating visitor objects if visitorClass does not override\n                // the visitor method named by methodName.\n                if (!visitorClass.implementsVisitorMethod(methodName)) {\n                    return;\n                }\n                var decl = declaredDirectives[directiveName];\n                var args;\n                if (decl) {\n                    // If this directive was explicitly declared, use the declared\n                    // argument types (and any default values) to check, coerce, and/or\n                    // supply default values for the given arguments.\n                    args = values_1.getArgumentValues(decl, directiveNode);\n                }\n                else {\n                    // If this directive was not explicitly declared, just convert the\n                    // argument nodes to their corresponding JavaScript values.\n                    args = Object.create(null);\n                    directiveNode.arguments.forEach(function (arg) {\n                        args[arg.name.value] = valueFromASTUntyped(arg.value);\n                    });\n                }\n                // As foretold in comments near the top of the visitSchemaDirectives\n                // method, this is where instances of the SchemaDirectiveVisitor class\n                // get created and assigned names. While subclasses could override the\n                // constructor method, the constructor is marked as protected, so\n                // these are the only arguments that will ever be passed.\n                visitors.push(new visitorClass({\n                    name: directiveName,\n                    args: args,\n                    visitedType: type,\n                    schema: schema,\n                    context: context,\n                }));\n            });\n            if (visitors.length > 0) {\n                visitors.forEach(function (visitor) {\n                    createdVisitors[visitor.name].push(visitor);\n                });\n            }\n            return visitors;\n        }\n        visitSchema(schema, visitorSelector);\n        // Automatically update any references to named schema types replaced\n        // during the traversal, so implementors don't have to worry about that.\n        healSchema(schema);\n        return createdVisitors;\n    };\n    SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {\n        var declaredDirectives = Object.create(null);\n        each(schema.getDirectives(), function (decl) {\n            declaredDirectives[decl.name] = decl;\n        });\n        // If the visitor subclass overrides getDirectiveDeclaration, and it\n        // returns a non-null GraphQLDirective, use that instead of any directive\n        // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n        // goes to the trouble of implementing getDirectiveDeclaration, it should\n        // be able to rely on that implementation.\n        each(directiveVisitors, function (visitorClass, directiveName) {\n            var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\n            if (decl) {\n                declaredDirectives[directiveName] = decl;\n            }\n        });\n        each(declaredDirectives, function (decl, name) {\n            if (!hasOwn.call(directiveVisitors, name)) {\n                // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n                // multiple times with partial directiveVisitors maps, so it's not\n                // necessarily an error for directiveVisitors to be missing an\n                // implementation of a directive that was declared in the schema.\n                return;\n            }\n            var visitorClass = directiveVisitors[name];\n            each(decl.locations, function (loc) {\n                var visitorMethodName = directiveLocationToVisitorMethodName(loc);\n                if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&\n                    !visitorClass.implementsVisitorMethod(visitorMethodName)) {\n                    // While visitor subclasses may implement extra visitor methods,\n                    // it's definitely a mistake if the GraphQLDirective declares itself\n                    // applicable to certain schema locations, and the visitor subclass\n                    // does not implement all the corresponding methods.\n                    throw new Error(\"SchemaDirectiveVisitor for @\" + name + \" must implement \" + visitorMethodName + \" method\");\n                }\n            });\n        });\n        return declaredDirectives;\n    };\n    return SchemaDirectiveVisitor;\n}(SchemaVisitor));\nexports.SchemaDirectiveVisitor = SchemaDirectiveVisitor;\n// Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\nfunction directiveLocationToVisitorMethodName(loc) {\n    return 'visit' + loc.replace(/([^_]*)_?/g, function (wholeMatch, part) {\n        return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n    });\n}\nfunction each(arrayOrObject, callback) {\n    Object.keys(arrayOrObject).forEach(function (key) {\n        callback(arrayOrObject[key], key);\n    });\n}\n// A more powerful version of each that has the ability to replace or remove\n// array or object keys.\nfunction updateEachKey(arrayOrObject, \n// The callback can return nothing to leave the key untouched, null to remove\n// the key from the array or object, or a non-null V to replace the value.\ncallback) {\n    var deletedCount = 0;\n    Object.keys(arrayOrObject).forEach(function (key) {\n        var result = callback(arrayOrObject[key], key);\n        if (typeof result === 'undefined') {\n            return;\n        }\n        if (result === null) {\n            delete arrayOrObject[key];\n            deletedCount++;\n            return;\n        }\n        arrayOrObject[key] = result;\n    });\n    if (deletedCount > 0 && Array.isArray(arrayOrObject)) {\n        // Remove any holes from the array due to deleted elements.\n        arrayOrObject.splice(0).forEach(function (elem) {\n            arrayOrObject.push(elem);\n        });\n    }\n}\n// Similar to the graphql-js function of the same name, slightly simplified:\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\nfunction valueFromASTUntyped(valueNode) {\n    switch (valueNode.kind) {\n        case graphql_1.Kind.NULL:\n            return null;\n        case graphql_1.Kind.INT:\n            return parseInt(valueNode.value, 10);\n        case graphql_1.Kind.FLOAT:\n            return parseFloat(valueNode.value);\n        case graphql_1.Kind.STRING:\n        case graphql_1.Kind.ENUM:\n        case graphql_1.Kind.BOOLEAN:\n            return valueNode.value;\n        case graphql_1.Kind.LIST:\n            return valueNode.values.map(valueFromASTUntyped);\n        case graphql_1.Kind.OBJECT:\n            var obj_1 = Object.create(null);\n            valueNode.fields.forEach(function (field) {\n                obj_1[field.name.value] = valueFromASTUntyped(field.value);\n            });\n            return obj_1;\n        /* istanbul ignore next */\n        default:\n            throw new Error('Unexpected value kind: ' + valueNode.kind);\n    }\n}\n//# sourceMappingURL=schemaVisitor.js.map"]},"metadata":{},"sourceType":"script"}