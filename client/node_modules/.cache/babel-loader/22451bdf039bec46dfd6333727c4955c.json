{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildServiceDefinition = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst graphql_2 = require(\"./utilities/graphql\");\n\nconst predicates_1 = require(\"./utilities/predicates\");\n\nfunction flattened(arr) {\n  return new Array().concat(...arr);\n}\n\nfunction buildServiceDefinition(modules) {\n  const errors = [];\n  const typeDefinitionsMap = Object.create(null);\n  const typeExtensionsMap = Object.create(null);\n  const directivesMap = Object.create(null);\n  const schemaDefinitions = [];\n  const schemaExtensions = [];\n\n  for (let module of modules) {\n    if (graphql_2.isNode(module) && graphql_2.isDocumentNode(module)) {\n      module = {\n        typeDefs: module\n      };\n    }\n\n    for (const definition of module.typeDefs.definitions) {\n      if (graphql_1.isTypeDefinitionNode(definition)) {\n        const typeName = definition.name.value;\n\n        if (typeDefinitionsMap[typeName]) {\n          typeDefinitionsMap[typeName].push(definition);\n        } else {\n          typeDefinitionsMap[typeName] = [definition];\n        }\n      } else if (graphql_1.isTypeExtensionNode(definition)) {\n        const typeName = definition.name.value;\n\n        if (typeExtensionsMap[typeName]) {\n          typeExtensionsMap[typeName].push(definition);\n        } else {\n          typeExtensionsMap[typeName] = [definition];\n        }\n      } else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n        const directiveName = definition.name.value;\n\n        if (directivesMap[directiveName]) {\n          directivesMap[directiveName].push(definition);\n        } else {\n          directivesMap[directiveName] = [definition];\n        }\n      } else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n        schemaDefinitions.push(definition);\n      } else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n        schemaExtensions.push(definition);\n      }\n    }\n  }\n\n  for (const [typeName, typeDefinitions] of Object.entries(typeDefinitionsMap)) {\n    if (typeDefinitions.length > 1) {\n      errors.push(new graphql_1.GraphQLError(`Type \"${typeName}\" was defined more than once.`, typeDefinitions));\n    }\n  }\n\n  for (const [directiveName, directives] of Object.entries(directivesMap)) {\n    if (directives.length > 1) {\n      errors.push(new graphql_1.GraphQLError(`Directive \"${directiveName}\" was defined more than once.`, directives));\n    }\n  }\n\n  let operationTypeMap;\n\n  if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n    operationTypeMap = {};\n    const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];\n    const operationTypes = flattened([schemaDefinition, ...schemaExtensions].map(node => node.operationTypes).filter(predicates_1.isNotNullOrUndefined));\n\n    for (const operationType of operationTypes) {\n      const typeName = operationType.type.name.value;\n      const operation = operationType.operation;\n\n      if (operationTypeMap[operation]) {\n        throw new graphql_1.GraphQLError(`Must provide only one ${operation} type in schema.`, [schemaDefinition]);\n      }\n\n      if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {\n        throw new graphql_1.GraphQLError(`Specified ${operation} type \"${typeName}\" not found in document.`, [schemaDefinition]);\n      }\n\n      operationTypeMap[operation] = typeName;\n    }\n  } else {\n    operationTypeMap = {\n      query: \"Query\",\n      mutation: \"Mutation\",\n      subscription: \"Subscription\"\n    };\n  }\n\n  for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {\n    if (!typeDefinitionsMap[typeName]) {\n      if (Object.values(operationTypeMap).includes(typeName)) {\n        typeDefinitionsMap[typeName] = [{\n          kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: typeName\n          }\n        }];\n      } else {\n        errors.push(new graphql_1.GraphQLError(`Cannot extend type \"${typeName}\" because it does not exist in the existing schema.`, typeExtensions));\n      }\n    }\n  }\n\n  if (errors.length > 0) {\n    return {\n      errors\n    };\n  }\n\n  try {\n    const typeDefinitions = flattened(Object.values(typeDefinitionsMap));\n    const directives = flattened(Object.values(directivesMap));\n    let schema = graphql_1.buildASTSchema({\n      kind: graphql_1.Kind.DOCUMENT,\n      definitions: [...typeDefinitions, ...directives]\n    });\n    const typeExtensions = flattened(Object.values(typeExtensionsMap));\n\n    if (typeExtensions.length > 0) {\n      schema = graphql_1.extendSchema(schema, {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: typeExtensions\n      });\n    }\n\n    for (const module of modules) {\n      if (!module.resolvers) continue;\n      addResolversToSchema(schema, module.resolvers);\n    }\n\n    return {\n      schema\n    };\n  } catch (error) {\n    return {\n      errors: [error]\n    };\n  }\n}\n\nexports.buildServiceDefinition = buildServiceDefinition;\n\nfunction addResolversToSchema(schema, resolvers) {\n  for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n    const type = schema.getType(typeName);\n    if (!graphql_1.isObjectType(type)) continue;\n    const fieldMap = type.getFields();\n\n    for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n      if (fieldName.startsWith(\"__\")) {\n        type[fieldName.substring(2)] = fieldConfig;\n        continue;\n      }\n\n      const field = fieldMap[fieldName];\n      if (!field) continue;\n\n      if (typeof fieldConfig === \"function\") {\n        field.resolve = fieldConfig;\n      } else {\n        if (fieldConfig.resolve) {\n          field.resolve = fieldConfig.resolve;\n        }\n\n        if (fieldConfig.subscribe) {\n          field.subscribe = fieldConfig.subscribe;\n        }\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../src/buildServiceDefinition.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildServiceDefinition = void 0;\nconst graphql_1 = require(\"graphql\");\nconst graphql_2 = require(\"./utilities/graphql\");\nconst predicates_1 = require(\"./utilities/predicates\");\nfunction flattened(arr) {\n    return new Array().concat(...arr);\n}\nfunction buildServiceDefinition(modules) {\n    const errors = [];\n    const typeDefinitionsMap = Object.create(null);\n    const typeExtensionsMap = Object.create(null);\n    const directivesMap = Object.create(null);\n    const schemaDefinitions = [];\n    const schemaExtensions = [];\n    for (let module of modules) {\n        if (graphql_2.isNode(module) && graphql_2.isDocumentNode(module)) {\n            module = { typeDefs: module };\n        }\n        for (const definition of module.typeDefs.definitions) {\n            if (graphql_1.isTypeDefinitionNode(definition)) {\n                const typeName = definition.name.value;\n                if (typeDefinitionsMap[typeName]) {\n                    typeDefinitionsMap[typeName].push(definition);\n                }\n                else {\n                    typeDefinitionsMap[typeName] = [definition];\n                }\n            }\n            else if (graphql_1.isTypeExtensionNode(definition)) {\n                const typeName = definition.name.value;\n                if (typeExtensionsMap[typeName]) {\n                    typeExtensionsMap[typeName].push(definition);\n                }\n                else {\n                    typeExtensionsMap[typeName] = [definition];\n                }\n            }\n            else if (definition.kind === graphql_1.Kind.DIRECTIVE_DEFINITION) {\n                const directiveName = definition.name.value;\n                if (directivesMap[directiveName]) {\n                    directivesMap[directiveName].push(definition);\n                }\n                else {\n                    directivesMap[directiveName] = [definition];\n                }\n            }\n            else if (definition.kind === graphql_1.Kind.SCHEMA_DEFINITION) {\n                schemaDefinitions.push(definition);\n            }\n            else if (definition.kind === graphql_1.Kind.SCHEMA_EXTENSION) {\n                schemaExtensions.push(definition);\n            }\n        }\n    }\n    for (const [typeName, typeDefinitions] of Object.entries(typeDefinitionsMap)) {\n        if (typeDefinitions.length > 1) {\n            errors.push(new graphql_1.GraphQLError(`Type \"${typeName}\" was defined more than once.`, typeDefinitions));\n        }\n    }\n    for (const [directiveName, directives] of Object.entries(directivesMap)) {\n        if (directives.length > 1) {\n            errors.push(new graphql_1.GraphQLError(`Directive \"${directiveName}\" was defined more than once.`, directives));\n        }\n    }\n    let operationTypeMap;\n    if (schemaDefinitions.length > 0 || schemaExtensions.length > 0) {\n        operationTypeMap = {};\n        const schemaDefinition = schemaDefinitions[schemaDefinitions.length - 1];\n        const operationTypes = flattened([schemaDefinition, ...schemaExtensions]\n            .map(node => node.operationTypes)\n            .filter(predicates_1.isNotNullOrUndefined));\n        for (const operationType of operationTypes) {\n            const typeName = operationType.type.name.value;\n            const operation = operationType.operation;\n            if (operationTypeMap[operation]) {\n                throw new graphql_1.GraphQLError(`Must provide only one ${operation} type in schema.`, [schemaDefinition]);\n            }\n            if (!(typeDefinitionsMap[typeName] || typeExtensionsMap[typeName])) {\n                throw new graphql_1.GraphQLError(`Specified ${operation} type \"${typeName}\" not found in document.`, [schemaDefinition]);\n            }\n            operationTypeMap[operation] = typeName;\n        }\n    }\n    else {\n        operationTypeMap = {\n            query: \"Query\",\n            mutation: \"Mutation\",\n            subscription: \"Subscription\"\n        };\n    }\n    for (const [typeName, typeExtensions] of Object.entries(typeExtensionsMap)) {\n        if (!typeDefinitionsMap[typeName]) {\n            if (Object.values(operationTypeMap).includes(typeName)) {\n                typeDefinitionsMap[typeName] = [\n                    {\n                        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: typeName\n                        }\n                    }\n                ];\n            }\n            else {\n                errors.push(new graphql_1.GraphQLError(`Cannot extend type \"${typeName}\" because it does not exist in the existing schema.`, typeExtensions));\n            }\n        }\n    }\n    if (errors.length > 0) {\n        return { errors };\n    }\n    try {\n        const typeDefinitions = flattened(Object.values(typeDefinitionsMap));\n        const directives = flattened(Object.values(directivesMap));\n        let schema = graphql_1.buildASTSchema({\n            kind: graphql_1.Kind.DOCUMENT,\n            definitions: [...typeDefinitions, ...directives]\n        });\n        const typeExtensions = flattened(Object.values(typeExtensionsMap));\n        if (typeExtensions.length > 0) {\n            schema = graphql_1.extendSchema(schema, {\n                kind: graphql_1.Kind.DOCUMENT,\n                definitions: typeExtensions\n            });\n        }\n        for (const module of modules) {\n            if (!module.resolvers)\n                continue;\n            addResolversToSchema(schema, module.resolvers);\n        }\n        return { schema };\n    }\n    catch (error) {\n        return { errors: [error] };\n    }\n}\nexports.buildServiceDefinition = buildServiceDefinition;\nfunction addResolversToSchema(schema, resolvers) {\n    for (const [typeName, fieldConfigs] of Object.entries(resolvers)) {\n        const type = schema.getType(typeName);\n        if (!graphql_1.isObjectType(type))\n            continue;\n        const fieldMap = type.getFields();\n        for (const [fieldName, fieldConfig] of Object.entries(fieldConfigs)) {\n            if (fieldName.startsWith(\"__\")) {\n                type[fieldName.substring(2)] = fieldConfig;\n                continue;\n            }\n            const field = fieldMap[fieldName];\n            if (!field)\n                continue;\n            if (typeof fieldConfig === \"function\") {\n                field.resolve = fieldConfig;\n            }\n            else {\n                if (fieldConfig.resolve) {\n                    field.resolve = fieldConfig.resolve;\n                }\n                if (fieldConfig.subscribe) {\n                    field.subscribe = fieldConfig.subscribe;\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=buildServiceDefinition.js.map"]},"metadata":{},"sourceType":"script"}