{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar resolveFromParentTypename_1 = require(\"./resolveFromParentTypename\");\n\nvar backcompatOptions = {\n  commentDescriptions: true\n};\n\nfunction typeFromAST(node) {\n  switch (node.kind) {\n    case graphql_1.Kind.OBJECT_TYPE_DEFINITION:\n      return makeObjectType(node);\n\n    case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:\n      return makeInterfaceType(node);\n\n    case graphql_1.Kind.ENUM_TYPE_DEFINITION:\n      return makeEnumType(node);\n\n    case graphql_1.Kind.UNION_TYPE_DEFINITION:\n      return makeUnionType(node);\n\n    case graphql_1.Kind.SCALAR_TYPE_DEFINITION:\n      return makeScalarType(node);\n\n    case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n      return makeInputObjectType(node);\n\n    case graphql_1.Kind.DIRECTIVE_DEFINITION:\n      return makeDirective(node);\n\n    default:\n      return null;\n  }\n}\n\nexports.default = typeFromAST;\n\nfunction makeObjectType(node) {\n  return new graphql_1.GraphQLObjectType({\n    name: node.name.value,\n    fields: function () {\n      return makeFields(node.fields);\n    },\n    interfaces: function () {\n      return node.interfaces.map(function (iface) {\n        return createNamedStub(iface.name.value, 'interface');\n      });\n    },\n    description: graphql_1.getDescription(node, backcompatOptions)\n  });\n}\n\nfunction makeInterfaceType(node) {\n  return new graphql_1.GraphQLInterfaceType({\n    name: node.name.value,\n    fields: function () {\n      return makeFields(node.fields);\n    },\n    description: graphql_1.getDescription(node, backcompatOptions),\n    resolveType: function (parent, context, info) {\n      return resolveFromParentTypename_1.default(parent, info.schema);\n    }\n  });\n}\n\nfunction makeEnumType(node) {\n  var values = {};\n  node.values.forEach(function (value) {\n    values[value.name.value] = {\n      description: graphql_1.getDescription(value, backcompatOptions)\n    };\n  });\n  return new graphql_1.GraphQLEnumType({\n    name: node.name.value,\n    values: values,\n    description: graphql_1.getDescription(node, backcompatOptions)\n  });\n}\n\nfunction makeUnionType(node) {\n  return new graphql_1.GraphQLUnionType({\n    name: node.name.value,\n    types: function () {\n      return node.types.map(function (type) {\n        return resolveType(type, 'object');\n      });\n    },\n    description: graphql_1.getDescription(node, backcompatOptions),\n    resolveType: function (parent, context, info) {\n      return resolveFromParentTypename_1.default(parent, info.schema);\n    }\n  });\n}\n\nfunction makeScalarType(node) {\n  return new graphql_1.GraphQLScalarType({\n    name: node.name.value,\n    description: graphql_1.getDescription(node, backcompatOptions),\n    serialize: function () {\n      return null;\n    },\n    // Note: validation calls the parse functions to determine if a\n    // literal value is correct. Returning null would cause use of custom\n    // scalars to always fail validation. Returning false causes them to\n    // always pass validation.\n    parseValue: function () {\n      return false;\n    },\n    parseLiteral: function () {\n      return false;\n    }\n  });\n}\n\nfunction makeInputObjectType(node) {\n  return new graphql_1.GraphQLInputObjectType({\n    name: node.name.value,\n    fields: function () {\n      return makeValues(node.fields);\n    },\n    description: graphql_1.getDescription(node, backcompatOptions)\n  });\n}\n\nfunction makeFields(nodes) {\n  var result = {};\n  nodes.forEach(function (node) {\n    var deprecatedDirective = node.directives.find(function (directive) {\n      return directive && directive.name && directive.name.value === 'deprecated';\n    });\n    var deprecatedArgument = deprecatedDirective && deprecatedDirective.arguments && deprecatedDirective.arguments.find(function (arg) {\n      return arg && arg.name && arg.name.value === 'reason';\n    });\n    var deprecationReason = deprecatedArgument && deprecatedArgument.value && deprecatedArgument.value.value;\n    result[node.name.value] = {\n      type: resolveType(node.type, 'object'),\n      args: makeValues(node.arguments),\n      description: graphql_1.getDescription(node, backcompatOptions),\n      deprecationReason: deprecationReason\n    };\n  });\n  return result;\n}\n\nfunction makeValues(nodes) {\n  var result = {};\n  nodes.forEach(function (node) {\n    var type = resolveType(node.type, 'input');\n    result[node.name.value] = {\n      type: type,\n      defaultValue: graphql_1.valueFromAST(node.defaultValue, type),\n      description: graphql_1.getDescription(node, backcompatOptions)\n    };\n  });\n  return result;\n}\n\nfunction resolveType(node, type) {\n  switch (node.kind) {\n    case graphql_1.Kind.LIST_TYPE:\n      return new graphql_1.GraphQLList(resolveType(node.type, type));\n\n    case graphql_1.Kind.NON_NULL_TYPE:\n      return new graphql_1.GraphQLNonNull(resolveType(node.type, type));\n\n    default:\n      return createNamedStub(node.name.value, type);\n  }\n}\n\nfunction createNamedStub(name, type) {\n  var constructor;\n\n  if (type === 'object') {\n    constructor = graphql_1.GraphQLObjectType;\n  } else if (type === 'interface') {\n    constructor = graphql_1.GraphQLInterfaceType;\n  } else {\n    constructor = graphql_1.GraphQLInputObjectType;\n  }\n\n  return new constructor({\n    name: name,\n    fields: {\n      __fake: {\n        type: graphql_1.GraphQLString\n      }\n    }\n  });\n}\n\nfunction makeDirective(node) {\n  var locations = [];\n  node.locations.forEach(function (location) {\n    if (location.value in graphql_1.DirectiveLocation) {\n      locations.push(location.value);\n    }\n  });\n  return new graphql_1.GraphQLDirective({\n    name: node.name.value,\n    description: node.description ? node.description.value : null,\n    args: makeValues(node.arguments),\n    locations: locations\n  });\n}","map":{"version":3,"sources":["../../src/stitching/typeFromAST.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\nvar resolveFromParentTypename_1 = require(\"./resolveFromParentTypename\");\nvar backcompatOptions = { commentDescriptions: true };\nfunction typeFromAST(node) {\n    switch (node.kind) {\n        case graphql_1.Kind.OBJECT_TYPE_DEFINITION:\n            return makeObjectType(node);\n        case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:\n            return makeInterfaceType(node);\n        case graphql_1.Kind.ENUM_TYPE_DEFINITION:\n            return makeEnumType(node);\n        case graphql_1.Kind.UNION_TYPE_DEFINITION:\n            return makeUnionType(node);\n        case graphql_1.Kind.SCALAR_TYPE_DEFINITION:\n            return makeScalarType(node);\n        case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n            return makeInputObjectType(node);\n        case graphql_1.Kind.DIRECTIVE_DEFINITION:\n            return makeDirective(node);\n        default:\n            return null;\n    }\n}\nexports.default = typeFromAST;\nfunction makeObjectType(node) {\n    return new graphql_1.GraphQLObjectType({\n        name: node.name.value,\n        fields: function () { return makeFields(node.fields); },\n        interfaces: function () {\n            return node.interfaces.map(function (iface) { return createNamedStub(iface.name.value, 'interface'); });\n        },\n        description: graphql_1.getDescription(node, backcompatOptions),\n    });\n}\nfunction makeInterfaceType(node) {\n    return new graphql_1.GraphQLInterfaceType({\n        name: node.name.value,\n        fields: function () { return makeFields(node.fields); },\n        description: graphql_1.getDescription(node, backcompatOptions),\n        resolveType: function (parent, context, info) {\n            return resolveFromParentTypename_1.default(parent, info.schema);\n        },\n    });\n}\nfunction makeEnumType(node) {\n    var values = {};\n    node.values.forEach(function (value) {\n        values[value.name.value] = {\n            description: graphql_1.getDescription(value, backcompatOptions),\n        };\n    });\n    return new graphql_1.GraphQLEnumType({\n        name: node.name.value,\n        values: values,\n        description: graphql_1.getDescription(node, backcompatOptions),\n    });\n}\nfunction makeUnionType(node) {\n    return new graphql_1.GraphQLUnionType({\n        name: node.name.value,\n        types: function () {\n            return node.types.map(function (type) { return resolveType(type, 'object'); });\n        },\n        description: graphql_1.getDescription(node, backcompatOptions),\n        resolveType: function (parent, context, info) {\n            return resolveFromParentTypename_1.default(parent, info.schema);\n        },\n    });\n}\nfunction makeScalarType(node) {\n    return new graphql_1.GraphQLScalarType({\n        name: node.name.value,\n        description: graphql_1.getDescription(node, backcompatOptions),\n        serialize: function () { return null; },\n        // Note: validation calls the parse functions to determine if a\n        // literal value is correct. Returning null would cause use of custom\n        // scalars to always fail validation. Returning false causes them to\n        // always pass validation.\n        parseValue: function () { return false; },\n        parseLiteral: function () { return false; },\n    });\n}\nfunction makeInputObjectType(node) {\n    return new graphql_1.GraphQLInputObjectType({\n        name: node.name.value,\n        fields: function () { return makeValues(node.fields); },\n        description: graphql_1.getDescription(node, backcompatOptions),\n    });\n}\nfunction makeFields(nodes) {\n    var result = {};\n    nodes.forEach(function (node) {\n        var deprecatedDirective = node.directives.find(function (directive) {\n            return directive && directive.name && directive.name.value === 'deprecated';\n        });\n        var deprecatedArgument = deprecatedDirective &&\n            deprecatedDirective.arguments &&\n            deprecatedDirective.arguments.find(function (arg) { return arg && arg.name && arg.name.value === 'reason'; });\n        var deprecationReason = deprecatedArgument &&\n            deprecatedArgument.value &&\n            deprecatedArgument.value.value;\n        result[node.name.value] = {\n            type: resolveType(node.type, 'object'),\n            args: makeValues(node.arguments),\n            description: graphql_1.getDescription(node, backcompatOptions),\n            deprecationReason: deprecationReason,\n        };\n    });\n    return result;\n}\nfunction makeValues(nodes) {\n    var result = {};\n    nodes.forEach(function (node) {\n        var type = resolveType(node.type, 'input');\n        result[node.name.value] = {\n            type: type,\n            defaultValue: graphql_1.valueFromAST(node.defaultValue, type),\n            description: graphql_1.getDescription(node, backcompatOptions),\n        };\n    });\n    return result;\n}\nfunction resolveType(node, type) {\n    switch (node.kind) {\n        case graphql_1.Kind.LIST_TYPE:\n            return new graphql_1.GraphQLList(resolveType(node.type, type));\n        case graphql_1.Kind.NON_NULL_TYPE:\n            return new graphql_1.GraphQLNonNull(resolveType(node.type, type));\n        default:\n            return createNamedStub(node.name.value, type);\n    }\n}\nfunction createNamedStub(name, type) {\n    var constructor;\n    if (type === 'object') {\n        constructor = graphql_1.GraphQLObjectType;\n    }\n    else if (type === 'interface') {\n        constructor = graphql_1.GraphQLInterfaceType;\n    }\n    else {\n        constructor = graphql_1.GraphQLInputObjectType;\n    }\n    return new constructor({\n        name: name,\n        fields: {\n            __fake: {\n                type: graphql_1.GraphQLString,\n            },\n        },\n    });\n}\nfunction makeDirective(node) {\n    var locations = [];\n    node.locations.forEach(function (location) {\n        if (location.value in graphql_1.DirectiveLocation) {\n            locations.push(location.value);\n        }\n    });\n    return new graphql_1.GraphQLDirective({\n        name: node.name.value,\n        description: node.description ? node.description.value : null,\n        args: makeValues(node.arguments),\n        locations: locations,\n    });\n}\n//# sourceMappingURL=typeFromAST.js.map"]},"metadata":{},"sourceType":"script"}