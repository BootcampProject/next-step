{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.processGraphQLRequest = exports.APQ_CACHE_PREFIX = exports.InvalidGraphQLRequestError = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst graphql_extensions_1 = require(\"graphql-extensions\");\n\nconst schemaInstrumentation_1 = require(\"./utils/schemaInstrumentation\");\n\nconst apollo_server_errors_1 = require(\"apollo-server-errors\");\n\nconst apollo_server_types_1 = require(\"apollo-server-types\");\n\nObject.defineProperty(exports, \"InvalidGraphQLRequestError\", {\n  enumerable: true,\n  get: function () {\n    return apollo_server_types_1.InvalidGraphQLRequestError;\n  }\n});\n\nconst dispatcher_1 = require(\"./utils/dispatcher\");\n\nconst apollo_server_caching_1 = require(\"apollo-server-caching\");\n\nconst createSHA_1 = __importDefault(require(\"./utils/createSHA\"));\n\nconst runHttpQuery_1 = require(\"./runHttpQuery\");\n\nexports.APQ_CACHE_PREFIX = 'apq:';\n\nfunction computeQueryHash(query) {\n  return createSHA_1.default('sha256').update(query).digest('hex');\n}\n\nconst symbolExtensionDeprecationDone = Symbol(\"apolloServerExtensionDeprecationDone\");\n\nfunction processGraphQLRequest(config, requestContext) {\n  var _a;\n\n  return __awaiter(this, void 0, void 0, function* () {\n    const logger = requestContext.logger || console;\n    const metrics = requestContext.metrics = requestContext.metrics || Object.create(null);\n    const extensionStack = initializeExtensionStack();\n    requestContext.context._extensionStack = extensionStack;\n    const dispatcher = initializeRequestListenerDispatcher();\n    yield initializeDataSources();\n    const request = requestContext.request;\n    let {\n      query,\n      extensions\n    } = request;\n    let queryHash;\n    let persistedQueryCache;\n    metrics.persistedQueryHit = false;\n    metrics.persistedQueryRegister = false;\n\n    if (extensions && extensions.persistedQuery) {\n      if (!config.persistedQueries || !config.persistedQueries.cache) {\n        return yield emitErrorAndThrow(new apollo_server_errors_1.PersistedQueryNotSupportedError());\n      } else if (extensions.persistedQuery.version !== 1) {\n        return yield emitErrorAndThrow(new apollo_server_types_1.InvalidGraphQLRequestError('Unsupported persisted query version'));\n      }\n\n      persistedQueryCache = config.persistedQueries.cache;\n\n      if (!(persistedQueryCache instanceof apollo_server_caching_1.PrefixingKeyValueCache)) {\n        persistedQueryCache = new apollo_server_caching_1.PrefixingKeyValueCache(persistedQueryCache, exports.APQ_CACHE_PREFIX);\n      }\n\n      queryHash = extensions.persistedQuery.sha256Hash;\n\n      if (query === undefined) {\n        query = yield persistedQueryCache.get(queryHash);\n\n        if (query) {\n          metrics.persistedQueryHit = true;\n        } else {\n          return yield emitErrorAndThrow(new apollo_server_errors_1.PersistedQueryNotFoundError());\n        }\n      } else {\n        const computedQueryHash = computeQueryHash(query);\n\n        if (queryHash !== computedQueryHash) {\n          return yield emitErrorAndThrow(new apollo_server_types_1.InvalidGraphQLRequestError('provided sha does not match query'));\n        }\n\n        metrics.persistedQueryRegister = true;\n      }\n    } else if (query) {\n      queryHash = computeQueryHash(query);\n    } else {\n      return yield emitErrorAndThrow(new apollo_server_types_1.InvalidGraphQLRequestError('Must provide query string.'));\n    }\n\n    requestContext.queryHash = queryHash;\n    requestContext.source = query;\n    yield dispatcher.invokeHookAsync('didResolveSource', requestContext);\n    const requestDidEnd = extensionStack.requestDidStart({\n      request: request.http,\n      queryString: request.query,\n      operationName: request.operationName,\n      variables: request.variables,\n      extensions: request.extensions,\n      context: requestContext.context,\n      persistedQueryHit: metrics.persistedQueryHit,\n      persistedQueryRegister: metrics.persistedQueryRegister,\n      requestContext: requestContext\n    });\n\n    try {\n      if (config.documentStore) {\n        try {\n          requestContext.document = yield config.documentStore.get(queryHash);\n        } catch (err) {\n          logger.warn('An error occurred while attempting to read from the documentStore. ' + (err && err.message) || err);\n        }\n      }\n\n      if (!requestContext.document) {\n        const parsingDidEnd = yield dispatcher.invokeDidStartHook('parsingDidStart', requestContext);\n\n        try {\n          requestContext.document = parse(query, config.parseOptions);\n          parsingDidEnd();\n        } catch (syntaxError) {\n          parsingDidEnd(syntaxError);\n          return yield sendErrorResponse(syntaxError, apollo_server_errors_1.SyntaxError);\n        }\n\n        const validationDidEnd = yield dispatcher.invokeDidStartHook('validationDidStart', requestContext);\n        const validationErrors = validate(requestContext.document);\n\n        if (validationErrors.length === 0) {\n          validationDidEnd();\n        } else {\n          validationDidEnd(validationErrors);\n          return yield sendErrorResponse(validationErrors, apollo_server_errors_1.ValidationError);\n        }\n\n        if (config.documentStore) {\n          Promise.resolve(config.documentStore.set(queryHash, requestContext.document)).catch(err => logger.warn('Could not store validated document. ' + (err && err.message) || err));\n        }\n      }\n\n      const operation = graphql_1.getOperationAST(requestContext.document, request.operationName);\n      requestContext.operation = operation || undefined;\n      requestContext.operationName = operation && operation.name && operation.name.value || null;\n\n      try {\n        yield dispatcher.invokeHookAsync('didResolveOperation', requestContext);\n      } catch (err) {\n        if (err instanceof runHttpQuery_1.HttpQueryError) {\n          const graphqlError = new graphql_1.GraphQLError(err.message);\n          graphqlError.stack = err.stack;\n          yield didEncounterErrors([graphqlError]);\n          throw err;\n        }\n\n        return yield sendErrorResponse(err);\n      }\n\n      if (metrics.persistedQueryRegister && persistedQueryCache) {\n        Promise.resolve(persistedQueryCache.set(queryHash, query, config.persistedQueries && typeof config.persistedQueries.ttl !== 'undefined' ? {\n          ttl: config.persistedQueries.ttl\n        } : Object.create(null))).catch(logger.warn);\n      }\n\n      let response = yield dispatcher.invokeHooksUntilNonNull('responseForOperation', requestContext);\n\n      if (response == null) {\n        const executionListeners = [];\n        dispatcher.invokeHookSync('executionDidStart', requestContext).forEach(executionListener => {\n          if (typeof executionListener === 'function') {\n            executionListeners.push({\n              executionDidEnd: executionListener\n            });\n          } else if (typeof executionListener === 'object') {\n            executionListeners.push(executionListener);\n          }\n        });\n        const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);\n\n        const invokeWillResolveField = function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return executionDispatcher.invokeDidStartHook('willResolveField', ...args);\n        };\n\n        Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, {\n          value: invokeWillResolveField\n        });\n\n        if (config.fieldResolver) {\n          Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolUserFieldResolver, {\n            value: config.fieldResolver\n          });\n        }\n\n        schemaInstrumentation_1.enablePluginsForSchemaResolvers(config.schema);\n\n        try {\n          const result = yield execute(requestContext);\n          const resultErrors = (_a = result.errors) === null || _a === void 0 ? void 0 : _a.map(e => {\n            var _a;\n\n            if (((_a = e.nodes) === null || _a === void 0 ? void 0 : _a.length) === 1 && e.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION && e.message.startsWith(`Variable \"$${e.nodes[0].variable.name.value}\" got invalid value `)) {\n              return apollo_server_errors_1.fromGraphQLError(e, {\n                errorClass: apollo_server_errors_1.UserInputError\n              });\n            }\n\n            return e;\n          });\n\n          if (resultErrors) {\n            yield didEncounterErrors(resultErrors);\n          }\n\n          response = Object.assign(Object.assign({}, result), {\n            errors: resultErrors ? formatErrors(resultErrors) : undefined\n          });\n          executionDispatcher.reverseInvokeHookSync('executionDidEnd');\n        } catch (executionError) {\n          executionDispatcher.reverseInvokeHookSync(\"executionDidEnd\", executionError);\n          return yield sendErrorResponse(executionError);\n        }\n      }\n\n      const formattedExtensions = extensionStack.format();\n\n      if (Object.keys(formattedExtensions).length > 0) {\n        response.extensions = formattedExtensions;\n      }\n\n      if (config.formatResponse) {\n        const formattedResponse = config.formatResponse(response, requestContext);\n\n        if (formattedResponse != null) {\n          response = formattedResponse;\n        }\n      }\n\n      return sendResponse(response);\n    } finally {\n      requestDidEnd();\n    }\n\n    function parse(query, parseOptions) {\n      const parsingDidEnd = extensionStack.parsingDidStart({\n        queryString: query\n      });\n\n      try {\n        return graphql_1.parse(query, parseOptions);\n      } finally {\n        parsingDidEnd();\n      }\n    }\n\n    function validate(document) {\n      let rules = graphql_1.specifiedRules;\n\n      if (config.validationRules) {\n        rules = rules.concat(config.validationRules);\n      }\n\n      const validationDidEnd = extensionStack.validationDidStart();\n\n      try {\n        return graphql_1.validate(config.schema, document, rules);\n      } finally {\n        validationDidEnd();\n      }\n    }\n\n    function execute(requestContext) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const {\n          request,\n          document\n        } = requestContext;\n        const executionArgs = {\n          schema: config.schema,\n          document,\n          rootValue: typeof config.rootValue === 'function' ? config.rootValue(document) : config.rootValue,\n          contextValue: requestContext.context,\n          variableValues: request.variables,\n          operationName: request.operationName,\n          fieldResolver: config.fieldResolver\n        };\n        const executionDidEnd = extensionStack.executionDidStart({\n          executionArgs\n        });\n\n        try {\n          if (config.executor) {\n            return yield config.executor(requestContext);\n          } else {\n            return yield graphql_1.execute(executionArgs);\n          }\n        } finally {\n          executionDidEnd();\n        }\n      });\n    }\n\n    function sendResponse(response) {\n      return __awaiter(this, void 0, void 0, function* () {\n        requestContext.response = extensionStack.willSendResponse({\n          graphqlResponse: Object.assign(Object.assign({}, requestContext.response), {\n            errors: response.errors,\n            data: response.data,\n            extensions: response.extensions\n          }),\n          context: requestContext.context\n        }).graphqlResponse;\n        yield dispatcher.invokeHookAsync('willSendResponse', requestContext);\n        return requestContext.response;\n      });\n    }\n\n    function emitErrorAndThrow(error) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield didEncounterErrors([error]);\n        throw error;\n      });\n    }\n\n    function didEncounterErrors(errors) {\n      return __awaiter(this, void 0, void 0, function* () {\n        requestContext.errors = errors;\n        extensionStack.didEncounterErrors(errors);\n        return yield dispatcher.invokeHookAsync('didEncounterErrors', requestContext);\n      });\n    }\n\n    function sendErrorResponse(errorOrErrors, errorClass) {\n      return __awaiter(this, void 0, void 0, function* () {\n        const errors = Array.isArray(errorOrErrors) ? errorOrErrors : [errorOrErrors];\n        yield didEncounterErrors(errors);\n        return sendResponse({\n          errors: formatErrors(errors.map(err => apollo_server_errors_1.fromGraphQLError(err, errorClass && {\n            errorClass\n          })))\n        });\n      });\n    }\n\n    function formatErrors(errors) {\n      return apollo_server_errors_1.formatApolloErrors(errors, {\n        formatter: config.formatError,\n        debug: requestContext.debug\n      });\n    }\n\n    function initializeRequestListenerDispatcher() {\n      const requestListeners = [];\n\n      if (config.plugins) {\n        for (const plugin of config.plugins) {\n          if (!plugin.requestDidStart) continue;\n          const listener = plugin.requestDidStart(requestContext);\n\n          if (listener) {\n            requestListeners.push(listener);\n          }\n        }\n      }\n\n      return new dispatcher_1.Dispatcher(requestListeners);\n    }\n\n    function initializeExtensionStack() {\n      var _a;\n\n      if ((_a = config.extensions) === null || _a === void 0 ? void 0 : _a.length) {\n        graphql_extensions_1.enableGraphQLExtensions(config.schema);\n      }\n\n      const extensions = config.extensions ? config.extensions.map(f => f()) : [];\n      const hasOwn = Object.prototype.hasOwnProperty;\n      extensions.forEach(extension => {\n        if (!extension.constructor || hasOwn.call(extension.constructor, symbolExtensionDeprecationDone)) {\n          return;\n        }\n\n        Object.defineProperty(extension.constructor, symbolExtensionDeprecationDone, {\n          value: true\n        });\n        const extensionName = extension.constructor.name;\n        logger.warn('[deprecated] ' + (extensionName ? 'A \"' + extensionName + '\" ' : 'An anonymous extension ') + 'was defined within the \"extensions\" configuration for ' + 'Apollo Server.  The API on which this extension is built ' + '(\"graphql-extensions\") is being deprecated in the next major ' + 'version of Apollo Server in favor of the new plugin API.  See ' + 'https://go.apollo.dev/s/plugins for the documentation on how ' + 'these plugins are to be defined and used.');\n      });\n      return new graphql_extensions_1.GraphQLExtensionStack(extensions);\n    }\n\n    function initializeDataSources() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (config.dataSources) {\n          const context = requestContext.context;\n          const dataSources = config.dataSources();\n          const initializers = [];\n\n          for (const dataSource of Object.values(dataSources)) {\n            if (dataSource.initialize) {\n              initializers.push(dataSource.initialize({\n                context,\n                cache: requestContext.cache\n              }));\n            }\n          }\n\n          yield Promise.all(initializers);\n\n          if ('dataSources' in context) {\n            throw new Error('Please use the dataSources config option instead of putting dataSources on the context yourself.');\n          }\n\n          context.dataSources = dataSources;\n        }\n      });\n    }\n  });\n}\n\nexports.processGraphQLRequest = processGraphQLRequest;","map":{"version":3,"sources":["../src/requestPipeline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.processGraphQLRequest = exports.APQ_CACHE_PREFIX = exports.InvalidGraphQLRequestError = void 0;\nconst graphql_1 = require(\"graphql\");\nconst graphql_extensions_1 = require(\"graphql-extensions\");\nconst schemaInstrumentation_1 = require(\"./utils/schemaInstrumentation\");\nconst apollo_server_errors_1 = require(\"apollo-server-errors\");\nconst apollo_server_types_1 = require(\"apollo-server-types\");\nObject.defineProperty(exports, \"InvalidGraphQLRequestError\", { enumerable: true, get: function () { return apollo_server_types_1.InvalidGraphQLRequestError; } });\nconst dispatcher_1 = require(\"./utils/dispatcher\");\nconst apollo_server_caching_1 = require(\"apollo-server-caching\");\nconst createSHA_1 = __importDefault(require(\"./utils/createSHA\"));\nconst runHttpQuery_1 = require(\"./runHttpQuery\");\nexports.APQ_CACHE_PREFIX = 'apq:';\nfunction computeQueryHash(query) {\n    return createSHA_1.default('sha256')\n        .update(query)\n        .digest('hex');\n}\nconst symbolExtensionDeprecationDone = Symbol(\"apolloServerExtensionDeprecationDone\");\nfunction processGraphQLRequest(config, requestContext) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const logger = requestContext.logger || console;\n        const metrics = requestContext.metrics =\n            requestContext.metrics || Object.create(null);\n        const extensionStack = initializeExtensionStack();\n        requestContext.context._extensionStack = extensionStack;\n        const dispatcher = initializeRequestListenerDispatcher();\n        yield initializeDataSources();\n        const request = requestContext.request;\n        let { query, extensions } = request;\n        let queryHash;\n        let persistedQueryCache;\n        metrics.persistedQueryHit = false;\n        metrics.persistedQueryRegister = false;\n        if (extensions && extensions.persistedQuery) {\n            if (!config.persistedQueries || !config.persistedQueries.cache) {\n                return yield emitErrorAndThrow(new apollo_server_errors_1.PersistedQueryNotSupportedError());\n            }\n            else if (extensions.persistedQuery.version !== 1) {\n                return yield emitErrorAndThrow(new apollo_server_types_1.InvalidGraphQLRequestError('Unsupported persisted query version'));\n            }\n            persistedQueryCache = config.persistedQueries.cache;\n            if (!(persistedQueryCache instanceof apollo_server_caching_1.PrefixingKeyValueCache)) {\n                persistedQueryCache = new apollo_server_caching_1.PrefixingKeyValueCache(persistedQueryCache, exports.APQ_CACHE_PREFIX);\n            }\n            queryHash = extensions.persistedQuery.sha256Hash;\n            if (query === undefined) {\n                query = yield persistedQueryCache.get(queryHash);\n                if (query) {\n                    metrics.persistedQueryHit = true;\n                }\n                else {\n                    return yield emitErrorAndThrow(new apollo_server_errors_1.PersistedQueryNotFoundError());\n                }\n            }\n            else {\n                const computedQueryHash = computeQueryHash(query);\n                if (queryHash !== computedQueryHash) {\n                    return yield emitErrorAndThrow(new apollo_server_types_1.InvalidGraphQLRequestError('provided sha does not match query'));\n                }\n                metrics.persistedQueryRegister = true;\n            }\n        }\n        else if (query) {\n            queryHash = computeQueryHash(query);\n        }\n        else {\n            return yield emitErrorAndThrow(new apollo_server_types_1.InvalidGraphQLRequestError('Must provide query string.'));\n        }\n        requestContext.queryHash = queryHash;\n        requestContext.source = query;\n        yield dispatcher.invokeHookAsync('didResolveSource', requestContext);\n        const requestDidEnd = extensionStack.requestDidStart({\n            request: request.http,\n            queryString: request.query,\n            operationName: request.operationName,\n            variables: request.variables,\n            extensions: request.extensions,\n            context: requestContext.context,\n            persistedQueryHit: metrics.persistedQueryHit,\n            persistedQueryRegister: metrics.persistedQueryRegister,\n            requestContext: requestContext,\n        });\n        try {\n            if (config.documentStore) {\n                try {\n                    requestContext.document = yield config.documentStore.get(queryHash);\n                }\n                catch (err) {\n                    logger.warn('An error occurred while attempting to read from the documentStore. '\n                        + (err && err.message) || err);\n                }\n            }\n            if (!requestContext.document) {\n                const parsingDidEnd = yield dispatcher.invokeDidStartHook('parsingDidStart', requestContext);\n                try {\n                    requestContext.document = parse(query, config.parseOptions);\n                    parsingDidEnd();\n                }\n                catch (syntaxError) {\n                    parsingDidEnd(syntaxError);\n                    return yield sendErrorResponse(syntaxError, apollo_server_errors_1.SyntaxError);\n                }\n                const validationDidEnd = yield dispatcher.invokeDidStartHook('validationDidStart', requestContext);\n                const validationErrors = validate(requestContext.document);\n                if (validationErrors.length === 0) {\n                    validationDidEnd();\n                }\n                else {\n                    validationDidEnd(validationErrors);\n                    return yield sendErrorResponse(validationErrors, apollo_server_errors_1.ValidationError);\n                }\n                if (config.documentStore) {\n                    Promise.resolve(config.documentStore.set(queryHash, requestContext.document)).catch(err => logger.warn('Could not store validated document. ' +\n                        (err && err.message) || err));\n                }\n            }\n            const operation = graphql_1.getOperationAST(requestContext.document, request.operationName);\n            requestContext.operation = operation || undefined;\n            requestContext.operationName =\n                (operation && operation.name && operation.name.value) || null;\n            try {\n                yield dispatcher.invokeHookAsync('didResolveOperation', requestContext);\n            }\n            catch (err) {\n                if (err instanceof runHttpQuery_1.HttpQueryError) {\n                    const graphqlError = new graphql_1.GraphQLError(err.message);\n                    graphqlError.stack = err.stack;\n                    yield didEncounterErrors([graphqlError]);\n                    throw err;\n                }\n                return yield sendErrorResponse(err);\n            }\n            if (metrics.persistedQueryRegister && persistedQueryCache) {\n                Promise.resolve(persistedQueryCache.set(queryHash, query, config.persistedQueries &&\n                    typeof config.persistedQueries.ttl !== 'undefined'\n                    ? {\n                        ttl: config.persistedQueries.ttl,\n                    }\n                    : Object.create(null))).catch(logger.warn);\n            }\n            let response = yield dispatcher.invokeHooksUntilNonNull('responseForOperation', requestContext);\n            if (response == null) {\n                const executionListeners = [];\n                dispatcher.invokeHookSync('executionDidStart', requestContext).forEach(executionListener => {\n                    if (typeof executionListener === 'function') {\n                        executionListeners.push({\n                            executionDidEnd: executionListener,\n                        });\n                    }\n                    else if (typeof executionListener === 'object') {\n                        executionListeners.push(executionListener);\n                    }\n                });\n                const executionDispatcher = new dispatcher_1.Dispatcher(executionListeners);\n                const invokeWillResolveField = (...args) => executionDispatcher.invokeDidStartHook('willResolveField', ...args);\n                Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolExecutionDispatcherWillResolveField, { value: invokeWillResolveField });\n                if (config.fieldResolver) {\n                    Object.defineProperty(requestContext.context, schemaInstrumentation_1.symbolUserFieldResolver, { value: config.fieldResolver });\n                }\n                schemaInstrumentation_1.enablePluginsForSchemaResolvers(config.schema);\n                try {\n                    const result = yield execute(requestContext);\n                    const resultErrors = (_a = result.errors) === null || _a === void 0 ? void 0 : _a.map((e) => {\n                        var _a;\n                        if (((_a = e.nodes) === null || _a === void 0 ? void 0 : _a.length) === 1 &&\n                            e.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION &&\n                            e.message.startsWith(`Variable \"$${e.nodes[0].variable.name.value}\" got invalid value `)) {\n                            return apollo_server_errors_1.fromGraphQLError(e, {\n                                errorClass: apollo_server_errors_1.UserInputError,\n                            });\n                        }\n                        return e;\n                    });\n                    if (resultErrors) {\n                        yield didEncounterErrors(resultErrors);\n                    }\n                    response = Object.assign(Object.assign({}, result), { errors: resultErrors ? formatErrors(resultErrors) : undefined });\n                    executionDispatcher.reverseInvokeHookSync('executionDidEnd');\n                }\n                catch (executionError) {\n                    executionDispatcher.reverseInvokeHookSync(\"executionDidEnd\", executionError);\n                    return yield sendErrorResponse(executionError);\n                }\n            }\n            const formattedExtensions = extensionStack.format();\n            if (Object.keys(formattedExtensions).length > 0) {\n                response.extensions = formattedExtensions;\n            }\n            if (config.formatResponse) {\n                const formattedResponse = config.formatResponse(response, requestContext);\n                if (formattedResponse != null) {\n                    response = formattedResponse;\n                }\n            }\n            return sendResponse(response);\n        }\n        finally {\n            requestDidEnd();\n        }\n        function parse(query, parseOptions) {\n            const parsingDidEnd = extensionStack.parsingDidStart({\n                queryString: query,\n            });\n            try {\n                return graphql_1.parse(query, parseOptions);\n            }\n            finally {\n                parsingDidEnd();\n            }\n        }\n        function validate(document) {\n            let rules = graphql_1.specifiedRules;\n            if (config.validationRules) {\n                rules = rules.concat(config.validationRules);\n            }\n            const validationDidEnd = extensionStack.validationDidStart();\n            try {\n                return graphql_1.validate(config.schema, document, rules);\n            }\n            finally {\n                validationDidEnd();\n            }\n        }\n        function execute(requestContext) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { request, document } = requestContext;\n                const executionArgs = {\n                    schema: config.schema,\n                    document,\n                    rootValue: typeof config.rootValue === 'function'\n                        ? config.rootValue(document)\n                        : config.rootValue,\n                    contextValue: requestContext.context,\n                    variableValues: request.variables,\n                    operationName: request.operationName,\n                    fieldResolver: config.fieldResolver,\n                };\n                const executionDidEnd = extensionStack.executionDidStart({\n                    executionArgs,\n                });\n                try {\n                    if (config.executor) {\n                        return yield config.executor(requestContext);\n                    }\n                    else {\n                        return yield graphql_1.execute(executionArgs);\n                    }\n                }\n                finally {\n                    executionDidEnd();\n                }\n            });\n        }\n        function sendResponse(response) {\n            return __awaiter(this, void 0, void 0, function* () {\n                requestContext.response = extensionStack.willSendResponse({\n                    graphqlResponse: Object.assign(Object.assign({}, requestContext.response), { errors: response.errors, data: response.data, extensions: response.extensions }),\n                    context: requestContext.context,\n                }).graphqlResponse;\n                yield dispatcher.invokeHookAsync('willSendResponse', requestContext);\n                return requestContext.response;\n            });\n        }\n        function emitErrorAndThrow(error) {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield didEncounterErrors([error]);\n                throw error;\n            });\n        }\n        function didEncounterErrors(errors) {\n            return __awaiter(this, void 0, void 0, function* () {\n                requestContext.errors = errors;\n                extensionStack.didEncounterErrors(errors);\n                return yield dispatcher.invokeHookAsync('didEncounterErrors', requestContext);\n            });\n        }\n        function sendErrorResponse(errorOrErrors, errorClass) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const errors = Array.isArray(errorOrErrors)\n                    ? errorOrErrors\n                    : [errorOrErrors];\n                yield didEncounterErrors(errors);\n                return sendResponse({\n                    errors: formatErrors(errors.map(err => apollo_server_errors_1.fromGraphQLError(err, errorClass && {\n                        errorClass,\n                    }))),\n                });\n            });\n        }\n        function formatErrors(errors) {\n            return apollo_server_errors_1.formatApolloErrors(errors, {\n                formatter: config.formatError,\n                debug: requestContext.debug,\n            });\n        }\n        function initializeRequestListenerDispatcher() {\n            const requestListeners = [];\n            if (config.plugins) {\n                for (const plugin of config.plugins) {\n                    if (!plugin.requestDidStart)\n                        continue;\n                    const listener = plugin.requestDidStart(requestContext);\n                    if (listener) {\n                        requestListeners.push(listener);\n                    }\n                }\n            }\n            return new dispatcher_1.Dispatcher(requestListeners);\n        }\n        function initializeExtensionStack() {\n            var _a;\n            if ((_a = config.extensions) === null || _a === void 0 ? void 0 : _a.length) {\n                graphql_extensions_1.enableGraphQLExtensions(config.schema);\n            }\n            const extensions = config.extensions ? config.extensions.map(f => f()) : [];\n            const hasOwn = Object.prototype.hasOwnProperty;\n            extensions.forEach((extension) => {\n                if (!extension.constructor ||\n                    hasOwn.call(extension.constructor, symbolExtensionDeprecationDone)) {\n                    return;\n                }\n                Object.defineProperty(extension.constructor, symbolExtensionDeprecationDone, { value: true });\n                const extensionName = extension.constructor.name;\n                logger.warn('[deprecated] ' +\n                    (extensionName\n                        ? 'A \"' + extensionName + '\" '\n                        : 'An anonymous extension ') +\n                    'was defined within the \"extensions\" configuration for ' +\n                    'Apollo Server.  The API on which this extension is built ' +\n                    '(\"graphql-extensions\") is being deprecated in the next major ' +\n                    'version of Apollo Server in favor of the new plugin API.  See ' +\n                    'https://go.apollo.dev/s/plugins for the documentation on how ' +\n                    'these plugins are to be defined and used.');\n            });\n            return new graphql_extensions_1.GraphQLExtensionStack(extensions);\n        }\n        function initializeDataSources() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (config.dataSources) {\n                    const context = requestContext.context;\n                    const dataSources = config.dataSources();\n                    const initializers = [];\n                    for (const dataSource of Object.values(dataSources)) {\n                        if (dataSource.initialize) {\n                            initializers.push(dataSource.initialize({\n                                context,\n                                cache: requestContext.cache,\n                            }));\n                        }\n                    }\n                    yield Promise.all(initializers);\n                    if ('dataSources' in context) {\n                        throw new Error('Please use the dataSources config option instead of putting dataSources on the context yourself.');\n                    }\n                    context.dataSources = dataSources;\n                }\n            });\n        }\n    });\n}\nexports.processGraphQLRequest = processGraphQLRequest;\n//# sourceMappingURL=requestPipeline.js.map"]},"metadata":{},"sourceType":"script"}