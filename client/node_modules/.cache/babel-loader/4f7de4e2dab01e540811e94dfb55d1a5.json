{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar iterall_1 = require(\"iterall\");\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\n\n\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n  var _a;\n\n  var $return;\n  var abruptClose;\n\n  if (typeof iterator.return === 'function') {\n    $return = iterator.return;\n\n    abruptClose = function (error) {\n      var rethrow = function () {\n        return Promise.reject(error);\n      };\n\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result) {\n    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  var mapReject;\n\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    var reject_1 = rejectCallback;\n\n    mapReject = function (error) {\n      return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);\n    };\n  }\n\n  return _a = {\n    next: function () {\n      return iterator.next().then(mapResult, mapReject);\n    },\n    return: function () {\n      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n    throw: function (error) {\n      if (typeof iterator.throw === 'function') {\n        return iterator.throw(error).then(mapResult, mapReject);\n      }\n\n      return Promise.reject(error).catch(abruptClose);\n    }\n  }, _a[iterall_1.$$asyncIterator] = function () {\n    return this;\n  }, _a;\n}\n\nexports.default = mapAsyncIterator;\n\nfunction asyncMapValue(value, callback) {\n  return new Promise(function (resolve) {\n    return resolve(callback(value));\n  });\n}\n\nfunction iteratorResult(value) {\n  return {\n    value: value,\n    done: false\n  };\n}","map":{"version":3,"sources":["../../src/stitching/mapAsyncIterator.ts"],"names":[],"mappings":";;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAEA;;;AAGG;;;AACH,SAAwB,gBAAxB,CACE,QADF,EAEE,QAFF,EAGE,cAHF,EAGsB;;;AAEpB,MAAI,OAAJ;AACA,MAAI,WAAJ;;AAEA,MAAI,OAAO,QAAQ,CAAC,MAAhB,KAA2B,UAA/B,EAA2C;AACzC,IAAA,OAAO,GAAG,QAAQ,CAAC,MAAnB;;AACA,IAAA,WAAW,GAAG,UAAC,KAAD,EAAW;AACvB,UAAM,OAAO,GAAG,YAAA;AAAM,eAAA,OAAO,CAAC,MAAR,CAAA,KAAA,CAAA;AAAqB,OAA3C;;AACA,aAAO,OAAO,CAAC,IAAR,CAAa,QAAb,EAAuB,IAAvB,CAA4B,OAA5B,EAAqC,OAArC,CAAP;AACD,KAHD;AAID;;AAED,WAAS,SAAT,CAAmB,MAAnB,EAA8B;AAC5B,WAAO,MAAM,CAAC,IAAP,GACH,MADG,GAEH,aAAa,CAAC,MAAM,CAAC,KAAR,EAAe,QAAf,CAAb,CAAsC,IAAtC,CAA2C,cAA3C,EAA2D,WAA3D,CAFJ;AAGD;;AAED,MAAI,SAAJ;;AACA,MAAI,cAAJ,EAAoB;AAClB;AACA,QAAM,QAAM,GAAG,cAAf;;AACA,IAAA,SAAS,GAAG,UAAC,KAAD,EAAW;AACrB,aAAA,aAAa,CAAC,KAAD,EAAQ,QAAR,CAAb,CAA6B,IAA7B,CAAkC,cAAlC,EAAkD,WAAlD,CAAA;AAA8D,KADhE;AAED;;AAED,SAAQ,EAAA,GAAA;AACN,IAAA,IAAI,EAAA,YAAA;AACF,aAAO,QAAQ,CAAC,IAAT,GAAgB,IAAhB,CAAqB,SAArB,EAAgC,SAAhC,CAAP;AACD,KAHK;AAIN,IAAA,MAAM,EAAA,YAAA;AACJ,aAAO,OAAO,GACV,OAAO,CAAC,IAAR,CAAa,QAAb,EAAuB,IAAvB,CAA4B,SAA5B,EAAuC,SAAvC,CADU,GAEV,OAAO,CAAC,OAAR,CAAgB;AAAE,QAAA,KAAK,EAAE,SAAT;AAAoB,QAAA,IAAI,EAAE;AAA1B,OAAhB,CAFJ;AAGD,KARK;AASN,IAAA,KAAK,EAAL,UAAM,KAAN,EAAgB;AACd,UAAI,OAAO,QAAQ,CAAC,KAAhB,KAA0B,UAA9B,EAA0C;AACxC,eAAO,QAAQ,CAAC,KAAT,CAAe,KAAf,EAAsB,IAAtB,CAA2B,SAA3B,EAAsC,SAAtC,CAAP;AACD;;AACD,aAAO,OAAO,CAAC,MAAR,CAAe,KAAf,EAAsB,KAAtB,CAA4B,WAA5B,CAAP;AACD;AAdK,GAAA,EAeN,EAAA,CAAC,SAAA,CAAA,eAAD,CAAA,GAAA,YAAA;AACE,WAAO,IAAP;AACD,GAjBK,EAkBC,EAlBT;AAmBD;;AAjDD,OAAA,CAAA,OAAA,GAAA,gBAAA;;AAmDA,SAAS,aAAT,CACE,KADF,EAEE,QAFF,EAEwC;AAEtC,SAAO,IAAI,OAAJ,CAAY,UAAA,OAAA,EAAO;AAAI,WAAA,OAAO,CAAC,QAAQ,CAAhB,KAAgB,CAAT,CAAP;AAAwB,GAA/C,CAAP;AACD;;AAED,SAAS,cAAT,CAA2B,KAA3B,EAAmC;AACjC,SAAO;AAAE,IAAA,KAAK,EAAA,KAAP;AAAS,IAAA,IAAI,EAAE;AAAf,GAAP;AACD","sourceRoot":"","sourcesContent":["Object.defineProperty(exports, \"__esModule\", { value: true });\nvar iterall_1 = require(\"iterall\");\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n    var _a;\n    var $return;\n    var abruptClose;\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = function (error) {\n            var rethrow = function () { return Promise.reject(error); };\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        return result.done\n            ? result\n            : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n    }\n    var mapReject;\n    if (rejectCallback) {\n        // Capture rejectCallback to ensure it cannot be null.\n        var reject_1 = rejectCallback;\n        mapReject = function (error) {\n            return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);\n        };\n    }\n    return _a = {\n            next: function () {\n                return iterator.next().then(mapResult, mapReject);\n            },\n            return: function () {\n                return $return\n                    ? $return.call(iterator).then(mapResult, mapReject)\n                    : Promise.resolve({ value: undefined, done: true });\n            },\n            throw: function (error) {\n                if (typeof iterator.throw === 'function') {\n                    return iterator.throw(error).then(mapResult, mapReject);\n                }\n                return Promise.reject(error).catch(abruptClose);\n            }\n        },\n        _a[iterall_1.$$asyncIterator] = function () {\n            return this;\n        },\n        _a;\n}\nexports.default = mapAsyncIterator;\nfunction asyncMapValue(value, callback) {\n    return new Promise(function (resolve) { return resolve(callback(value)); });\n}\nfunction iteratorResult(value) {\n    return { value: value, done: false };\n}\n//# sourceMappingURL=mapAsyncIterator.js.map"]},"metadata":{},"sourceType":"script"}