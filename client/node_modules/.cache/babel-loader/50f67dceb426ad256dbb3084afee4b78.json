{"ast":null,"code":"var Decoder = require('../utils').Decoder,\n    decodeText = require('../utils').decodeText;\n\nvar RE_CHARSET = /^charset$/i;\nUrlEncoded.detect = /^application\\/x-www-form-urlencoded/i;\n\nfunction UrlEncoded(boy, cfg) {\n  if (!(this instanceof UrlEncoded)) return new UrlEncoded(boy, cfg);\n  var limits = cfg.limits,\n      headers = cfg.headers,\n      parsedConType = cfg.parsedConType;\n  this.boy = boy;\n  this.fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;\n  this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === 'number' ? limits.fieldNameSize : 100;\n  this.fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;\n  var charset;\n\n  for (var i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {\n      charset = parsedConType[i][1].toLowerCase();\n      break;\n    }\n  }\n\n  if (charset === undefined) charset = cfg.defCharset || 'utf8';\n  this.decoder = new Decoder();\n  this.charset = charset;\n  this._fields = 0;\n  this._state = 'key';\n  this._checkingBytes = true;\n  this._bytesKey = 0;\n  this._bytesVal = 0;\n  this._key = '';\n  this._val = '';\n  this._keyTrunc = false;\n  this._valTrunc = false;\n  this._hitlimit = false;\n}\n\nUrlEncoded.prototype.write = function (data, cb) {\n  if (this._fields === this.fieldsLimit) {\n    if (!this.boy.hitFieldsLimit) {\n      this.boy.hitFieldsLimit = true;\n      this.boy.emit('fieldsLimit');\n    }\n\n    return cb();\n  }\n\n  var idxeq,\n      idxamp,\n      i,\n      p = 0,\n      len = data.length;\n\n  while (p < len) {\n    if (this._state === 'key') {\n      idxeq = idxamp = undefined;\n\n      for (i = p; i < len; ++i) {\n        if (!this._checkingBytes) ++p;\n\n        if (data[i] === 0x3D\n        /*=*/\n        ) {\n          idxeq = i;\n          break;\n        } else if (data[i] === 0x26\n        /*&*/\n        ) {\n          idxamp = i;\n          break;\n        }\n\n        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {\n          this._hitLimit = true;\n          break;\n        } else if (this._checkingBytes) ++this._bytesKey;\n      }\n\n      if (idxeq !== undefined) {\n        // key with assignment\n        if (idxeq > p) this._key += this.decoder.write(data.toString('binary', p, idxeq));\n        this._state = 'val';\n        this._hitLimit = false;\n        this._checkingBytes = true;\n        this._val = '';\n        this._bytesVal = 0;\n        this._valTrunc = false;\n        this.decoder.reset();\n        p = idxeq + 1;\n      } else if (idxamp !== undefined) {\n        // key with no assignment\n        ++this._fields;\n        var key,\n            keyTrunc = this._keyTrunc;\n        if (idxamp > p) key = this._key += this.decoder.write(data.toString('binary', p, idxamp));else key = this._key;\n        this._hitLimit = false;\n        this._checkingBytes = true;\n        this._key = '';\n        this._bytesKey = 0;\n        this._keyTrunc = false;\n        this.decoder.reset();\n\n        if (key.length) {\n          this.boy.emit('field', decodeText(key, 'binary', this.charset), '', keyTrunc, false);\n        }\n\n        p = idxamp + 1;\n        if (this._fields === this.fieldsLimit) return cb();\n      } else if (this._hitLimit) {\n        // we may not have hit the actual limit if there are encoded bytes...\n        if (i > p) this._key += this.decoder.write(data.toString('binary', p, i));\n        p = i;\n\n        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {\n          // yep, we actually did hit the limit\n          this._checkingBytes = false;\n          this._keyTrunc = true;\n        }\n      } else {\n        if (p < len) this._key += this.decoder.write(data.toString('binary', p));\n        p = len;\n      }\n    } else {\n      idxamp = undefined;\n\n      for (i = p; i < len; ++i) {\n        if (!this._checkingBytes) ++p;\n\n        if (data[i] === 0x26\n        /*&*/\n        ) {\n          idxamp = i;\n          break;\n        }\n\n        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {\n          this._hitLimit = true;\n          break;\n        } else if (this._checkingBytes) ++this._bytesVal;\n      }\n\n      if (idxamp !== undefined) {\n        ++this._fields;\n        if (idxamp > p) this._val += this.decoder.write(data.toString('binary', p, idxamp));\n        this.boy.emit('field', decodeText(this._key, 'binary', this.charset), decodeText(this._val, 'binary', this.charset), this._keyTrunc, this._valTrunc);\n        this._state = 'key';\n        this._hitLimit = false;\n        this._checkingBytes = true;\n        this._key = '';\n        this._bytesKey = 0;\n        this._keyTrunc = false;\n        this.decoder.reset();\n        p = idxamp + 1;\n        if (this._fields === this.fieldsLimit) return cb();\n      } else if (this._hitLimit) {\n        // we may not have hit the actual limit if there are encoded bytes...\n        if (i > p) this._val += this.decoder.write(data.toString('binary', p, i));\n        p = i;\n\n        if (this._val === '' && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {\n          // yep, we actually did hit the limit\n          this._checkingBytes = false;\n          this._valTrunc = true;\n        }\n      } else {\n        if (p < len) this._val += this.decoder.write(data.toString('binary', p));\n        p = len;\n      }\n    }\n  }\n\n  cb();\n};\n\nUrlEncoded.prototype.end = function () {\n  if (this.boy._done) return;\n\n  if (this._state === 'key' && this._key.length > 0) {\n    this.boy.emit('field', decodeText(this._key, 'binary', this.charset), '', this._keyTrunc, false);\n  } else if (this._state === 'val') {\n    this.boy.emit('field', decodeText(this._key, 'binary', this.charset), decodeText(this._val, 'binary', this.charset), this._keyTrunc, this._valTrunc);\n  }\n\n  this.boy._done = true;\n  this.boy.emit('finish');\n};\n\nmodule.exports = UrlEncoded;","map":{"version":3,"sources":["C:/Users/Sallam/Desktop/projects/next-step/server/node_modules/busboy/lib/types/urlencoded.js"],"names":["Decoder","require","decodeText","RE_CHARSET","UrlEncoded","detect","boy","cfg","limits","headers","parsedConType","fieldSizeLimit","fieldSize","fieldNameSizeLimit","fieldNameSize","fieldsLimit","fields","Infinity","charset","i","len","length","Array","isArray","test","toLowerCase","undefined","defCharset","decoder","_fields","_state","_checkingBytes","_bytesKey","_bytesVal","_key","_val","_keyTrunc","_valTrunc","_hitlimit","prototype","write","data","cb","hitFieldsLimit","emit","idxeq","idxamp","p","_hitLimit","toString","reset","key","keyTrunc","end","_done","module","exports"],"mappings":"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","sourcesContent":["var Decoder = require('../utils').Decoder,\n    decodeText = require('../utils').decodeText;\n\nvar RE_CHARSET = /^charset$/i;\n\nUrlEncoded.detect = /^application\\/x-www-form-urlencoded/i;\nfunction UrlEncoded(boy, cfg) {\n  if (!(this instanceof UrlEncoded))\n    return new UrlEncoded(boy, cfg);\n  var limits = cfg.limits,\n      headers = cfg.headers,\n      parsedConType = cfg.parsedConType;\n  this.boy = boy;\n\n  this.fieldSizeLimit = (limits && typeof limits.fieldSize === 'number'\n                         ? limits.fieldSize\n                         : 1 * 1024 * 1024);\n  this.fieldNameSizeLimit = (limits && typeof limits.fieldNameSize === 'number'\n                             ? limits.fieldNameSize\n                             : 100);\n  this.fieldsLimit = (limits && typeof limits.fields === 'number'\n                      ? limits.fields\n                      : Infinity);\n\n  var charset;\n  for (var i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i])\n        && RE_CHARSET.test(parsedConType[i][0])) {\n      charset = parsedConType[i][1].toLowerCase();\n      break;\n    }\n  }\n\n  if (charset === undefined)\n    charset = cfg.defCharset || 'utf8';\n\n  this.decoder = new Decoder();\n  this.charset = charset;\n  this._fields = 0;\n  this._state = 'key';\n  this._checkingBytes = true;\n  this._bytesKey = 0;\n  this._bytesVal = 0;\n  this._key = '';\n  this._val = '';\n  this._keyTrunc = false;\n  this._valTrunc = false;\n  this._hitlimit = false;\n}\n\nUrlEncoded.prototype.write = function(data, cb) {\n  if (this._fields === this.fieldsLimit) {\n    if (!this.boy.hitFieldsLimit) {\n      this.boy.hitFieldsLimit = true;\n      this.boy.emit('fieldsLimit');\n    }\n    return cb();\n  }\n\n  var idxeq, idxamp, i, p = 0, len = data.length;\n\n  while (p < len) {\n    if (this._state === 'key') {\n      idxeq = idxamp = undefined;\n      for (i = p; i < len; ++i) {\n        if (!this._checkingBytes)\n          ++p;\n        if (data[i] === 0x3D/*=*/) {\n          idxeq = i;\n          break;\n        } else if (data[i] === 0x26/*&*/) {\n          idxamp = i;\n          break;\n        }\n        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {\n          this._hitLimit = true;\n          break;\n        } else if (this._checkingBytes)\n          ++this._bytesKey;\n      }\n\n      if (idxeq !== undefined) {\n        // key with assignment\n        if (idxeq > p)\n          this._key += this.decoder.write(data.toString('binary', p, idxeq));\n        this._state = 'val';\n\n        this._hitLimit = false;\n        this._checkingBytes = true;\n        this._val = '';\n        this._bytesVal = 0;\n        this._valTrunc = false;\n        this.decoder.reset();\n\n        p = idxeq + 1;\n      } else if (idxamp !== undefined) {\n        // key with no assignment\n        ++this._fields;\n        var key, keyTrunc = this._keyTrunc;\n        if (idxamp > p)\n          key = (this._key += this.decoder.write(data.toString('binary', p, idxamp)));\n        else\n          key = this._key;\n\n        this._hitLimit = false;\n        this._checkingBytes = true;\n        this._key = '';\n        this._bytesKey = 0;\n        this._keyTrunc = false;\n        this.decoder.reset();\n\n        if (key.length) {\n          this.boy.emit('field', decodeText(key, 'binary', this.charset),\n                                 '',\n                                 keyTrunc,\n                                 false);\n        }\n\n        p = idxamp + 1;\n        if (this._fields === this.fieldsLimit)\n          return cb();\n      } else if (this._hitLimit) {\n        // we may not have hit the actual limit if there are encoded bytes...\n        if (i > p)\n          this._key += this.decoder.write(data.toString('binary', p, i));\n        p = i;\n        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {\n          // yep, we actually did hit the limit\n          this._checkingBytes = false;\n          this._keyTrunc = true;\n        }\n      } else {\n        if (p < len)\n          this._key += this.decoder.write(data.toString('binary', p));\n        p = len;\n      }\n    } else {\n      idxamp = undefined;\n      for (i = p; i < len; ++i) {\n        if (!this._checkingBytes)\n          ++p;\n        if (data[i] === 0x26/*&*/) {\n          idxamp = i;\n          break;\n        }\n        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {\n          this._hitLimit = true;\n          break;\n        }\n        else if (this._checkingBytes)\n          ++this._bytesVal;\n      }\n\n      if (idxamp !== undefined) {\n        ++this._fields;\n        if (idxamp > p)\n          this._val += this.decoder.write(data.toString('binary', p, idxamp));\n        this.boy.emit('field', decodeText(this._key, 'binary', this.charset),\n                               decodeText(this._val, 'binary', this.charset),\n                               this._keyTrunc,\n                               this._valTrunc);\n        this._state = 'key';\n\n        this._hitLimit = false;\n        this._checkingBytes = true;\n        this._key = '';\n        this._bytesKey = 0;\n        this._keyTrunc = false;\n        this.decoder.reset();\n\n        p = idxamp + 1;\n        if (this._fields === this.fieldsLimit)\n          return cb();\n      } else if (this._hitLimit) {\n        // we may not have hit the actual limit if there are encoded bytes...\n        if (i > p)\n          this._val += this.decoder.write(data.toString('binary', p, i));\n        p = i;\n        if ((this._val === '' && this.fieldSizeLimit === 0)\n            || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {\n          // yep, we actually did hit the limit\n          this._checkingBytes = false;\n          this._valTrunc = true;\n        }\n      } else {\n        if (p < len)\n          this._val += this.decoder.write(data.toString('binary', p));\n        p = len;\n      }\n    }\n  }\n  cb();\n};\n\nUrlEncoded.prototype.end = function() {\n  if (this.boy._done)\n    return;\n\n  if (this._state === 'key' && this._key.length > 0) {\n    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),\n                           '',\n                           this._keyTrunc,\n                           false);\n  } else if (this._state === 'val') {\n    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),\n                           decodeText(this._val, 'binary', this.charset),\n                           this._keyTrunc,\n                           this._valTrunc);\n  }\n  this.boy._done = true;\n  this.boy.emit('finish');\n};\n\nmodule.exports = UrlEncoded;\n"]},"metadata":{},"sourceType":"script"}