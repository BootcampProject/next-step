{"ast":null,"code":"import util from 'util';\nimport Busboy from 'busboy';\nimport { WriteStream } from 'fs-capacitor';\nimport createError from 'http-errors';\nimport objectPath from 'object-path';\nimport { SPEC_URL } from './constants';\nimport { ignoreStream } from './ignoreStream';\nimport { isEnumerableObject } from './isEnumerableObject';\n\nclass Upload {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = file => {\n        this.file = file;\n        resolve(file);\n      };\n\n      this.reject = reject;\n    });\n    this.promise.catch(() => {});\n  }\n\n}\n\nexport const processRequest = function (request, response) {\n  let {\n    maxFieldSize = 1000000,\n    maxFileSize = Infinity,\n    maxFiles = Infinity\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return new Promise((resolve, reject) => {\n    let released;\n    let exitError;\n    let currentStream;\n    let operations;\n    let operationsPath;\n    let map;\n    const parser = new Busboy({\n      headers: request.headers,\n      limits: {\n        fieldSize: maxFieldSize,\n        fields: 2,\n        fileSize: maxFileSize,\n        files: maxFiles\n      }\n    });\n\n    const exit = error => {\n      if (exitError) return;\n      exitError = error;\n      reject(exitError);\n      parser.destroy();\n      if (currentStream) currentStream.destroy(exitError);\n      if (map) for (const upload of map.values()) if (!upload.file) upload.reject(exitError);\n      request.unpipe(parser);\n      setImmediate(() => {\n        request.resume();\n      });\n    };\n\n    const release = () => {\n      // istanbul ignore next\n      if (released) return;\n      released = true;\n      if (map) for (const upload of map.values()) if (upload.file) upload.file.capacitor.destroy();\n    };\n\n    const abort = () => {\n      exit(createError(499, 'Request disconnected during file upload stream parsing.'));\n    };\n\n    parser.on('field', (fieldName, value, fieldNameTruncated, valueTruncated) => {\n      if (exitError) return;\n      if (valueTruncated) return exit(createError(413, `The ‘${fieldName}’ multipart field value exceeds the ${maxFieldSize} byte size limit.`));\n\n      switch (fieldName) {\n        case 'operations':\n          try {\n            operations = JSON.parse(value);\n          } catch (error) {\n            return exit(createError(400, `Invalid JSON in the ‘operations’ multipart field (${SPEC_URL}).`));\n          }\n\n          if (!isEnumerableObject(operations) && !Array.isArray(operations)) return exit(createError(400, `Invalid type for the ‘operations’ multipart field (${SPEC_URL}).`));\n          operationsPath = objectPath(operations);\n          break;\n\n        case 'map':\n          {\n            if (!operations) return exit(createError(400, `Misordered multipart fields; ‘map’ should follow ‘operations’ (${SPEC_URL}).`));\n            let parsedMap;\n\n            try {\n              parsedMap = JSON.parse(value);\n            } catch (error) {\n              return exit(createError(400, `Invalid JSON in the ‘map’ multipart field (${SPEC_URL}).`));\n            }\n\n            if (!isEnumerableObject(parsedMap)) return exit(createError(400, `Invalid type for the ‘map’ multipart field (${SPEC_URL}).`));\n            const mapEntries = Object.entries(parsedMap);\n            if (mapEntries.length > maxFiles) return exit(createError(413, `${maxFiles} max file uploads exceeded.`));\n            map = new Map();\n\n            for (const [fieldName, paths] of mapEntries) {\n              if (!Array.isArray(paths)) return exit(createError(400, `Invalid type for the ‘map’ multipart field entry key ‘${fieldName}’ array (${SPEC_URL}).`));\n              map.set(fieldName, new Upload());\n\n              for (const [index, path] of paths.entries()) {\n                if (typeof path !== 'string') return exit(createError(400, `Invalid type for the ‘map’ multipart field entry key ‘${fieldName}’ array index ‘${index}’ value (${SPEC_URL}).`));\n\n                try {\n                  operationsPath.set(path, map.get(fieldName).promise);\n                } catch (error) {\n                  return exit(createError(400, `Invalid object path for the ‘map’ multipart field entry key ‘${fieldName}’ array index ‘${index}’ value ‘${path}’ (${SPEC_URL}).`));\n                }\n              }\n            }\n\n            resolve(operations);\n          }\n      }\n    });\n    parser.on('file', (fieldName, stream, filename, encoding, mimetype) => {\n      if (exitError) {\n        ignoreStream(stream);\n        return;\n      }\n\n      if (!map) {\n        ignoreStream(stream);\n        return exit(createError(400, `Misordered multipart fields; files should follow ‘map’ (${SPEC_URL}).`));\n      }\n\n      currentStream = stream;\n      stream.on('end', () => {\n        currentStream = null;\n      });\n      const upload = map.get(fieldName);\n\n      if (!upload) {\n        ignoreStream(stream);\n        return;\n      }\n\n      const capacitor = new WriteStream();\n      capacitor.on('error', () => {\n        stream.unpipe();\n        stream.resume();\n      });\n      stream.on('limit', () => {\n        stream.unpipe();\n        capacitor.destroy(createError(413, `File truncated as it exceeds the ${maxFileSize} byte size limit.`));\n      });\n      stream.on('error', error => {\n        stream.unpipe(); // istanbul ignore next\n\n        capacitor.destroy(exitError || error);\n      });\n      stream.pipe(capacitor);\n      const file = {\n        filename,\n        mimetype,\n        encoding,\n\n        createReadStream() {\n          const error = capacitor.error || (released ? exitError : null);\n          if (error) throw error;\n          return capacitor.createReadStream();\n        }\n\n      };\n      let capacitorStream;\n      Object.defineProperty(file, 'stream', {\n        get: util.deprecate(function () {\n          if (!capacitorStream) capacitorStream = this.createReadStream();\n          return capacitorStream;\n        }, 'File upload property ‘stream’ is deprecated. Use ‘createReadStream()’ instead.')\n      });\n      Object.defineProperty(file, 'capacitor', {\n        value: capacitor\n      });\n      upload.resolve(file);\n    });\n    parser.once('filesLimit', () => exit(createError(413, `${maxFiles} max file uploads exceeded.`)));\n    parser.once('finish', () => {\n      request.unpipe(parser);\n      request.resume();\n      if (!operations) return exit(createError(400, `Missing multipart field ‘operations’ (${SPEC_URL}).`));\n      if (!map) return exit(createError(400, `Missing multipart field ‘map’ (${SPEC_URL}).`));\n\n      for (const upload of map.values()) if (!upload.file) upload.reject(createError(400, 'File missing in the request.'));\n    });\n    parser.once('error', exit);\n    response.once('finish', release);\n    response.once('close', release);\n    request.once('close', abort);\n    request.once('end', () => {\n      request.removeListener('close', abort);\n    });\n    request.pipe(parser);\n  });\n};","map":{"version":3,"sources":["C:/Users/Sallam/Desktop/projects/next-step/server/node_modules/@apollographql/graphql-upload-8-fork/lib/processRequest.mjs"],"names":["util","Busboy","WriteStream","createError","objectPath","SPEC_URL","ignoreStream","isEnumerableObject","Upload","constructor","promise","Promise","resolve","reject","file","catch","processRequest","request","response","maxFieldSize","maxFileSize","Infinity","maxFiles","released","exitError","currentStream","operations","operationsPath","map","parser","headers","limits","fieldSize","fields","fileSize","files","exit","error","destroy","upload","values","unpipe","setImmediate","resume","release","capacitor","abort","on","fieldName","value","fieldNameTruncated","valueTruncated","JSON","parse","Array","isArray","parsedMap","mapEntries","Object","entries","length","Map","paths","set","index","path","get","stream","filename","encoding","mimetype","pipe","createReadStream","capacitorStream","defineProperty","deprecate","once","removeListener"],"mappings":"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","sourcesContent":["import util from 'util'\nimport Busboy from 'busboy'\nimport { WriteStream } from 'fs-capacitor'\nimport createError from 'http-errors'\nimport objectPath from 'object-path'\nimport { SPEC_URL } from './constants'\nimport { ignoreStream } from './ignoreStream'\nimport { isEnumerableObject } from './isEnumerableObject'\n\nclass Upload {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = file => {\n        this.file = file\n        resolve(file)\n      }\n\n      this.reject = reject\n    })\n    this.promise.catch(() => {})\n  }\n}\n\nexport const processRequest = (\n  request,\n  response,\n  { maxFieldSize = 1000000, maxFileSize = Infinity, maxFiles = Infinity } = {}\n) =>\n  new Promise((resolve, reject) => {\n    let released\n    let exitError\n    let currentStream\n    let operations\n    let operationsPath\n    let map\n    const parser = new Busboy({\n      headers: request.headers,\n      limits: {\n        fieldSize: maxFieldSize,\n        fields: 2,\n        fileSize: maxFileSize,\n        files: maxFiles\n      }\n    })\n\n    const exit = error => {\n      if (exitError) return\n      exitError = error\n      reject(exitError)\n      parser.destroy()\n      if (currentStream) currentStream.destroy(exitError)\n      if (map)\n        for (const upload of map.values())\n          if (!upload.file) upload.reject(exitError)\n      request.unpipe(parser)\n      setImmediate(() => {\n        request.resume()\n      })\n    }\n\n    const release = () => {\n      // istanbul ignore next\n      if (released) return\n      released = true\n      if (map)\n        for (const upload of map.values())\n          if (upload.file) upload.file.capacitor.destroy()\n    }\n\n    const abort = () => {\n      exit(\n        createError(\n          499,\n          'Request disconnected during file upload stream parsing.'\n        )\n      )\n    }\n\n    parser.on(\n      'field',\n      (fieldName, value, fieldNameTruncated, valueTruncated) => {\n        if (exitError) return\n        if (valueTruncated)\n          return exit(\n            createError(\n              413,\n              `The ‘${fieldName}’ multipart field value exceeds the ${maxFieldSize} byte size limit.`\n            )\n          )\n\n        switch (fieldName) {\n          case 'operations':\n            try {\n              operations = JSON.parse(value)\n            } catch (error) {\n              return exit(\n                createError(\n                  400,\n                  `Invalid JSON in the ‘operations’ multipart field (${SPEC_URL}).`\n                )\n              )\n            }\n\n            if (!isEnumerableObject(operations) && !Array.isArray(operations))\n              return exit(\n                createError(\n                  400,\n                  `Invalid type for the ‘operations’ multipart field (${SPEC_URL}).`\n                )\n              )\n            operationsPath = objectPath(operations)\n            break\n\n          case 'map': {\n            if (!operations)\n              return exit(\n                createError(\n                  400,\n                  `Misordered multipart fields; ‘map’ should follow ‘operations’ (${SPEC_URL}).`\n                )\n              )\n            let parsedMap\n\n            try {\n              parsedMap = JSON.parse(value)\n            } catch (error) {\n              return exit(\n                createError(\n                  400,\n                  `Invalid JSON in the ‘map’ multipart field (${SPEC_URL}).`\n                )\n              )\n            }\n\n            if (!isEnumerableObject(parsedMap))\n              return exit(\n                createError(\n                  400,\n                  `Invalid type for the ‘map’ multipart field (${SPEC_URL}).`\n                )\n              )\n            const mapEntries = Object.entries(parsedMap)\n            if (mapEntries.length > maxFiles)\n              return exit(\n                createError(413, `${maxFiles} max file uploads exceeded.`)\n              )\n            map = new Map()\n\n            for (const [fieldName, paths] of mapEntries) {\n              if (!Array.isArray(paths))\n                return exit(\n                  createError(\n                    400,\n                    `Invalid type for the ‘map’ multipart field entry key ‘${fieldName}’ array (${SPEC_URL}).`\n                  )\n                )\n              map.set(fieldName, new Upload())\n\n              for (const [index, path] of paths.entries()) {\n                if (typeof path !== 'string')\n                  return exit(\n                    createError(\n                      400,\n                      `Invalid type for the ‘map’ multipart field entry key ‘${fieldName}’ array index ‘${index}’ value (${SPEC_URL}).`\n                    )\n                  )\n\n                try {\n                  operationsPath.set(path, map.get(fieldName).promise)\n                } catch (error) {\n                  return exit(\n                    createError(\n                      400,\n                      `Invalid object path for the ‘map’ multipart field entry key ‘${fieldName}’ array index ‘${index}’ value ‘${path}’ (${SPEC_URL}).`\n                    )\n                  )\n                }\n              }\n            }\n\n            resolve(operations)\n          }\n        }\n      }\n    )\n    parser.on('file', (fieldName, stream, filename, encoding, mimetype) => {\n      if (exitError) {\n        ignoreStream(stream)\n        return\n      }\n\n      if (!map) {\n        ignoreStream(stream)\n        return exit(\n          createError(\n            400,\n            `Misordered multipart fields; files should follow ‘map’ (${SPEC_URL}).`\n          )\n        )\n      }\n\n      currentStream = stream\n      stream.on('end', () => {\n        currentStream = null\n      })\n      const upload = map.get(fieldName)\n\n      if (!upload) {\n        ignoreStream(stream)\n        return\n      }\n\n      const capacitor = new WriteStream()\n      capacitor.on('error', () => {\n        stream.unpipe()\n        stream.resume()\n      })\n      stream.on('limit', () => {\n        stream.unpipe()\n        capacitor.destroy(\n          createError(\n            413,\n            `File truncated as it exceeds the ${maxFileSize} byte size limit.`\n          )\n        )\n      })\n      stream.on('error', error => {\n        stream.unpipe() // istanbul ignore next\n\n        capacitor.destroy(exitError || error)\n      })\n      stream.pipe(capacitor)\n      const file = {\n        filename,\n        mimetype,\n        encoding,\n\n        createReadStream() {\n          const error = capacitor.error || (released ? exitError : null)\n          if (error) throw error\n          return capacitor.createReadStream()\n        }\n      }\n      let capacitorStream\n      Object.defineProperty(file, 'stream', {\n        get: util.deprecate(function() {\n          if (!capacitorStream) capacitorStream = this.createReadStream()\n          return capacitorStream\n        }, 'File upload property ‘stream’ is deprecated. Use ‘createReadStream()’ instead.')\n      })\n      Object.defineProperty(file, 'capacitor', {\n        value: capacitor\n      })\n      upload.resolve(file)\n    })\n    parser.once('filesLimit', () =>\n      exit(createError(413, `${maxFiles} max file uploads exceeded.`))\n    )\n    parser.once('finish', () => {\n      request.unpipe(parser)\n      request.resume()\n      if (!operations)\n        return exit(\n          createError(\n            400,\n            `Missing multipart field ‘operations’ (${SPEC_URL}).`\n          )\n        )\n      if (!map)\n        return exit(\n          createError(400, `Missing multipart field ‘map’ (${SPEC_URL}).`)\n        )\n\n      for (const upload of map.values())\n        if (!upload.file)\n          upload.reject(createError(400, 'File missing in the request.'))\n    })\n    parser.once('error', exit)\n    response.once('finish', release)\n    response.once('close', release)\n    request.once('close', abort)\n    request.once('end', () => {\n      request.removeListener('close', abort)\n    })\n    request.pipe(parser)\n  })\n"]},"metadata":{},"sourceType":"module"}