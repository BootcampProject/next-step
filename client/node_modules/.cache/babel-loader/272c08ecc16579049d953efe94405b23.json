{"ast":null,"code":"// TODO:\n//  * support 1 nested multipart level\n//    (see second multipart example here:\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\n//  * support limits.fieldNameSize\n//     -- this will require modifications to utils.parseParams\nvar ReadableStream = require('stream').Readable,\n    inherits = require('util').inherits;\n\nvar Dicer = require('dicer');\n\nvar parseParams = require('../utils').parseParams,\n    decodeText = require('../utils').decodeText,\n    basename = require('../utils').basename;\n\nvar RE_BOUNDARY = /^boundary$/i,\n    RE_FIELD = /^form-data$/i,\n    RE_CHARSET = /^charset$/i,\n    RE_FILENAME = /^filename$/i,\n    RE_NAME = /^name$/i;\nMultipart.detect = /^multipart\\/form-data/i;\n\nfunction Multipart(boy, cfg) {\n  if (!(this instanceof Multipart)) return new Multipart(boy, cfg);\n  var i,\n      len,\n      self = this,\n      boundary,\n      limits = cfg.limits,\n      parsedConType = cfg.parsedConType || [],\n      defCharset = cfg.defCharset || 'utf8',\n      preservePath = cfg.preservePath,\n      fileopts = typeof cfg.fileHwm === 'number' ? {\n    highWaterMark: cfg.fileHwm\n  } : {};\n\n  for (i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {\n      boundary = parsedConType[i][1];\n      break;\n    }\n  }\n\n  function checkFinished() {\n    if (nends === 0 && finished && !boy._done) {\n      finished = false;\n      process.nextTick(function () {\n        boy._done = true;\n        boy.emit('finish');\n      });\n    }\n  }\n\n  if (typeof boundary !== 'string') throw new Error('Multipart: Boundary not found');\n  var fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024,\n      fileSizeLimit = limits && typeof limits.fileSize === 'number' ? limits.fileSize : Infinity,\n      filesLimit = limits && typeof limits.files === 'number' ? limits.files : Infinity,\n      fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity,\n      partsLimit = limits && typeof limits.parts === 'number' ? limits.parts : Infinity;\n  var nfiles = 0,\n      nfields = 0,\n      nends = 0,\n      curFile,\n      curField,\n      finished = false;\n  this._needDrain = false;\n  this._pause = false;\n  this._cb = undefined;\n  this._nparts = 0;\n  this._boy = boy;\n  var parserCfg = {\n    boundary: boundary,\n    maxHeaderPairs: limits && limits.headerPairs\n  };\n  if (fileopts.highWaterMark) parserCfg.partHwm = fileopts.highWaterMark;\n  if (cfg.highWaterMark) parserCfg.highWaterMark = cfg.highWaterMark;\n  this.parser = new Dicer(parserCfg);\n  this.parser.on('drain', function () {\n    self._needDrain = false;\n\n    if (self._cb && !self._pause) {\n      var cb = self._cb;\n      self._cb = undefined;\n      cb();\n    }\n  }).on('part', function onPart(part) {\n    if (++self._nparts > partsLimit) {\n      self.parser.removeListener('part', onPart);\n      self.parser.on('part', skipPart);\n      boy.hitPartsLimit = true;\n      boy.emit('partsLimit');\n      return skipPart(part);\n    } // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n    // us emit 'end' early since we know the part has ended if we are already\n    // seeing the next part\n\n\n    if (curField) {\n      var field = curField;\n      field.emit('end');\n      field.removeAllListeners('end');\n    }\n\n    part.on('header', function (header) {\n      var contype,\n          fieldname,\n          parsed,\n          charset,\n          encoding,\n          filename,\n          nsize = 0;\n\n      if (header['content-type']) {\n        parsed = parseParams(header['content-type'][0]);\n\n        if (parsed[0]) {\n          contype = parsed[0].toLowerCase();\n\n          for (i = 0, len = parsed.length; i < len; ++i) {\n            if (RE_CHARSET.test(parsed[i][0])) {\n              charset = parsed[i][1].toLowerCase();\n              break;\n            }\n          }\n        }\n      }\n\n      if (contype === undefined) contype = 'text/plain';\n      if (charset === undefined) charset = defCharset;\n\n      if (header['content-disposition']) {\n        parsed = parseParams(header['content-disposition'][0]);\n        if (!RE_FIELD.test(parsed[0])) return skipPart(part);\n\n        for (i = 0, len = parsed.length; i < len; ++i) {\n          if (RE_NAME.test(parsed[i][0])) {\n            fieldname = decodeText(parsed[i][1], 'binary', 'utf8');\n          } else if (RE_FILENAME.test(parsed[i][0])) {\n            filename = decodeText(parsed[i][1], 'binary', 'utf8');\n            if (!preservePath) filename = basename(filename);\n          }\n        }\n      } else return skipPart(part);\n\n      if (header['content-transfer-encoding']) encoding = header['content-transfer-encoding'][0].toLowerCase();else encoding = '7bit';\n      var onData, onEnd;\n\n      if (contype === 'application/octet-stream' || filename !== undefined) {\n        // file/binary field\n        if (nfiles === filesLimit) {\n          if (!boy.hitFilesLimit) {\n            boy.hitFilesLimit = true;\n            boy.emit('filesLimit');\n          }\n\n          return skipPart(part);\n        }\n\n        ++nfiles;\n\n        if (!boy._events.file) {\n          self.parser._ignore();\n\n          return;\n        }\n\n        ++nends;\n        var file = new FileStream(fileopts);\n        curFile = file;\n        file.on('end', function () {\n          --nends;\n          self._pause = false;\n          checkFinished();\n\n          if (self._cb && !self._needDrain) {\n            var cb = self._cb;\n            self._cb = undefined;\n            cb();\n          }\n        });\n\n        file._read = function (n) {\n          if (!self._pause) return;\n          self._pause = false;\n\n          if (self._cb && !self._needDrain) {\n            var cb = self._cb;\n            self._cb = undefined;\n            cb();\n          }\n        };\n\n        boy.emit('file', fieldname, file, filename, encoding, contype);\n\n        onData = function (data) {\n          if ((nsize += data.length) > fileSizeLimit) {\n            var extralen = fileSizeLimit - (nsize - data.length);\n            if (extralen > 0) file.push(data.slice(0, extralen));\n            file.emit('limit');\n            file.truncated = true;\n            part.removeAllListeners('data');\n          } else if (!file.push(data)) self._pause = true;\n        };\n\n        onEnd = function () {\n          curFile = undefined;\n          file.push(null);\n        };\n      } else {\n        // non-file field\n        if (nfields === fieldsLimit) {\n          if (!boy.hitFieldsLimit) {\n            boy.hitFieldsLimit = true;\n            boy.emit('fieldsLimit');\n          }\n\n          return skipPart(part);\n        }\n\n        ++nfields;\n        ++nends;\n        var buffer = '',\n            truncated = false;\n        curField = part;\n\n        onData = function (data) {\n          if ((nsize += data.length) > fieldSizeLimit) {\n            var extralen = fieldSizeLimit - (nsize - data.length);\n            buffer += data.toString('binary', 0, extralen);\n            truncated = true;\n            part.removeAllListeners('data');\n          } else buffer += data.toString('binary');\n        };\n\n        onEnd = function () {\n          curField = undefined;\n          if (buffer.length) buffer = decodeText(buffer, 'binary', charset);\n          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);\n          --nends;\n          checkFinished();\n        };\n      }\n      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\n         broken. Streams2/streams3 is a huge black box of confusion, but\n         somehow overriding the sync state seems to fix things again (and still\n         seems to work for previous node versions).\n      */\n\n\n      part._readableState.sync = false;\n      part.on('data', onData);\n      part.on('end', onEnd);\n    }).on('error', function (err) {\n      if (curFile) curFile.emit('error', err);\n    });\n  }).on('error', function (err) {\n    boy.emit('error', err);\n  }).on('finish', function () {\n    finished = true;\n    checkFinished();\n  });\n}\n\nMultipart.prototype.write = function (chunk, cb) {\n  var r;\n  if ((r = this.parser.write(chunk)) && !this._pause) cb();else {\n    this._needDrain = !r;\n    this._cb = cb;\n  }\n};\n\nMultipart.prototype.end = function () {\n  var self = this;\n\n  if (this._nparts === 0 && !self._boy._done) {\n    process.nextTick(function () {\n      self._boy._done = true;\n\n      self._boy.emit('finish');\n    });\n  } else if (this.parser.writable) this.parser.end();\n};\n\nfunction skipPart(part) {\n  part.resume();\n}\n\nfunction FileStream(opts) {\n  if (!(this instanceof FileStream)) return new FileStream(opts);\n  ReadableStream.call(this, opts);\n  this.truncated = false;\n}\n\ninherits(FileStream, ReadableStream);\n\nFileStream.prototype._read = function (n) {};\n\nmodule.exports = Multipart;","map":{"version":3,"sources":["C:/Users/Sallam/Desktop/projects/next-step/server/node_modules/busboy/lib/types/multipart.js"],"names":["ReadableStream","require","Readable","inherits","Dicer","parseParams","decodeText","basename","RE_BOUNDARY","RE_FIELD","RE_CHARSET","RE_FILENAME","RE_NAME","Multipart","detect","boy","cfg","i","len","self","boundary","limits","parsedConType","defCharset","preservePath","fileopts","fileHwm","highWaterMark","length","Array","isArray","test","checkFinished","nends","finished","_done","process","nextTick","emit","Error","fieldSizeLimit","fieldSize","fileSizeLimit","fileSize","Infinity","filesLimit","files","fieldsLimit","fields","partsLimit","parts","nfiles","nfields","curFile","curField","_needDrain","_pause","_cb","undefined","_nparts","_boy","parserCfg","maxHeaderPairs","headerPairs","partHwm","parser","on","cb","onPart","part","removeListener","skipPart","hitPartsLimit","field","removeAllListeners","header","contype","fieldname","parsed","charset","encoding","filename","nsize","toLowerCase","onData","onEnd","hitFilesLimit","_events","file","_ignore","FileStream","_read","n","data","extralen","push","slice","truncated","hitFieldsLimit","buffer","toString","_readableState","sync","err","prototype","write","chunk","r","end","writable","resume","opts","call","module","exports"],"mappings":"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","sourcesContent":["// TODO:\n//  * support 1 nested multipart level\n//    (see second multipart example here:\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\n//  * support limits.fieldNameSize\n//     -- this will require modifications to utils.parseParams\n\nvar ReadableStream = require('stream').Readable,\n    inherits = require('util').inherits;\n\nvar Dicer = require('dicer');\n\nvar parseParams = require('../utils').parseParams,\n    decodeText = require('../utils').decodeText,\n    basename = require('../utils').basename;\n\nvar RE_BOUNDARY = /^boundary$/i,\n    RE_FIELD = /^form-data$/i,\n    RE_CHARSET = /^charset$/i,\n    RE_FILENAME = /^filename$/i,\n    RE_NAME = /^name$/i;\n\nMultipart.detect = /^multipart\\/form-data/i;\nfunction Multipart(boy, cfg) {\n  if (!(this instanceof Multipart))\n    return new Multipart(boy, cfg);\n  var i,\n      len,\n      self = this,\n      boundary,\n      limits = cfg.limits,\n      parsedConType = cfg.parsedConType || [],\n      defCharset = cfg.defCharset || 'utf8',\n      preservePath = cfg.preservePath,\n      fileopts = (typeof cfg.fileHwm === 'number'\n                  ? { highWaterMark: cfg.fileHwm }\n                  : {});\n\n  for (i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i])\n        && RE_BOUNDARY.test(parsedConType[i][0])) {\n      boundary = parsedConType[i][1];\n      break;\n    }\n  }\n\n  function checkFinished() {\n    if (nends === 0 && finished && !boy._done) {\n      finished = false;\n      process.nextTick(function() {\n        boy._done = true;\n        boy.emit('finish');\n      });\n    }\n  }\n\n  if (typeof boundary !== 'string')\n    throw new Error('Multipart: Boundary not found');\n\n  var fieldSizeLimit = (limits && typeof limits.fieldSize === 'number'\n                        ? limits.fieldSize\n                        : 1 * 1024 * 1024),\n      fileSizeLimit = (limits && typeof limits.fileSize === 'number'\n                       ? limits.fileSize\n                       : Infinity),\n      filesLimit = (limits && typeof limits.files === 'number'\n                    ? limits.files\n                    : Infinity),\n      fieldsLimit = (limits && typeof limits.fields === 'number'\n                     ? limits.fields\n                     : Infinity),\n      partsLimit = (limits && typeof limits.parts === 'number'\n                    ? limits.parts\n                    : Infinity);\n\n  var nfiles = 0,\n      nfields = 0,\n      nends = 0,\n      curFile,\n      curField,\n      finished = false;\n\n  this._needDrain = false;\n  this._pause = false;\n  this._cb = undefined;\n  this._nparts = 0;\n  this._boy = boy;\n\n  var parserCfg = {\n    boundary: boundary,\n    maxHeaderPairs: (limits && limits.headerPairs)\n  };\n  if (fileopts.highWaterMark)\n    parserCfg.partHwm = fileopts.highWaterMark;\n  if (cfg.highWaterMark)\n    parserCfg.highWaterMark = cfg.highWaterMark;\n\n  this.parser = new Dicer(parserCfg);\n  this.parser.on('drain', function() {\n    self._needDrain = false;\n    if (self._cb && !self._pause) {\n      var cb = self._cb;\n      self._cb = undefined;\n      cb();\n    }\n  }).on('part', function onPart(part) {\n    if (++self._nparts > partsLimit) {\n      self.parser.removeListener('part', onPart);\n      self.parser.on('part', skipPart);\n      boy.hitPartsLimit = true;\n      boy.emit('partsLimit');\n      return skipPart(part);\n    }\n\n    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n    // us emit 'end' early since we know the part has ended if we are already\n    // seeing the next part\n    if (curField) {\n      var field = curField;\n      field.emit('end');\n      field.removeAllListeners('end');\n    }\n\n    part.on('header', function(header) {\n      var contype,\n          fieldname,\n          parsed,\n          charset,\n          encoding,\n          filename,\n          nsize = 0;\n\n      if (header['content-type']) {\n        parsed = parseParams(header['content-type'][0]);\n        if (parsed[0]) {\n          contype = parsed[0].toLowerCase();\n          for (i = 0, len = parsed.length; i < len; ++i) {\n            if (RE_CHARSET.test(parsed[i][0])) {\n              charset = parsed[i][1].toLowerCase();\n              break;\n            }\n          }\n        }\n      }\n\n      if (contype === undefined)\n        contype = 'text/plain';\n      if (charset === undefined)\n        charset = defCharset;\n\n      if (header['content-disposition']) {\n        parsed = parseParams(header['content-disposition'][0]);\n        if (!RE_FIELD.test(parsed[0]))\n          return skipPart(part);\n        for (i = 0, len = parsed.length; i < len; ++i) {\n          if (RE_NAME.test(parsed[i][0])) {\n            fieldname = decodeText(parsed[i][1], 'binary', 'utf8');\n          } else if (RE_FILENAME.test(parsed[i][0])) {\n            filename = decodeText(parsed[i][1], 'binary', 'utf8');\n            if (!preservePath)\n              filename = basename(filename);\n          }\n        }\n      } else\n        return skipPart(part);\n\n      if (header['content-transfer-encoding'])\n        encoding = header['content-transfer-encoding'][0].toLowerCase();\n      else\n        encoding = '7bit';\n\n      var onData,\n          onEnd;\n      if (contype === 'application/octet-stream' || filename !== undefined) {\n        // file/binary field\n        if (nfiles === filesLimit) {\n          if (!boy.hitFilesLimit) {\n            boy.hitFilesLimit = true;\n            boy.emit('filesLimit');\n          }\n          return skipPart(part);\n        }\n\n        ++nfiles;\n\n        if (!boy._events.file) {\n          self.parser._ignore();\n          return;\n        }\n\n        ++nends;\n        var file = new FileStream(fileopts);\n        curFile = file;\n        file.on('end', function() {\n          --nends;\n          self._pause = false;\n          checkFinished();\n          if (self._cb && !self._needDrain) {\n            var cb = self._cb;\n            self._cb = undefined;\n            cb();\n          }\n        });\n        file._read = function(n) {\n          if (!self._pause)\n            return;\n          self._pause = false;\n          if (self._cb && !self._needDrain) {\n            var cb = self._cb;\n            self._cb = undefined;\n            cb();\n          }\n        };\n        boy.emit('file', fieldname, file, filename, encoding, contype);\n\n        onData = function(data) {\n          if ((nsize += data.length) > fileSizeLimit) {\n            var extralen = (fileSizeLimit - (nsize - data.length));\n            if (extralen > 0)\n              file.push(data.slice(0, extralen));\n            file.emit('limit');\n            file.truncated = true;\n            part.removeAllListeners('data');\n          } else if (!file.push(data))\n            self._pause = true;\n        };\n\n        onEnd = function() {\n          curFile = undefined;\n          file.push(null);\n        };\n      } else {\n        // non-file field\n        if (nfields === fieldsLimit) {\n          if (!boy.hitFieldsLimit) {\n            boy.hitFieldsLimit = true;\n            boy.emit('fieldsLimit');\n          }\n          return skipPart(part);\n        }\n\n        ++nfields;\n        ++nends;\n        var buffer = '',\n            truncated = false;\n        curField = part;\n\n        onData = function(data) {\n          if ((nsize += data.length) > fieldSizeLimit) {\n            var extralen = (fieldSizeLimit - (nsize - data.length));\n            buffer += data.toString('binary', 0, extralen);\n            truncated = true;\n            part.removeAllListeners('data');\n          } else\n            buffer += data.toString('binary');\n        };\n\n        onEnd = function() {\n          curField = undefined;\n          if (buffer.length)\n            buffer = decodeText(buffer, 'binary', charset);\n          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);\n          --nends;\n          checkFinished();\n        };\n      }\n\n      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\n         broken. Streams2/streams3 is a huge black box of confusion, but\n         somehow overriding the sync state seems to fix things again (and still\n         seems to work for previous node versions).\n      */\n      part._readableState.sync = false;\n\n      part.on('data', onData);\n      part.on('end', onEnd);\n    }).on('error', function(err) {\n      if (curFile)\n        curFile.emit('error', err);\n    });\n  }).on('error', function(err) {\n    boy.emit('error', err);\n  }).on('finish', function() {\n    finished = true;\n    checkFinished();\n  });\n}\n\nMultipart.prototype.write = function(chunk, cb) {\n  var r;\n  if ((r = this.parser.write(chunk)) && !this._pause)\n    cb();\n  else {\n    this._needDrain = !r;\n    this._cb = cb;\n  }\n};\n\nMultipart.prototype.end = function() {\n  var self = this;\n  if (this._nparts === 0 && !self._boy._done) {\n    process.nextTick(function() {\n      self._boy._done = true;\n      self._boy.emit('finish');\n    });\n  } else if (this.parser.writable)\n    this.parser.end();\n};\n\nfunction skipPart(part) {\n  part.resume();\n}\n\nfunction FileStream(opts) {\n  if (!(this instanceof FileStream))\n    return new FileStream(opts);\n  ReadableStream.call(this, opts);\n\n  this.truncated = false;\n}\ninherits(FileStream, ReadableStream);\n\nFileStream.prototype._read = function(n) {};\n\nmodule.exports = Multipart;\n"]},"metadata":{},"sourceType":"script"}