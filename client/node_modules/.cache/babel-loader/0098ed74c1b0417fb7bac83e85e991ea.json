{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\n  var typeNames = Object.keys(__assign(__assign({}, schema.getTypeMap()), resolvers));\n  var extendedResolvers = {};\n  typeNames.forEach(function (typeName) {\n    var typeResolvers = resolvers[typeName];\n    var type = schema.getType(typeName);\n\n    if (type instanceof graphql_1.GraphQLObjectType) {\n      var interfaceResolvers = type.getInterfaces().map(function (iFace) {\n        return resolvers[iFace.name];\n      });\n      extendedResolvers[typeName] = Object.assign.apply(Object, __spreadArrays([{}], interfaceResolvers, [typeResolvers]));\n    } else {\n      if (typeResolvers) {\n        extendedResolvers[typeName] = typeResolvers;\n      }\n    }\n  });\n  return extendedResolvers;\n}\n\nexports.default = extendResolversFromInterfaces;","map":{"version":3,"sources":["../../src/generate/extendResolversFromInterfaces.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAIA,SAAS,6BAAT,CACE,MADF,EAEE,SAFF,EAEuB;AAErB,MAAM,SAAS,GAAG,MAAM,CAAC,IAAP,CAAW,QAAA,CAAA,QAAA,CAAA,EAAA,EACxB,MAAM,CAAC,UAAP,EADwB,CAAA,EAExB,SAFwB,CAAX,CAAlB;AAKA,MAAM,iBAAiB,GAAe,EAAtC;AACA,EAAA,SAAS,CAAC,OAAV,CAAkB,UAAA,QAAA,EAAQ;AACxB,QAAM,aAAa,GAAG,SAAS,CAAC,QAAD,CAA/B;AACA,QAAM,IAAI,GAAG,MAAM,CAAC,OAAP,CAAe,QAAf,CAAb;;AACA,QAAI,IAAI,YAAY,SAAA,CAAA,iBAApB,EAAuC;AACrC,UAAM,kBAAkB,GAAG,IAAI,CAC5B,aADwB,GAExB,GAFwB,CAEpB,UAAA,KAAA,EAAK;AAAI,eAAA,SAAS,CAAC,KAAK,CAAf,IAAS,CAAT;AAAqB,OAFV,CAA3B;AAGA,MAAA,iBAAiB,CAAC,QAAD,CAAjB,GAA8B,MAAM,CAAC,MAAP,CAAa,KAAb,CAAA,MAAA,EAAM,cAAA,CAAA,CAClC,EADkC,CAAA,EAE/B,kBAF+B,EAEb,CACrB,aADqB,CAFa,CAAN,CAA9B;AAKD,KATD,MASO;AACL,UAAI,aAAJ,EAAmB;AACjB,QAAA,iBAAiB,CAAC,QAAD,CAAjB,GAA8B,aAA9B;AACD;AACF;AACF,GAjBD;AAmBA,SAAO,iBAAP;AACD;;AAED,OAAA,CAAA,OAAA,GAAe,6BAAf","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\nfunction extendResolversFromInterfaces(schema, resolvers) {\n    var typeNames = Object.keys(__assign(__assign({}, schema.getTypeMap()), resolvers));\n    var extendedResolvers = {};\n    typeNames.forEach(function (typeName) {\n        var typeResolvers = resolvers[typeName];\n        var type = schema.getType(typeName);\n        if (type instanceof graphql_1.GraphQLObjectType) {\n            var interfaceResolvers = type\n                .getInterfaces()\n                .map(function (iFace) { return resolvers[iFace.name]; });\n            extendedResolvers[typeName] = Object.assign.apply(Object, __spreadArrays([{}], interfaceResolvers, [typeResolvers]));\n        }\n        else {\n            if (typeResolvers) {\n                extendedResolvers[typeName] = typeResolvers;\n            }\n        }\n    });\n    return extendedResolvers;\n}\nexports.default = extendResolversFromInterfaces;\n//# sourceMappingURL=extendResolversFromInterfaces.js.map"]},"metadata":{},"sourceType":"script"}