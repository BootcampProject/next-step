{"ast":null,"code":"/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"@apollo/protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.Trace = function () {\n  /**\n   * Properties of a Trace.\n   * @exports ITrace\n   * @interface ITrace\n   * @property {google.protobuf.ITimestamp|null} [startTime] Trace startTime\n   * @property {google.protobuf.ITimestamp|null} [endTime] Trace endTime\n   * @property {number|null} [durationNs] Trace durationNs\n   * @property {Trace.INode|null} [root] Trace root\n   * @property {string|null} [signature] Trace signature\n   * @property {string|null} [unexecutedOperationBody] Trace unexecutedOperationBody\n   * @property {string|null} [unexecutedOperationName] Trace unexecutedOperationName\n   * @property {Trace.IDetails|null} [details] Trace details\n   * @property {string|null} [clientName] Trace clientName\n   * @property {string|null} [clientVersion] Trace clientVersion\n   * @property {string|null} [clientAddress] Trace clientAddress\n   * @property {string|null} [clientReferenceId] Trace clientReferenceId\n   * @property {Trace.IHTTP|null} [http] Trace http\n   * @property {Trace.ICachePolicy|null} [cachePolicy] Trace cachePolicy\n   * @property {Trace.IQueryPlanNode|null} [queryPlan] Trace queryPlan\n   * @property {boolean|null} [fullQueryCacheHit] Trace fullQueryCacheHit\n   * @property {boolean|null} [persistedQueryHit] Trace persistedQueryHit\n   * @property {boolean|null} [persistedQueryRegister] Trace persistedQueryRegister\n   * @property {boolean|null} [registeredOperation] Trace registeredOperation\n   * @property {boolean|null} [forbiddenOperation] Trace forbiddenOperation\n   */\n\n  /**\n   * Constructs a new Trace.\n   * @exports Trace\n   * @classdesc Represents a Trace.\n   * @implements ITrace\n   * @constructor\n   * @param {ITrace=} [properties] Properties to set\n   */\n  function Trace(properties) {\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Trace startTime.\n   * @member {google.protobuf.ITimestamp|null|undefined} startTime\n   * @memberof Trace\n   * @instance\n   */\n\n\n  Trace.prototype.startTime = null;\n  /**\n   * Trace endTime.\n   * @member {google.protobuf.ITimestamp|null|undefined} endTime\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.endTime = null;\n  /**\n   * Trace durationNs.\n   * @member {number} durationNs\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.durationNs = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Trace root.\n   * @member {Trace.INode|null|undefined} root\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.root = null;\n  /**\n   * Trace signature.\n   * @member {string} signature\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.signature = \"\";\n  /**\n   * Trace unexecutedOperationBody.\n   * @member {string} unexecutedOperationBody\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.unexecutedOperationBody = \"\";\n  /**\n   * Trace unexecutedOperationName.\n   * @member {string} unexecutedOperationName\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.unexecutedOperationName = \"\";\n  /**\n   * Trace details.\n   * @member {Trace.IDetails|null|undefined} details\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.details = null;\n  /**\n   * Trace clientName.\n   * @member {string} clientName\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.clientName = \"\";\n  /**\n   * Trace clientVersion.\n   * @member {string} clientVersion\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.clientVersion = \"\";\n  /**\n   * Trace clientAddress.\n   * @member {string} clientAddress\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.clientAddress = \"\";\n  /**\n   * Trace clientReferenceId.\n   * @member {string} clientReferenceId\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.clientReferenceId = \"\";\n  /**\n   * Trace http.\n   * @member {Trace.IHTTP|null|undefined} http\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.http = null;\n  /**\n   * Trace cachePolicy.\n   * @member {Trace.ICachePolicy|null|undefined} cachePolicy\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.cachePolicy = null;\n  /**\n   * Trace queryPlan.\n   * @member {Trace.IQueryPlanNode|null|undefined} queryPlan\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.queryPlan = null;\n  /**\n   * Trace fullQueryCacheHit.\n   * @member {boolean} fullQueryCacheHit\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.fullQueryCacheHit = false;\n  /**\n   * Trace persistedQueryHit.\n   * @member {boolean} persistedQueryHit\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.persistedQueryHit = false;\n  /**\n   * Trace persistedQueryRegister.\n   * @member {boolean} persistedQueryRegister\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.persistedQueryRegister = false;\n  /**\n   * Trace registeredOperation.\n   * @member {boolean} registeredOperation\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.registeredOperation = false;\n  /**\n   * Trace forbiddenOperation.\n   * @member {boolean} forbiddenOperation\n   * @memberof Trace\n   * @instance\n   */\n\n  Trace.prototype.forbiddenOperation = false;\n  /**\n   * Creates a new Trace instance using the specified properties.\n   * @function create\n   * @memberof Trace\n   * @static\n   * @param {ITrace=} [properties] Properties to set\n   * @returns {Trace} Trace instance\n   */\n\n  Trace.create = function create(properties) {\n    return new Trace(properties);\n  };\n  /**\n   * Encodes the specified Trace message. Does not implicitly {@link Trace.verify|verify} messages.\n   * @function encode\n   * @memberof Trace\n   * @static\n   * @param {ITrace} message Trace message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Trace.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.endTime != null && Object.hasOwnProperty.call(message, \"endTime\")) $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(\n    /* id 3, wireType 2 =*/\n    26).fork()).ldelim();\n    if (message.startTime != null && Object.hasOwnProperty.call(message, \"startTime\")) $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(\n    /* id 4, wireType 2 =*/\n    34).fork()).ldelim();\n    if (message.details != null && Object.hasOwnProperty.call(message, \"details\")) $root.Trace.Details.encode(message.details, writer.uint32(\n    /* id 6, wireType 2 =*/\n    50).fork()).ldelim();\n    if (message.clientName != null && Object.hasOwnProperty.call(message, \"clientName\")) writer.uint32(\n    /* id 7, wireType 2 =*/\n    58).string(message.clientName);\n    if (message.clientVersion != null && Object.hasOwnProperty.call(message, \"clientVersion\")) writer.uint32(\n    /* id 8, wireType 2 =*/\n    66).string(message.clientVersion);\n    if (message.clientAddress != null && Object.hasOwnProperty.call(message, \"clientAddress\")) writer.uint32(\n    /* id 9, wireType 2 =*/\n    74).string(message.clientAddress);\n    if (message.http != null && Object.hasOwnProperty.call(message, \"http\")) $root.Trace.HTTP.encode(message.http, writer.uint32(\n    /* id 10, wireType 2 =*/\n    82).fork()).ldelim();\n    if (message.durationNs != null && Object.hasOwnProperty.call(message, \"durationNs\")) writer.uint32(\n    /* id 11, wireType 0 =*/\n    88).uint64(message.durationNs);\n    if (message.root != null && Object.hasOwnProperty.call(message, \"root\")) $root.Trace.Node.encode(message.root, writer.uint32(\n    /* id 14, wireType 2 =*/\n    114).fork()).ldelim();\n    if (message.cachePolicy != null && Object.hasOwnProperty.call(message, \"cachePolicy\")) $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(\n    /* id 18, wireType 2 =*/\n    146).fork()).ldelim();\n    if (message.signature != null && Object.hasOwnProperty.call(message, \"signature\")) writer.uint32(\n    /* id 19, wireType 2 =*/\n    154).string(message.signature);\n    if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, \"fullQueryCacheHit\")) writer.uint32(\n    /* id 20, wireType 0 =*/\n    160).bool(message.fullQueryCacheHit);\n    if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, \"persistedQueryHit\")) writer.uint32(\n    /* id 21, wireType 0 =*/\n    168).bool(message.persistedQueryHit);\n    if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, \"persistedQueryRegister\")) writer.uint32(\n    /* id 22, wireType 0 =*/\n    176).bool(message.persistedQueryRegister);\n    if (message.clientReferenceId != null && Object.hasOwnProperty.call(message, \"clientReferenceId\")) writer.uint32(\n    /* id 23, wireType 2 =*/\n    186).string(message.clientReferenceId);\n    if (message.registeredOperation != null && Object.hasOwnProperty.call(message, \"registeredOperation\")) writer.uint32(\n    /* id 24, wireType 0 =*/\n    192).bool(message.registeredOperation);\n    if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, \"forbiddenOperation\")) writer.uint32(\n    /* id 25, wireType 0 =*/\n    200).bool(message.forbiddenOperation);\n    if (message.queryPlan != null && Object.hasOwnProperty.call(message, \"queryPlan\")) $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(\n    /* id 26, wireType 2 =*/\n    210).fork()).ldelim();\n    if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, \"unexecutedOperationBody\")) writer.uint32(\n    /* id 27, wireType 2 =*/\n    218).string(message.unexecutedOperationBody);\n    if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, \"unexecutedOperationName\")) writer.uint32(\n    /* id 28, wireType 2 =*/\n    226).string(message.unexecutedOperationName);\n    return writer;\n  };\n  /**\n   * Encodes the specified Trace message, length delimited. Does not implicitly {@link Trace.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Trace\n   * @static\n   * @param {ITrace} message Trace message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Trace.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a Trace message from the specified reader or buffer.\n   * @function decode\n   * @memberof Trace\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Trace} Trace\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Trace.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.Trace();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 4:\n          message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n          break;\n\n        case 11:\n          message.durationNs = reader.uint64();\n          break;\n\n        case 14:\n          message.root = $root.Trace.Node.decode(reader, reader.uint32());\n          break;\n\n        case 19:\n          message.signature = reader.string();\n          break;\n\n        case 27:\n          message.unexecutedOperationBody = reader.string();\n          break;\n\n        case 28:\n          message.unexecutedOperationName = reader.string();\n          break;\n\n        case 6:\n          message.details = $root.Trace.Details.decode(reader, reader.uint32());\n          break;\n\n        case 7:\n          message.clientName = reader.string();\n          break;\n\n        case 8:\n          message.clientVersion = reader.string();\n          break;\n\n        case 9:\n          message.clientAddress = reader.string();\n          break;\n\n        case 23:\n          message.clientReferenceId = reader.string();\n          break;\n\n        case 10:\n          message.http = $root.Trace.HTTP.decode(reader, reader.uint32());\n          break;\n\n        case 18:\n          message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());\n          break;\n\n        case 26:\n          message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());\n          break;\n\n        case 20:\n          message.fullQueryCacheHit = reader.bool();\n          break;\n\n        case 21:\n          message.persistedQueryHit = reader.bool();\n          break;\n\n        case 22:\n          message.persistedQueryRegister = reader.bool();\n          break;\n\n        case 24:\n          message.registeredOperation = reader.bool();\n          break;\n\n        case 25:\n          message.forbiddenOperation = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a Trace message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Trace\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Trace} Trace\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Trace.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a Trace message.\n   * @function verify\n   * @memberof Trace\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  Trace.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.startTime != null && message.hasOwnProperty(\"startTime\")) {\n      var error = $root.google.protobuf.Timestamp.verify(message.startTime);\n      if (error) return \"startTime.\" + error;\n    }\n\n    if (message.endTime != null && message.hasOwnProperty(\"endTime\")) {\n      var error = $root.google.protobuf.Timestamp.verify(message.endTime);\n      if (error) return \"endTime.\" + error;\n    }\n\n    if (message.durationNs != null && message.hasOwnProperty(\"durationNs\")) if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high))) return \"durationNs: integer|Long expected\";\n\n    if (message.root != null && message.hasOwnProperty(\"root\")) {\n      var error = $root.Trace.Node.verify(message.root);\n      if (error) return \"root.\" + error;\n    }\n\n    if (message.signature != null && message.hasOwnProperty(\"signature\")) if (!$util.isString(message.signature)) return \"signature: string expected\";\n    if (message.unexecutedOperationBody != null && message.hasOwnProperty(\"unexecutedOperationBody\")) if (!$util.isString(message.unexecutedOperationBody)) return \"unexecutedOperationBody: string expected\";\n    if (message.unexecutedOperationName != null && message.hasOwnProperty(\"unexecutedOperationName\")) if (!$util.isString(message.unexecutedOperationName)) return \"unexecutedOperationName: string expected\";\n\n    if (message.details != null && message.hasOwnProperty(\"details\")) {\n      var error = $root.Trace.Details.verify(message.details);\n      if (error) return \"details.\" + error;\n    }\n\n    if (message.clientName != null && message.hasOwnProperty(\"clientName\")) if (!$util.isString(message.clientName)) return \"clientName: string expected\";\n    if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\")) if (!$util.isString(message.clientVersion)) return \"clientVersion: string expected\";\n    if (message.clientAddress != null && message.hasOwnProperty(\"clientAddress\")) if (!$util.isString(message.clientAddress)) return \"clientAddress: string expected\";\n    if (message.clientReferenceId != null && message.hasOwnProperty(\"clientReferenceId\")) if (!$util.isString(message.clientReferenceId)) return \"clientReferenceId: string expected\";\n\n    if (message.http != null && message.hasOwnProperty(\"http\")) {\n      var error = $root.Trace.HTTP.verify(message.http);\n      if (error) return \"http.\" + error;\n    }\n\n    if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\")) {\n      var error = $root.Trace.CachePolicy.verify(message.cachePolicy);\n      if (error) return \"cachePolicy.\" + error;\n    }\n\n    if (message.queryPlan != null && message.hasOwnProperty(\"queryPlan\")) {\n      var error = $root.Trace.QueryPlanNode.verify(message.queryPlan);\n      if (error) return \"queryPlan.\" + error;\n    }\n\n    if (message.fullQueryCacheHit != null && message.hasOwnProperty(\"fullQueryCacheHit\")) if (typeof message.fullQueryCacheHit !== \"boolean\") return \"fullQueryCacheHit: boolean expected\";\n    if (message.persistedQueryHit != null && message.hasOwnProperty(\"persistedQueryHit\")) if (typeof message.persistedQueryHit !== \"boolean\") return \"persistedQueryHit: boolean expected\";\n    if (message.persistedQueryRegister != null && message.hasOwnProperty(\"persistedQueryRegister\")) if (typeof message.persistedQueryRegister !== \"boolean\") return \"persistedQueryRegister: boolean expected\";\n    if (message.registeredOperation != null && message.hasOwnProperty(\"registeredOperation\")) if (typeof message.registeredOperation !== \"boolean\") return \"registeredOperation: boolean expected\";\n    if (message.forbiddenOperation != null && message.hasOwnProperty(\"forbiddenOperation\")) if (typeof message.forbiddenOperation !== \"boolean\") return \"forbiddenOperation: boolean expected\";\n    return null;\n  };\n  /**\n   * Creates a plain object from a Trace message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Trace\n   * @static\n   * @param {Trace} message Trace\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Trace.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.defaults) {\n      object.endTime = null;\n      object.startTime = null;\n      object.details = null;\n      object.clientName = \"\";\n      object.clientVersion = \"\";\n      object.clientAddress = \"\";\n      object.http = null;\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.durationNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.durationNs = options.longs === String ? \"0\" : 0;\n\n      object.root = null;\n      object.cachePolicy = null;\n      object.signature = \"\";\n      object.fullQueryCacheHit = false;\n      object.persistedQueryHit = false;\n      object.persistedQueryRegister = false;\n      object.clientReferenceId = \"\";\n      object.registeredOperation = false;\n      object.forbiddenOperation = false;\n      object.queryPlan = null;\n      object.unexecutedOperationBody = \"\";\n      object.unexecutedOperationName = \"\";\n    }\n\n    if (message.endTime != null && message.hasOwnProperty(\"endTime\")) object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);\n    if (message.startTime != null && message.hasOwnProperty(\"startTime\")) object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);\n    if (message.details != null && message.hasOwnProperty(\"details\")) object.details = $root.Trace.Details.toObject(message.details, options);\n    if (message.clientName != null && message.hasOwnProperty(\"clientName\")) object.clientName = message.clientName;\n    if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\")) object.clientVersion = message.clientVersion;\n    if (message.clientAddress != null && message.hasOwnProperty(\"clientAddress\")) object.clientAddress = message.clientAddress;\n    if (message.http != null && message.hasOwnProperty(\"http\")) object.http = $root.Trace.HTTP.toObject(message.http, options);\n    if (message.durationNs != null && message.hasOwnProperty(\"durationNs\")) if (typeof message.durationNs === \"number\") object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;else object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;\n    if (message.root != null && message.hasOwnProperty(\"root\")) object.root = $root.Trace.Node.toObject(message.root, options);\n    if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\")) object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);\n    if (message.signature != null && message.hasOwnProperty(\"signature\")) object.signature = message.signature;\n    if (message.fullQueryCacheHit != null && message.hasOwnProperty(\"fullQueryCacheHit\")) object.fullQueryCacheHit = message.fullQueryCacheHit;\n    if (message.persistedQueryHit != null && message.hasOwnProperty(\"persistedQueryHit\")) object.persistedQueryHit = message.persistedQueryHit;\n    if (message.persistedQueryRegister != null && message.hasOwnProperty(\"persistedQueryRegister\")) object.persistedQueryRegister = message.persistedQueryRegister;\n    if (message.clientReferenceId != null && message.hasOwnProperty(\"clientReferenceId\")) object.clientReferenceId = message.clientReferenceId;\n    if (message.registeredOperation != null && message.hasOwnProperty(\"registeredOperation\")) object.registeredOperation = message.registeredOperation;\n    if (message.forbiddenOperation != null && message.hasOwnProperty(\"forbiddenOperation\")) object.forbiddenOperation = message.forbiddenOperation;\n    if (message.queryPlan != null && message.hasOwnProperty(\"queryPlan\")) object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);\n    if (message.unexecutedOperationBody != null && message.hasOwnProperty(\"unexecutedOperationBody\")) object.unexecutedOperationBody = message.unexecutedOperationBody;\n    if (message.unexecutedOperationName != null && message.hasOwnProperty(\"unexecutedOperationName\")) object.unexecutedOperationName = message.unexecutedOperationName;\n    return object;\n  };\n  /**\n   * Converts this Trace to JSON.\n   * @function toJSON\n   * @memberof Trace\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Trace.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  Trace.CachePolicy = function () {\n    /**\n     * Properties of a CachePolicy.\n     * @memberof Trace\n     * @interface ICachePolicy\n     * @property {Trace.CachePolicy.Scope|null} [scope] CachePolicy scope\n     * @property {number|null} [maxAgeNs] CachePolicy maxAgeNs\n     */\n\n    /**\n     * Constructs a new CachePolicy.\n     * @memberof Trace\n     * @classdesc Represents a CachePolicy.\n     * @implements ICachePolicy\n     * @constructor\n     * @param {Trace.ICachePolicy=} [properties] Properties to set\n     */\n    function CachePolicy(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CachePolicy scope.\n     * @member {Trace.CachePolicy.Scope} scope\n     * @memberof Trace.CachePolicy\n     * @instance\n     */\n\n\n    CachePolicy.prototype.scope = 0;\n    /**\n     * CachePolicy maxAgeNs.\n     * @member {number} maxAgeNs\n     * @memberof Trace.CachePolicy\n     * @instance\n     */\n\n    CachePolicy.prototype.maxAgeNs = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n    /**\n     * Creates a new CachePolicy instance using the specified properties.\n     * @function create\n     * @memberof Trace.CachePolicy\n     * @static\n     * @param {Trace.ICachePolicy=} [properties] Properties to set\n     * @returns {Trace.CachePolicy} CachePolicy instance\n     */\n\n    CachePolicy.create = function create(properties) {\n      return new CachePolicy(properties);\n    };\n    /**\n     * Encodes the specified CachePolicy message. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.\n     * @function encode\n     * @memberof Trace.CachePolicy\n     * @static\n     * @param {Trace.ICachePolicy} message CachePolicy message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CachePolicy.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.scope != null && Object.hasOwnProperty.call(message, \"scope\")) writer.uint32(\n      /* id 1, wireType 0 =*/\n      8).int32(message.scope);\n      if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, \"maxAgeNs\")) writer.uint32(\n      /* id 2, wireType 0 =*/\n      16).int64(message.maxAgeNs);\n      return writer;\n    };\n    /**\n     * Encodes the specified CachePolicy message, length delimited. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Trace.CachePolicy\n     * @static\n     * @param {Trace.ICachePolicy} message CachePolicy message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    CachePolicy.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a CachePolicy message from the specified reader or buffer.\n     * @function decode\n     * @memberof Trace.CachePolicy\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Trace.CachePolicy} CachePolicy\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CachePolicy.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Trace.CachePolicy();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.scope = reader.int32();\n            break;\n\n          case 2:\n            message.maxAgeNs = reader.int64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a CachePolicy message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Trace.CachePolicy\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Trace.CachePolicy} CachePolicy\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    CachePolicy.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a CachePolicy message.\n     * @function verify\n     * @memberof Trace.CachePolicy\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    CachePolicy.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.scope != null && message.hasOwnProperty(\"scope\")) switch (message.scope) {\n        default:\n          return \"scope: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n          break;\n      }\n      if (message.maxAgeNs != null && message.hasOwnProperty(\"maxAgeNs\")) if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high))) return \"maxAgeNs: integer|Long expected\";\n      return null;\n    };\n    /**\n     * Creates a plain object from a CachePolicy message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Trace.CachePolicy\n     * @static\n     * @param {Trace.CachePolicy} message CachePolicy\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    CachePolicy.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.scope = options.enums === String ? \"UNKNOWN\" : 0;\n\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, false);\n          object.maxAgeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.maxAgeNs = options.longs === String ? \"0\" : 0;\n      }\n\n      if (message.scope != null && message.hasOwnProperty(\"scope\")) object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;\n      if (message.maxAgeNs != null && message.hasOwnProperty(\"maxAgeNs\")) if (typeof message.maxAgeNs === \"number\") object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;else object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;\n      return object;\n    };\n    /**\n     * Converts this CachePolicy to JSON.\n     * @function toJSON\n     * @memberof Trace.CachePolicy\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    CachePolicy.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    /**\n     * Scope enum.\n     * @name Trace.CachePolicy.Scope\n     * @enum {string}\n     * @property {number} UNKNOWN=0 UNKNOWN value\n     * @property {number} PUBLIC=1 PUBLIC value\n     * @property {number} PRIVATE=2 PRIVATE value\n     */\n\n\n    CachePolicy.Scope = function () {\n      var valuesById = {},\n          values = Object.create(valuesById);\n      values[valuesById[0] = \"UNKNOWN\"] = 0;\n      values[valuesById[1] = \"PUBLIC\"] = 1;\n      values[valuesById[2] = \"PRIVATE\"] = 2;\n      return values;\n    }();\n\n    return CachePolicy;\n  }();\n\n  Trace.Details = function () {\n    /**\n     * Properties of a Details.\n     * @memberof Trace\n     * @interface IDetails\n     * @property {Object.<string,string>|null} [variablesJson] Details variablesJson\n     * @property {string|null} [operationName] Details operationName\n     */\n\n    /**\n     * Constructs a new Details.\n     * @memberof Trace\n     * @classdesc Represents a Details.\n     * @implements IDetails\n     * @constructor\n     * @param {Trace.IDetails=} [properties] Properties to set\n     */\n    function Details(properties) {\n      this.variablesJson = {};\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Details variablesJson.\n     * @member {Object.<string,string>} variablesJson\n     * @memberof Trace.Details\n     * @instance\n     */\n\n\n    Details.prototype.variablesJson = $util.emptyObject;\n    /**\n     * Details operationName.\n     * @member {string} operationName\n     * @memberof Trace.Details\n     * @instance\n     */\n\n    Details.prototype.operationName = \"\";\n    /**\n     * Creates a new Details instance using the specified properties.\n     * @function create\n     * @memberof Trace.Details\n     * @static\n     * @param {Trace.IDetails=} [properties] Properties to set\n     * @returns {Trace.Details} Details instance\n     */\n\n    Details.create = function create(properties) {\n      return new Details(properties);\n    };\n    /**\n     * Encodes the specified Details message. Does not implicitly {@link Trace.Details.verify|verify} messages.\n     * @function encode\n     * @memberof Trace.Details\n     * @static\n     * @param {Trace.IDetails} message Details message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Details.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.operationName != null && Object.hasOwnProperty.call(message, \"operationName\")) writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).string(message.operationName);\n      if (message.variablesJson != null && Object.hasOwnProperty.call(message, \"variablesJson\")) for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i) writer.uint32(\n      /* id 4, wireType 2 =*/\n      34).fork().uint32(\n      /* id 1, wireType 2 =*/\n      10).string(keys[i]).uint32(\n      /* id 2, wireType 2 =*/\n      18).string(message.variablesJson[keys[i]]).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified Details message, length delimited. Does not implicitly {@link Trace.Details.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Trace.Details\n     * @static\n     * @param {Trace.IDetails} message Details message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Details.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a Details message from the specified reader or buffer.\n     * @function decode\n     * @memberof Trace.Details\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Trace.Details} Details\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Details.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Trace.Details(),\n          key;\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 4:\n            reader.skip().pos++;\n            if (message.variablesJson === $util.emptyObject) message.variablesJson = {};\n            key = reader.string();\n            reader.pos++;\n            message.variablesJson[key] = reader.string();\n            break;\n\n          case 3:\n            message.operationName = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a Details message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Trace.Details\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Trace.Details} Details\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Details.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a Details message.\n     * @function verify\n     * @memberof Trace.Details\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    Details.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n      if (message.variablesJson != null && message.hasOwnProperty(\"variablesJson\")) {\n        if (!$util.isObject(message.variablesJson)) return \"variablesJson: object expected\";\n        var key = Object.keys(message.variablesJson);\n\n        for (var i = 0; i < key.length; ++i) if (!$util.isString(message.variablesJson[key[i]])) return \"variablesJson: string{k:string} expected\";\n      }\n\n      if (message.operationName != null && message.hasOwnProperty(\"operationName\")) if (!$util.isString(message.operationName)) return \"operationName: string expected\";\n      return null;\n    };\n    /**\n     * Creates a plain object from a Details message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Trace.Details\n     * @static\n     * @param {Trace.Details} message Details\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Details.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.objects || options.defaults) object.variablesJson = {};\n      if (options.defaults) object.operationName = \"\";\n      if (message.operationName != null && message.hasOwnProperty(\"operationName\")) object.operationName = message.operationName;\n      var keys2;\n\n      if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {\n        object.variablesJson = {};\n\n        for (var j = 0; j < keys2.length; ++j) object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];\n      }\n\n      return object;\n    };\n    /**\n     * Converts this Details to JSON.\n     * @function toJSON\n     * @memberof Trace.Details\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Details.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Details;\n  }();\n\n  Trace.Error = function () {\n    /**\n     * Properties of an Error.\n     * @memberof Trace\n     * @interface IError\n     * @property {string|null} [message] Error message\n     * @property {Array.<Trace.ILocation>|null} [location] Error location\n     * @property {number|null} [timeNs] Error timeNs\n     * @property {string|null} [json] Error json\n     */\n\n    /**\n     * Constructs a new Error.\n     * @memberof Trace\n     * @classdesc Represents an Error.\n     * @implements IError\n     * @constructor\n     * @param {Trace.IError=} [properties] Properties to set\n     */\n    function Error(properties) {\n      this.location = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Error message.\n     * @member {string} message\n     * @memberof Trace.Error\n     * @instance\n     */\n\n\n    Error.prototype.message = \"\";\n    /**\n     * Error location.\n     * @member {Array.<Trace.ILocation>} location\n     * @memberof Trace.Error\n     * @instance\n     */\n\n    Error.prototype.location = $util.emptyArray;\n    /**\n     * Error timeNs.\n     * @member {number} timeNs\n     * @memberof Trace.Error\n     * @instance\n     */\n\n    Error.prototype.timeNs = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * Error json.\n     * @member {string} json\n     * @memberof Trace.Error\n     * @instance\n     */\n\n    Error.prototype.json = \"\";\n    /**\n     * Creates a new Error instance using the specified properties.\n     * @function create\n     * @memberof Trace.Error\n     * @static\n     * @param {Trace.IError=} [properties] Properties to set\n     * @returns {Trace.Error} Error instance\n     */\n\n    Error.create = function create(properties) {\n      return new Error(properties);\n    };\n    /**\n     * Encodes the specified Error message. Does not implicitly {@link Trace.Error.verify|verify} messages.\n     * @function encode\n     * @memberof Trace.Error\n     * @static\n     * @param {Trace.IError} message Error message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Error.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.message != null && Object.hasOwnProperty.call(message, \"message\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).string(message.message);\n      if (message.location != null && message.location.length) for (var i = 0; i < message.location.length; ++i) $root.Trace.Location.encode(message.location[i], writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.timeNs != null && Object.hasOwnProperty.call(message, \"timeNs\")) writer.uint32(\n      /* id 3, wireType 0 =*/\n      24).uint64(message.timeNs);\n      if (message.json != null && Object.hasOwnProperty.call(message, \"json\")) writer.uint32(\n      /* id 4, wireType 2 =*/\n      34).string(message.json);\n      return writer;\n    };\n    /**\n     * Encodes the specified Error message, length delimited. Does not implicitly {@link Trace.Error.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Trace.Error\n     * @static\n     * @param {Trace.IError} message Error message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Error.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an Error message from the specified reader or buffer.\n     * @function decode\n     * @memberof Trace.Error\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Trace.Error} Error\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Error.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Trace.Error();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.message = reader.string();\n            break;\n\n          case 2:\n            if (!(message.location && message.location.length)) message.location = [];\n            message.location.push($root.Trace.Location.decode(reader, reader.uint32()));\n            break;\n\n          case 3:\n            message.timeNs = reader.uint64();\n            break;\n\n          case 4:\n            message.json = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes an Error message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Trace.Error\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Trace.Error} Error\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Error.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an Error message.\n     * @function verify\n     * @memberof Trace.Error\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    Error.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.message != null && message.hasOwnProperty(\"message\")) if (!$util.isString(message.message)) return \"message: string expected\";\n\n      if (message.location != null && message.hasOwnProperty(\"location\")) {\n        if (!Array.isArray(message.location)) return \"location: array expected\";\n\n        for (var i = 0; i < message.location.length; ++i) {\n          var error = $root.Trace.Location.verify(message.location[i]);\n          if (error) return \"location.\" + error;\n        }\n      }\n\n      if (message.timeNs != null && message.hasOwnProperty(\"timeNs\")) if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high))) return \"timeNs: integer|Long expected\";\n      if (message.json != null && message.hasOwnProperty(\"json\")) if (!$util.isString(message.json)) return \"json: string expected\";\n      return null;\n    };\n    /**\n     * Creates a plain object from an Error message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Trace.Error\n     * @static\n     * @param {Trace.Error} message Error\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Error.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n      if (options.arrays || options.defaults) object.location = [];\n\n      if (options.defaults) {\n        object.message = \"\";\n\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, true);\n          object.timeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.timeNs = options.longs === String ? \"0\" : 0;\n\n        object.json = \"\";\n      }\n\n      if (message.message != null && message.hasOwnProperty(\"message\")) object.message = message.message;\n\n      if (message.location && message.location.length) {\n        object.location = [];\n\n        for (var j = 0; j < message.location.length; ++j) object.location[j] = $root.Trace.Location.toObject(message.location[j], options);\n      }\n\n      if (message.timeNs != null && message.hasOwnProperty(\"timeNs\")) if (typeof message.timeNs === \"number\") object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;else object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;\n      if (message.json != null && message.hasOwnProperty(\"json\")) object.json = message.json;\n      return object;\n    };\n    /**\n     * Converts this Error to JSON.\n     * @function toJSON\n     * @memberof Trace.Error\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Error.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Error;\n  }();\n\n  Trace.HTTP = function () {\n    /**\n     * Properties of a HTTP.\n     * @memberof Trace\n     * @interface IHTTP\n     * @property {Trace.HTTP.Method|null} [method] HTTP method\n     * @property {string|null} [host] HTTP host\n     * @property {string|null} [path] HTTP path\n     * @property {Object.<string,Trace.HTTP.IValues>|null} [requestHeaders] HTTP requestHeaders\n     * @property {Object.<string,Trace.HTTP.IValues>|null} [responseHeaders] HTTP responseHeaders\n     * @property {number|null} [statusCode] HTTP statusCode\n     * @property {boolean|null} [secure] HTTP secure\n     * @property {string|null} [protocol] HTTP protocol\n     */\n\n    /**\n     * Constructs a new HTTP.\n     * @memberof Trace\n     * @classdesc Represents a HTTP.\n     * @implements IHTTP\n     * @constructor\n     * @param {Trace.IHTTP=} [properties] Properties to set\n     */\n    function HTTP(properties) {\n      this.requestHeaders = {};\n      this.responseHeaders = {};\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * HTTP method.\n     * @member {Trace.HTTP.Method} method\n     * @memberof Trace.HTTP\n     * @instance\n     */\n\n\n    HTTP.prototype.method = 0;\n    /**\n     * HTTP host.\n     * @member {string} host\n     * @memberof Trace.HTTP\n     * @instance\n     */\n\n    HTTP.prototype.host = \"\";\n    /**\n     * HTTP path.\n     * @member {string} path\n     * @memberof Trace.HTTP\n     * @instance\n     */\n\n    HTTP.prototype.path = \"\";\n    /**\n     * HTTP requestHeaders.\n     * @member {Object.<string,Trace.HTTP.IValues>} requestHeaders\n     * @memberof Trace.HTTP\n     * @instance\n     */\n\n    HTTP.prototype.requestHeaders = $util.emptyObject;\n    /**\n     * HTTP responseHeaders.\n     * @member {Object.<string,Trace.HTTP.IValues>} responseHeaders\n     * @memberof Trace.HTTP\n     * @instance\n     */\n\n    HTTP.prototype.responseHeaders = $util.emptyObject;\n    /**\n     * HTTP statusCode.\n     * @member {number} statusCode\n     * @memberof Trace.HTTP\n     * @instance\n     */\n\n    HTTP.prototype.statusCode = 0;\n    /**\n     * HTTP secure.\n     * @member {boolean} secure\n     * @memberof Trace.HTTP\n     * @instance\n     */\n\n    HTTP.prototype.secure = false;\n    /**\n     * HTTP protocol.\n     * @member {string} protocol\n     * @memberof Trace.HTTP\n     * @instance\n     */\n\n    HTTP.prototype.protocol = \"\";\n    /**\n     * Creates a new HTTP instance using the specified properties.\n     * @function create\n     * @memberof Trace.HTTP\n     * @static\n     * @param {Trace.IHTTP=} [properties] Properties to set\n     * @returns {Trace.HTTP} HTTP instance\n     */\n\n    HTTP.create = function create(properties) {\n      return new HTTP(properties);\n    };\n    /**\n     * Encodes the specified HTTP message. Does not implicitly {@link Trace.HTTP.verify|verify} messages.\n     * @function encode\n     * @memberof Trace.HTTP\n     * @static\n     * @param {Trace.IHTTP} message HTTP message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    HTTP.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.method != null && Object.hasOwnProperty.call(message, \"method\")) writer.uint32(\n      /* id 1, wireType 0 =*/\n      8).int32(message.method);\n      if (message.host != null && Object.hasOwnProperty.call(message, \"host\")) writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).string(message.host);\n      if (message.path != null && Object.hasOwnProperty.call(message, \"path\")) writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).string(message.path);\n      if (message.requestHeaders != null && Object.hasOwnProperty.call(message, \"requestHeaders\")) for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {\n        writer.uint32(\n        /* id 4, wireType 2 =*/\n        34).fork().uint32(\n        /* id 1, wireType 2 =*/\n        10).string(keys[i]);\n        $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(\n        /* id 2, wireType 2 =*/\n        18).fork()).ldelim().ldelim();\n      }\n      if (message.responseHeaders != null && Object.hasOwnProperty.call(message, \"responseHeaders\")) for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {\n        writer.uint32(\n        /* id 5, wireType 2 =*/\n        42).fork().uint32(\n        /* id 1, wireType 2 =*/\n        10).string(keys[i]);\n        $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(\n        /* id 2, wireType 2 =*/\n        18).fork()).ldelim().ldelim();\n      }\n      if (message.statusCode != null && Object.hasOwnProperty.call(message, \"statusCode\")) writer.uint32(\n      /* id 6, wireType 0 =*/\n      48).uint32(message.statusCode);\n      if (message.secure != null && Object.hasOwnProperty.call(message, \"secure\")) writer.uint32(\n      /* id 8, wireType 0 =*/\n      64).bool(message.secure);\n      if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\")) writer.uint32(\n      /* id 9, wireType 2 =*/\n      74).string(message.protocol);\n      return writer;\n    };\n    /**\n     * Encodes the specified HTTP message, length delimited. Does not implicitly {@link Trace.HTTP.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Trace.HTTP\n     * @static\n     * @param {Trace.IHTTP} message HTTP message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    HTTP.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a HTTP message from the specified reader or buffer.\n     * @function decode\n     * @memberof Trace.HTTP\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Trace.HTTP} HTTP\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    HTTP.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Trace.HTTP(),\n          key;\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.method = reader.int32();\n            break;\n\n          case 2:\n            message.host = reader.string();\n            break;\n\n          case 3:\n            message.path = reader.string();\n            break;\n\n          case 4:\n            reader.skip().pos++;\n            if (message.requestHeaders === $util.emptyObject) message.requestHeaders = {};\n            key = reader.string();\n            reader.pos++;\n            message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());\n            break;\n\n          case 5:\n            reader.skip().pos++;\n            if (message.responseHeaders === $util.emptyObject) message.responseHeaders = {};\n            key = reader.string();\n            reader.pos++;\n            message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());\n            break;\n\n          case 6:\n            message.statusCode = reader.uint32();\n            break;\n\n          case 8:\n            message.secure = reader.bool();\n            break;\n\n          case 9:\n            message.protocol = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a HTTP message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Trace.HTTP\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Trace.HTTP} HTTP\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    HTTP.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a HTTP message.\n     * @function verify\n     * @memberof Trace.HTTP\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    HTTP.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.method != null && message.hasOwnProperty(\"method\")) switch (message.method) {\n        default:\n          return \"method: enum value expected\";\n\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n          break;\n      }\n      if (message.host != null && message.hasOwnProperty(\"host\")) if (!$util.isString(message.host)) return \"host: string expected\";\n      if (message.path != null && message.hasOwnProperty(\"path\")) if (!$util.isString(message.path)) return \"path: string expected\";\n\n      if (message.requestHeaders != null && message.hasOwnProperty(\"requestHeaders\")) {\n        if (!$util.isObject(message.requestHeaders)) return \"requestHeaders: object expected\";\n        var key = Object.keys(message.requestHeaders);\n\n        for (var i = 0; i < key.length; ++i) {\n          var error = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);\n          if (error) return \"requestHeaders.\" + error;\n        }\n      }\n\n      if (message.responseHeaders != null && message.hasOwnProperty(\"responseHeaders\")) {\n        if (!$util.isObject(message.responseHeaders)) return \"responseHeaders: object expected\";\n        var key = Object.keys(message.responseHeaders);\n\n        for (var i = 0; i < key.length; ++i) {\n          var error = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);\n          if (error) return \"responseHeaders.\" + error;\n        }\n      }\n\n      if (message.statusCode != null && message.hasOwnProperty(\"statusCode\")) if (!$util.isInteger(message.statusCode)) return \"statusCode: integer expected\";\n      if (message.secure != null && message.hasOwnProperty(\"secure\")) if (typeof message.secure !== \"boolean\") return \"secure: boolean expected\";\n      if (message.protocol != null && message.hasOwnProperty(\"protocol\")) if (!$util.isString(message.protocol)) return \"protocol: string expected\";\n      return null;\n    };\n    /**\n     * Creates a plain object from a HTTP message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Trace.HTTP\n     * @static\n     * @param {Trace.HTTP} message HTTP\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    HTTP.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.objects || options.defaults) {\n        object.requestHeaders = {};\n        object.responseHeaders = {};\n      }\n\n      if (options.defaults) {\n        object.method = options.enums === String ? \"UNKNOWN\" : 0;\n        object.host = \"\";\n        object.path = \"\";\n        object.statusCode = 0;\n        object.secure = false;\n        object.protocol = \"\";\n      }\n\n      if (message.method != null && message.hasOwnProperty(\"method\")) object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;\n      if (message.host != null && message.hasOwnProperty(\"host\")) object.host = message.host;\n      if (message.path != null && message.hasOwnProperty(\"path\")) object.path = message.path;\n      var keys2;\n\n      if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {\n        object.requestHeaders = {};\n\n        for (var j = 0; j < keys2.length; ++j) object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);\n      }\n\n      if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {\n        object.responseHeaders = {};\n\n        for (var j = 0; j < keys2.length; ++j) object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);\n      }\n\n      if (message.statusCode != null && message.hasOwnProperty(\"statusCode\")) object.statusCode = message.statusCode;\n      if (message.secure != null && message.hasOwnProperty(\"secure\")) object.secure = message.secure;\n      if (message.protocol != null && message.hasOwnProperty(\"protocol\")) object.protocol = message.protocol;\n      return object;\n    };\n    /**\n     * Converts this HTTP to JSON.\n     * @function toJSON\n     * @memberof Trace.HTTP\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    HTTP.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    HTTP.Values = function () {\n      /**\n       * Properties of a Values.\n       * @memberof Trace.HTTP\n       * @interface IValues\n       * @property {Array.<string>|null} [value] Values value\n       */\n\n      /**\n       * Constructs a new Values.\n       * @memberof Trace.HTTP\n       * @classdesc Represents a Values.\n       * @implements IValues\n       * @constructor\n       * @param {Trace.HTTP.IValues=} [properties] Properties to set\n       */\n      function Values(properties) {\n        this.value = [];\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * Values value.\n       * @member {Array.<string>} value\n       * @memberof Trace.HTTP.Values\n       * @instance\n       */\n\n\n      Values.prototype.value = $util.emptyArray;\n      /**\n       * Creates a new Values instance using the specified properties.\n       * @function create\n       * @memberof Trace.HTTP.Values\n       * @static\n       * @param {Trace.HTTP.IValues=} [properties] Properties to set\n       * @returns {Trace.HTTP.Values} Values instance\n       */\n\n      Values.create = function create(properties) {\n        return new Values(properties);\n      };\n      /**\n       * Encodes the specified Values message. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.\n       * @function encode\n       * @memberof Trace.HTTP.Values\n       * @static\n       * @param {Trace.HTTP.IValues} message Values message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      Values.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.value != null && message.value.length) for (var i = 0; i < message.value.length; ++i) writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).string(message.value[i]);\n        return writer;\n      };\n      /**\n       * Encodes the specified Values message, length delimited. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof Trace.HTTP.Values\n       * @static\n       * @param {Trace.HTTP.IValues} message Values message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      Values.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a Values message from the specified reader or buffer.\n       * @function decode\n       * @memberof Trace.HTTP.Values\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {Trace.HTTP.Values} Values\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      Values.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.Trace.HTTP.Values();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              if (!(message.value && message.value.length)) message.value = [];\n              message.value.push(reader.string());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a Values message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof Trace.HTTP.Values\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {Trace.HTTP.Values} Values\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      Values.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a Values message.\n       * @function verify\n       * @memberof Trace.HTTP.Values\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      Values.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n        if (message.value != null && message.hasOwnProperty(\"value\")) {\n          if (!Array.isArray(message.value)) return \"value: array expected\";\n\n          for (var i = 0; i < message.value.length; ++i) if (!$util.isString(message.value[i])) return \"value: string[] expected\";\n        }\n\n        return null;\n      };\n      /**\n       * Creates a plain object from a Values message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof Trace.HTTP.Values\n       * @static\n       * @param {Trace.HTTP.Values} message Values\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      Values.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.arrays || options.defaults) object.value = [];\n\n        if (message.value && message.value.length) {\n          object.value = [];\n\n          for (var j = 0; j < message.value.length; ++j) object.value[j] = message.value[j];\n        }\n\n        return object;\n      };\n      /**\n       * Converts this Values to JSON.\n       * @function toJSON\n       * @memberof Trace.HTTP.Values\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      Values.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return Values;\n    }();\n    /**\n     * Method enum.\n     * @name Trace.HTTP.Method\n     * @enum {string}\n     * @property {number} UNKNOWN=0 UNKNOWN value\n     * @property {number} OPTIONS=1 OPTIONS value\n     * @property {number} GET=2 GET value\n     * @property {number} HEAD=3 HEAD value\n     * @property {number} POST=4 POST value\n     * @property {number} PUT=5 PUT value\n     * @property {number} DELETE=6 DELETE value\n     * @property {number} TRACE=7 TRACE value\n     * @property {number} CONNECT=8 CONNECT value\n     * @property {number} PATCH=9 PATCH value\n     */\n\n\n    HTTP.Method = function () {\n      var valuesById = {},\n          values = Object.create(valuesById);\n      values[valuesById[0] = \"UNKNOWN\"] = 0;\n      values[valuesById[1] = \"OPTIONS\"] = 1;\n      values[valuesById[2] = \"GET\"] = 2;\n      values[valuesById[3] = \"HEAD\"] = 3;\n      values[valuesById[4] = \"POST\"] = 4;\n      values[valuesById[5] = \"PUT\"] = 5;\n      values[valuesById[6] = \"DELETE\"] = 6;\n      values[valuesById[7] = \"TRACE\"] = 7;\n      values[valuesById[8] = \"CONNECT\"] = 8;\n      values[valuesById[9] = \"PATCH\"] = 9;\n      return values;\n    }();\n\n    return HTTP;\n  }();\n\n  Trace.Location = function () {\n    /**\n     * Properties of a Location.\n     * @memberof Trace\n     * @interface ILocation\n     * @property {number|null} [line] Location line\n     * @property {number|null} [column] Location column\n     */\n\n    /**\n     * Constructs a new Location.\n     * @memberof Trace\n     * @classdesc Represents a Location.\n     * @implements ILocation\n     * @constructor\n     * @param {Trace.ILocation=} [properties] Properties to set\n     */\n    function Location(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Location line.\n     * @member {number} line\n     * @memberof Trace.Location\n     * @instance\n     */\n\n\n    Location.prototype.line = 0;\n    /**\n     * Location column.\n     * @member {number} column\n     * @memberof Trace.Location\n     * @instance\n     */\n\n    Location.prototype.column = 0;\n    /**\n     * Creates a new Location instance using the specified properties.\n     * @function create\n     * @memberof Trace.Location\n     * @static\n     * @param {Trace.ILocation=} [properties] Properties to set\n     * @returns {Trace.Location} Location instance\n     */\n\n    Location.create = function create(properties) {\n      return new Location(properties);\n    };\n    /**\n     * Encodes the specified Location message. Does not implicitly {@link Trace.Location.verify|verify} messages.\n     * @function encode\n     * @memberof Trace.Location\n     * @static\n     * @param {Trace.ILocation} message Location message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Location.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.line != null && Object.hasOwnProperty.call(message, \"line\")) writer.uint32(\n      /* id 1, wireType 0 =*/\n      8).uint32(message.line);\n      if (message.column != null && Object.hasOwnProperty.call(message, \"column\")) writer.uint32(\n      /* id 2, wireType 0 =*/\n      16).uint32(message.column);\n      return writer;\n    };\n    /**\n     * Encodes the specified Location message, length delimited. Does not implicitly {@link Trace.Location.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Trace.Location\n     * @static\n     * @param {Trace.ILocation} message Location message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Location.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a Location message from the specified reader or buffer.\n     * @function decode\n     * @memberof Trace.Location\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Trace.Location} Location\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Location.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Trace.Location();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.line = reader.uint32();\n            break;\n\n          case 2:\n            message.column = reader.uint32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a Location message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Trace.Location\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Trace.Location} Location\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Location.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a Location message.\n     * @function verify\n     * @memberof Trace.Location\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    Location.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      if (message.line != null && message.hasOwnProperty(\"line\")) if (!$util.isInteger(message.line)) return \"line: integer expected\";\n      if (message.column != null && message.hasOwnProperty(\"column\")) if (!$util.isInteger(message.column)) return \"column: integer expected\";\n      return null;\n    };\n    /**\n     * Creates a plain object from a Location message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Trace.Location\n     * @static\n     * @param {Trace.Location} message Location\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Location.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.defaults) {\n        object.line = 0;\n        object.column = 0;\n      }\n\n      if (message.line != null && message.hasOwnProperty(\"line\")) object.line = message.line;\n      if (message.column != null && message.hasOwnProperty(\"column\")) object.column = message.column;\n      return object;\n    };\n    /**\n     * Converts this Location to JSON.\n     * @function toJSON\n     * @memberof Trace.Location\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Location.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Location;\n  }();\n\n  Trace.Node = function () {\n    /**\n     * Properties of a Node.\n     * @memberof Trace\n     * @interface INode\n     * @property {string|null} [responseName] Node responseName\n     * @property {number|null} [index] Node index\n     * @property {string|null} [originalFieldName] Node originalFieldName\n     * @property {string|null} [type] Node type\n     * @property {string|null} [parentType] Node parentType\n     * @property {Trace.ICachePolicy|null} [cachePolicy] Node cachePolicy\n     * @property {number|null} [startTime] Node startTime\n     * @property {number|null} [endTime] Node endTime\n     * @property {Array.<Trace.IError>|null} [error] Node error\n     * @property {Array.<Trace.INode>|null} [child] Node child\n     */\n\n    /**\n     * Constructs a new Node.\n     * @memberof Trace\n     * @classdesc Represents a Node.\n     * @implements INode\n     * @constructor\n     * @param {Trace.INode=} [properties] Properties to set\n     */\n    function Node(properties) {\n      this.error = [];\n      this.child = [];\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Node responseName.\n     * @member {string} responseName\n     * @memberof Trace.Node\n     * @instance\n     */\n\n\n    Node.prototype.responseName = \"\";\n    /**\n     * Node index.\n     * @member {number} index\n     * @memberof Trace.Node\n     * @instance\n     */\n\n    Node.prototype.index = 0;\n    /**\n     * Node originalFieldName.\n     * @member {string} originalFieldName\n     * @memberof Trace.Node\n     * @instance\n     */\n\n    Node.prototype.originalFieldName = \"\";\n    /**\n     * Node type.\n     * @member {string} type\n     * @memberof Trace.Node\n     * @instance\n     */\n\n    Node.prototype.type = \"\";\n    /**\n     * Node parentType.\n     * @member {string} parentType\n     * @memberof Trace.Node\n     * @instance\n     */\n\n    Node.prototype.parentType = \"\";\n    /**\n     * Node cachePolicy.\n     * @member {Trace.ICachePolicy|null|undefined} cachePolicy\n     * @memberof Trace.Node\n     * @instance\n     */\n\n    Node.prototype.cachePolicy = null;\n    /**\n     * Node startTime.\n     * @member {number} startTime\n     * @memberof Trace.Node\n     * @instance\n     */\n\n    Node.prototype.startTime = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * Node endTime.\n     * @member {number} endTime\n     * @memberof Trace.Node\n     * @instance\n     */\n\n    Node.prototype.endTime = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * Node error.\n     * @member {Array.<Trace.IError>} error\n     * @memberof Trace.Node\n     * @instance\n     */\n\n    Node.prototype.error = $util.emptyArray;\n    /**\n     * Node child.\n     * @member {Array.<Trace.INode>} child\n     * @memberof Trace.Node\n     * @instance\n     */\n\n    Node.prototype.child = $util.emptyArray; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * Node id.\n     * @member {\"responseName\"|\"index\"|undefined} id\n     * @memberof Trace.Node\n     * @instance\n     */\n\n    Object.defineProperty(Node.prototype, \"id\", {\n      get: $util.oneOfGetter($oneOfFields = [\"responseName\", \"index\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Creates a new Node instance using the specified properties.\n     * @function create\n     * @memberof Trace.Node\n     * @static\n     * @param {Trace.INode=} [properties] Properties to set\n     * @returns {Trace.Node} Node instance\n     */\n\n    Node.create = function create(properties) {\n      return new Node(properties);\n    };\n    /**\n     * Encodes the specified Node message. Does not implicitly {@link Trace.Node.verify|verify} messages.\n     * @function encode\n     * @memberof Trace.Node\n     * @static\n     * @param {Trace.INode} message Node message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Node.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.responseName != null && Object.hasOwnProperty.call(message, \"responseName\")) writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).string(message.responseName);\n      if (message.index != null && Object.hasOwnProperty.call(message, \"index\")) writer.uint32(\n      /* id 2, wireType 0 =*/\n      16).uint32(message.index);\n      if (message.type != null && Object.hasOwnProperty.call(message, \"type\")) writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).string(message.type);\n      if (message.cachePolicy != null && Object.hasOwnProperty.call(message, \"cachePolicy\")) $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(\n      /* id 5, wireType 2 =*/\n      42).fork()).ldelim();\n      if (message.startTime != null && Object.hasOwnProperty.call(message, \"startTime\")) writer.uint32(\n      /* id 8, wireType 0 =*/\n      64).uint64(message.startTime);\n      if (message.endTime != null && Object.hasOwnProperty.call(message, \"endTime\")) writer.uint32(\n      /* id 9, wireType 0 =*/\n      72).uint64(message.endTime);\n      if (message.error != null && message.error.length) for (var i = 0; i < message.error.length; ++i) $root.Trace.Error.encode(message.error[i], writer.uint32(\n      /* id 11, wireType 2 =*/\n      90).fork()).ldelim();\n      if (message.child != null && message.child.length) for (var i = 0; i < message.child.length; ++i) $root.Trace.Node.encode(message.child[i], writer.uint32(\n      /* id 12, wireType 2 =*/\n      98).fork()).ldelim();\n      if (message.parentType != null && Object.hasOwnProperty.call(message, \"parentType\")) writer.uint32(\n      /* id 13, wireType 2 =*/\n      106).string(message.parentType);\n      if (message.originalFieldName != null && Object.hasOwnProperty.call(message, \"originalFieldName\")) writer.uint32(\n      /* id 14, wireType 2 =*/\n      114).string(message.originalFieldName);\n      return writer;\n    };\n    /**\n     * Encodes the specified Node message, length delimited. Does not implicitly {@link Trace.Node.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Trace.Node\n     * @static\n     * @param {Trace.INode} message Node message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    Node.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a Node message from the specified reader or buffer.\n     * @function decode\n     * @memberof Trace.Node\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Trace.Node} Node\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Node.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Trace.Node();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.responseName = reader.string();\n            break;\n\n          case 2:\n            message.index = reader.uint32();\n            break;\n\n          case 14:\n            message.originalFieldName = reader.string();\n            break;\n\n          case 3:\n            message.type = reader.string();\n            break;\n\n          case 13:\n            message.parentType = reader.string();\n            break;\n\n          case 5:\n            message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());\n            break;\n\n          case 8:\n            message.startTime = reader.uint64();\n            break;\n\n          case 9:\n            message.endTime = reader.uint64();\n            break;\n\n          case 11:\n            if (!(message.error && message.error.length)) message.error = [];\n            message.error.push($root.Trace.Error.decode(reader, reader.uint32()));\n            break;\n\n          case 12:\n            if (!(message.child && message.child.length)) message.child = [];\n            message.child.push($root.Trace.Node.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a Node message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Trace.Node\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Trace.Node} Node\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    Node.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a Node message.\n     * @function verify\n     * @memberof Trace.Node\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    Node.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      var properties = {};\n\n      if (message.responseName != null && message.hasOwnProperty(\"responseName\")) {\n        properties.id = 1;\n        if (!$util.isString(message.responseName)) return \"responseName: string expected\";\n      }\n\n      if (message.index != null && message.hasOwnProperty(\"index\")) {\n        if (properties.id === 1) return \"id: multiple values\";\n        properties.id = 1;\n        if (!$util.isInteger(message.index)) return \"index: integer expected\";\n      }\n\n      if (message.originalFieldName != null && message.hasOwnProperty(\"originalFieldName\")) if (!$util.isString(message.originalFieldName)) return \"originalFieldName: string expected\";\n      if (message.type != null && message.hasOwnProperty(\"type\")) if (!$util.isString(message.type)) return \"type: string expected\";\n      if (message.parentType != null && message.hasOwnProperty(\"parentType\")) if (!$util.isString(message.parentType)) return \"parentType: string expected\";\n\n      if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\")) {\n        var error = $root.Trace.CachePolicy.verify(message.cachePolicy);\n        if (error) return \"cachePolicy.\" + error;\n      }\n\n      if (message.startTime != null && message.hasOwnProperty(\"startTime\")) if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high))) return \"startTime: integer|Long expected\";\n      if (message.endTime != null && message.hasOwnProperty(\"endTime\")) if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high))) return \"endTime: integer|Long expected\";\n\n      if (message.error != null && message.hasOwnProperty(\"error\")) {\n        if (!Array.isArray(message.error)) return \"error: array expected\";\n\n        for (var i = 0; i < message.error.length; ++i) {\n          var error = $root.Trace.Error.verify(message.error[i]);\n          if (error) return \"error.\" + error;\n        }\n      }\n\n      if (message.child != null && message.hasOwnProperty(\"child\")) {\n        if (!Array.isArray(message.child)) return \"child: array expected\";\n\n        for (var i = 0; i < message.child.length; ++i) {\n          var error = $root.Trace.Node.verify(message.child[i]);\n          if (error) return \"child.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a plain object from a Node message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Trace.Node\n     * @static\n     * @param {Trace.Node} message Node\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    Node.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (options.arrays || options.defaults) {\n        object.error = [];\n        object.child = [];\n      }\n\n      if (options.defaults) {\n        object.type = \"\";\n        object.cachePolicy = null;\n\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, true);\n          object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.startTime = options.longs === String ? \"0\" : 0;\n\n        if ($util.Long) {\n          var long = new $util.Long(0, 0, true);\n          object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n        } else object.endTime = options.longs === String ? \"0\" : 0;\n\n        object.parentType = \"\";\n        object.originalFieldName = \"\";\n      }\n\n      if (message.responseName != null && message.hasOwnProperty(\"responseName\")) {\n        object.responseName = message.responseName;\n        if (options.oneofs) object.id = \"responseName\";\n      }\n\n      if (message.index != null && message.hasOwnProperty(\"index\")) {\n        object.index = message.index;\n        if (options.oneofs) object.id = \"index\";\n      }\n\n      if (message.type != null && message.hasOwnProperty(\"type\")) object.type = message.type;\n      if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\")) object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);\n      if (message.startTime != null && message.hasOwnProperty(\"startTime\")) if (typeof message.startTime === \"number\") object.startTime = options.longs === String ? String(message.startTime) : message.startTime;else object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;\n      if (message.endTime != null && message.hasOwnProperty(\"endTime\")) if (typeof message.endTime === \"number\") object.endTime = options.longs === String ? String(message.endTime) : message.endTime;else object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;\n\n      if (message.error && message.error.length) {\n        object.error = [];\n\n        for (var j = 0; j < message.error.length; ++j) object.error[j] = $root.Trace.Error.toObject(message.error[j], options);\n      }\n\n      if (message.child && message.child.length) {\n        object.child = [];\n\n        for (var j = 0; j < message.child.length; ++j) object.child[j] = $root.Trace.Node.toObject(message.child[j], options);\n      }\n\n      if (message.parentType != null && message.hasOwnProperty(\"parentType\")) object.parentType = message.parentType;\n      if (message.originalFieldName != null && message.hasOwnProperty(\"originalFieldName\")) object.originalFieldName = message.originalFieldName;\n      return object;\n    };\n    /**\n     * Converts this Node to JSON.\n     * @function toJSON\n     * @memberof Trace.Node\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    Node.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Node;\n  }();\n\n  Trace.QueryPlanNode = function () {\n    /**\n     * Properties of a QueryPlanNode.\n     * @memberof Trace\n     * @interface IQueryPlanNode\n     * @property {Trace.QueryPlanNode.ISequenceNode|null} [sequence] QueryPlanNode sequence\n     * @property {Trace.QueryPlanNode.IParallelNode|null} [parallel] QueryPlanNode parallel\n     * @property {Trace.QueryPlanNode.IFetchNode|null} [fetch] QueryPlanNode fetch\n     * @property {Trace.QueryPlanNode.IFlattenNode|null} [flatten] QueryPlanNode flatten\n     */\n\n    /**\n     * Constructs a new QueryPlanNode.\n     * @memberof Trace\n     * @classdesc Represents a QueryPlanNode.\n     * @implements IQueryPlanNode\n     * @constructor\n     * @param {Trace.IQueryPlanNode=} [properties] Properties to set\n     */\n    function QueryPlanNode(properties) {\n      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * QueryPlanNode sequence.\n     * @member {Trace.QueryPlanNode.ISequenceNode|null|undefined} sequence\n     * @memberof Trace.QueryPlanNode\n     * @instance\n     */\n\n\n    QueryPlanNode.prototype.sequence = null;\n    /**\n     * QueryPlanNode parallel.\n     * @member {Trace.QueryPlanNode.IParallelNode|null|undefined} parallel\n     * @memberof Trace.QueryPlanNode\n     * @instance\n     */\n\n    QueryPlanNode.prototype.parallel = null;\n    /**\n     * QueryPlanNode fetch.\n     * @member {Trace.QueryPlanNode.IFetchNode|null|undefined} fetch\n     * @memberof Trace.QueryPlanNode\n     * @instance\n     */\n\n    QueryPlanNode.prototype.fetch = null;\n    /**\n     * QueryPlanNode flatten.\n     * @member {Trace.QueryPlanNode.IFlattenNode|null|undefined} flatten\n     * @memberof Trace.QueryPlanNode\n     * @instance\n     */\n\n    QueryPlanNode.prototype.flatten = null; // OneOf field names bound to virtual getters and setters\n\n    var $oneOfFields;\n    /**\n     * QueryPlanNode node.\n     * @member {\"sequence\"|\"parallel\"|\"fetch\"|\"flatten\"|undefined} node\n     * @memberof Trace.QueryPlanNode\n     * @instance\n     */\n\n    Object.defineProperty(QueryPlanNode.prototype, \"node\", {\n      get: $util.oneOfGetter($oneOfFields = [\"sequence\", \"parallel\", \"fetch\", \"flatten\"]),\n      set: $util.oneOfSetter($oneOfFields)\n    });\n    /**\n     * Creates a new QueryPlanNode instance using the specified properties.\n     * @function create\n     * @memberof Trace.QueryPlanNode\n     * @static\n     * @param {Trace.IQueryPlanNode=} [properties] Properties to set\n     * @returns {Trace.QueryPlanNode} QueryPlanNode instance\n     */\n\n    QueryPlanNode.create = function create(properties) {\n      return new QueryPlanNode(properties);\n    };\n    /**\n     * Encodes the specified QueryPlanNode message. Does not implicitly {@link Trace.QueryPlanNode.verify|verify} messages.\n     * @function encode\n     * @memberof Trace.QueryPlanNode\n     * @static\n     * @param {Trace.IQueryPlanNode} message QueryPlanNode message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    QueryPlanNode.encode = function encode(message, writer) {\n      if (!writer) writer = $Writer.create();\n      if (message.sequence != null && Object.hasOwnProperty.call(message, \"sequence\")) $root.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork()).ldelim();\n      if (message.parallel != null && Object.hasOwnProperty.call(message, \"parallel\")) $root.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim();\n      if (message.fetch != null && Object.hasOwnProperty.call(message, \"fetch\")) $root.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork()).ldelim();\n      if (message.flatten != null && Object.hasOwnProperty.call(message, \"flatten\")) $root.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(\n      /* id 4, wireType 2 =*/\n      34).fork()).ldelim();\n      return writer;\n    };\n    /**\n     * Encodes the specified QueryPlanNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Trace.QueryPlanNode\n     * @static\n     * @param {Trace.IQueryPlanNode} message QueryPlanNode message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n\n\n    QueryPlanNode.encodeDelimited = function encodeDelimited(message, writer) {\n      return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a QueryPlanNode message from the specified reader or buffer.\n     * @function decode\n     * @memberof Trace.QueryPlanNode\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Trace.QueryPlanNode} QueryPlanNode\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    QueryPlanNode.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Trace.QueryPlanNode();\n\n      while (reader.pos < end) {\n        var tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());\n            break;\n\n          case 3:\n            message.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());\n            break;\n\n          case 4:\n            message.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n    /**\n     * Decodes a QueryPlanNode message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Trace.QueryPlanNode\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Trace.QueryPlanNode} QueryPlanNode\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n\n    QueryPlanNode.decodeDelimited = function decodeDelimited(reader) {\n      if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n      return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a QueryPlanNode message.\n     * @function verify\n     * @memberof Trace.QueryPlanNode\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n\n\n    QueryPlanNode.verify = function verify(message) {\n      if (typeof message !== \"object\" || message === null) return \"object expected\";\n      var properties = {};\n\n      if (message.sequence != null && message.hasOwnProperty(\"sequence\")) {\n        properties.node = 1;\n        {\n          var error = $root.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);\n          if (error) return \"sequence.\" + error;\n        }\n      }\n\n      if (message.parallel != null && message.hasOwnProperty(\"parallel\")) {\n        if (properties.node === 1) return \"node: multiple values\";\n        properties.node = 1;\n        {\n          var error = $root.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);\n          if (error) return \"parallel.\" + error;\n        }\n      }\n\n      if (message.fetch != null && message.hasOwnProperty(\"fetch\")) {\n        if (properties.node === 1) return \"node: multiple values\";\n        properties.node = 1;\n        {\n          var error = $root.Trace.QueryPlanNode.FetchNode.verify(message.fetch);\n          if (error) return \"fetch.\" + error;\n        }\n      }\n\n      if (message.flatten != null && message.hasOwnProperty(\"flatten\")) {\n        if (properties.node === 1) return \"node: multiple values\";\n        properties.node = 1;\n        {\n          var error = $root.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);\n          if (error) return \"flatten.\" + error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Creates a plain object from a QueryPlanNode message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Trace.QueryPlanNode\n     * @static\n     * @param {Trace.QueryPlanNode} message QueryPlanNode\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n\n\n    QueryPlanNode.toObject = function toObject(message, options) {\n      if (!options) options = {};\n      var object = {};\n\n      if (message.sequence != null && message.hasOwnProperty(\"sequence\")) {\n        object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);\n        if (options.oneofs) object.node = \"sequence\";\n      }\n\n      if (message.parallel != null && message.hasOwnProperty(\"parallel\")) {\n        object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);\n        if (options.oneofs) object.node = \"parallel\";\n      }\n\n      if (message.fetch != null && message.hasOwnProperty(\"fetch\")) {\n        object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);\n        if (options.oneofs) object.node = \"fetch\";\n      }\n\n      if (message.flatten != null && message.hasOwnProperty(\"flatten\")) {\n        object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);\n        if (options.oneofs) object.node = \"flatten\";\n      }\n\n      return object;\n    };\n    /**\n     * Converts this QueryPlanNode to JSON.\n     * @function toJSON\n     * @memberof Trace.QueryPlanNode\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n\n\n    QueryPlanNode.prototype.toJSON = function toJSON() {\n      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    QueryPlanNode.SequenceNode = function () {\n      /**\n       * Properties of a SequenceNode.\n       * @memberof Trace.QueryPlanNode\n       * @interface ISequenceNode\n       * @property {Array.<Trace.IQueryPlanNode>|null} [nodes] SequenceNode nodes\n       */\n\n      /**\n       * Constructs a new SequenceNode.\n       * @memberof Trace.QueryPlanNode\n       * @classdesc Represents a SequenceNode.\n       * @implements ISequenceNode\n       * @constructor\n       * @param {Trace.QueryPlanNode.ISequenceNode=} [properties] Properties to set\n       */\n      function SequenceNode(properties) {\n        this.nodes = [];\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * SequenceNode nodes.\n       * @member {Array.<Trace.IQueryPlanNode>} nodes\n       * @memberof Trace.QueryPlanNode.SequenceNode\n       * @instance\n       */\n\n\n      SequenceNode.prototype.nodes = $util.emptyArray;\n      /**\n       * Creates a new SequenceNode instance using the specified properties.\n       * @function create\n       * @memberof Trace.QueryPlanNode.SequenceNode\n       * @static\n       * @param {Trace.QueryPlanNode.ISequenceNode=} [properties] Properties to set\n       * @returns {Trace.QueryPlanNode.SequenceNode} SequenceNode instance\n       */\n\n      SequenceNode.create = function create(properties) {\n        return new SequenceNode(properties);\n      };\n      /**\n       * Encodes the specified SequenceNode message. Does not implicitly {@link Trace.QueryPlanNode.SequenceNode.verify|verify} messages.\n       * @function encode\n       * @memberof Trace.QueryPlanNode.SequenceNode\n       * @static\n       * @param {Trace.QueryPlanNode.ISequenceNode} message SequenceNode message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      SequenceNode.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.nodes != null && message.nodes.length) for (var i = 0; i < message.nodes.length; ++i) $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).fork()).ldelim();\n        return writer;\n      };\n      /**\n       * Encodes the specified SequenceNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.SequenceNode.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof Trace.QueryPlanNode.SequenceNode\n       * @static\n       * @param {Trace.QueryPlanNode.ISequenceNode} message SequenceNode message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      SequenceNode.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a SequenceNode message from the specified reader or buffer.\n       * @function decode\n       * @memberof Trace.QueryPlanNode.SequenceNode\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {Trace.QueryPlanNode.SequenceNode} SequenceNode\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      SequenceNode.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.Trace.QueryPlanNode.SequenceNode();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              if (!(message.nodes && message.nodes.length)) message.nodes = [];\n              message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a SequenceNode message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof Trace.QueryPlanNode.SequenceNode\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {Trace.QueryPlanNode.SequenceNode} SequenceNode\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      SequenceNode.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a SequenceNode message.\n       * @function verify\n       * @memberof Trace.QueryPlanNode.SequenceNode\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      SequenceNode.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n        if (message.nodes != null && message.hasOwnProperty(\"nodes\")) {\n          if (!Array.isArray(message.nodes)) return \"nodes: array expected\";\n\n          for (var i = 0; i < message.nodes.length; ++i) {\n            var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);\n            if (error) return \"nodes.\" + error;\n          }\n        }\n\n        return null;\n      };\n      /**\n       * Creates a plain object from a SequenceNode message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof Trace.QueryPlanNode.SequenceNode\n       * @static\n       * @param {Trace.QueryPlanNode.SequenceNode} message SequenceNode\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      SequenceNode.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.arrays || options.defaults) object.nodes = [];\n\n        if (message.nodes && message.nodes.length) {\n          object.nodes = [];\n\n          for (var j = 0; j < message.nodes.length; ++j) object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);\n        }\n\n        return object;\n      };\n      /**\n       * Converts this SequenceNode to JSON.\n       * @function toJSON\n       * @memberof Trace.QueryPlanNode.SequenceNode\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      SequenceNode.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return SequenceNode;\n    }();\n\n    QueryPlanNode.ParallelNode = function () {\n      /**\n       * Properties of a ParallelNode.\n       * @memberof Trace.QueryPlanNode\n       * @interface IParallelNode\n       * @property {Array.<Trace.IQueryPlanNode>|null} [nodes] ParallelNode nodes\n       */\n\n      /**\n       * Constructs a new ParallelNode.\n       * @memberof Trace.QueryPlanNode\n       * @classdesc Represents a ParallelNode.\n       * @implements IParallelNode\n       * @constructor\n       * @param {Trace.QueryPlanNode.IParallelNode=} [properties] Properties to set\n       */\n      function ParallelNode(properties) {\n        this.nodes = [];\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * ParallelNode nodes.\n       * @member {Array.<Trace.IQueryPlanNode>} nodes\n       * @memberof Trace.QueryPlanNode.ParallelNode\n       * @instance\n       */\n\n\n      ParallelNode.prototype.nodes = $util.emptyArray;\n      /**\n       * Creates a new ParallelNode instance using the specified properties.\n       * @function create\n       * @memberof Trace.QueryPlanNode.ParallelNode\n       * @static\n       * @param {Trace.QueryPlanNode.IParallelNode=} [properties] Properties to set\n       * @returns {Trace.QueryPlanNode.ParallelNode} ParallelNode instance\n       */\n\n      ParallelNode.create = function create(properties) {\n        return new ParallelNode(properties);\n      };\n      /**\n       * Encodes the specified ParallelNode message. Does not implicitly {@link Trace.QueryPlanNode.ParallelNode.verify|verify} messages.\n       * @function encode\n       * @memberof Trace.QueryPlanNode.ParallelNode\n       * @static\n       * @param {Trace.QueryPlanNode.IParallelNode} message ParallelNode message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ParallelNode.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.nodes != null && message.nodes.length) for (var i = 0; i < message.nodes.length; ++i) $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).fork()).ldelim();\n        return writer;\n      };\n      /**\n       * Encodes the specified ParallelNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.ParallelNode.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof Trace.QueryPlanNode.ParallelNode\n       * @static\n       * @param {Trace.QueryPlanNode.IParallelNode} message ParallelNode message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ParallelNode.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a ParallelNode message from the specified reader or buffer.\n       * @function decode\n       * @memberof Trace.QueryPlanNode.ParallelNode\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {Trace.QueryPlanNode.ParallelNode} ParallelNode\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ParallelNode.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.Trace.QueryPlanNode.ParallelNode();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              if (!(message.nodes && message.nodes.length)) message.nodes = [];\n              message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a ParallelNode message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof Trace.QueryPlanNode.ParallelNode\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {Trace.QueryPlanNode.ParallelNode} ParallelNode\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ParallelNode.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a ParallelNode message.\n       * @function verify\n       * @memberof Trace.QueryPlanNode.ParallelNode\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      ParallelNode.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n        if (message.nodes != null && message.hasOwnProperty(\"nodes\")) {\n          if (!Array.isArray(message.nodes)) return \"nodes: array expected\";\n\n          for (var i = 0; i < message.nodes.length; ++i) {\n            var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);\n            if (error) return \"nodes.\" + error;\n          }\n        }\n\n        return null;\n      };\n      /**\n       * Creates a plain object from a ParallelNode message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof Trace.QueryPlanNode.ParallelNode\n       * @static\n       * @param {Trace.QueryPlanNode.ParallelNode} message ParallelNode\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ParallelNode.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.arrays || options.defaults) object.nodes = [];\n\n        if (message.nodes && message.nodes.length) {\n          object.nodes = [];\n\n          for (var j = 0; j < message.nodes.length; ++j) object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);\n        }\n\n        return object;\n      };\n      /**\n       * Converts this ParallelNode to JSON.\n       * @function toJSON\n       * @memberof Trace.QueryPlanNode.ParallelNode\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ParallelNode.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return ParallelNode;\n    }();\n\n    QueryPlanNode.FetchNode = function () {\n      /**\n       * Properties of a FetchNode.\n       * @memberof Trace.QueryPlanNode\n       * @interface IFetchNode\n       * @property {string|null} [serviceName] FetchNode serviceName\n       * @property {boolean|null} [traceParsingFailed] FetchNode traceParsingFailed\n       * @property {ITrace|null} [trace] FetchNode trace\n       * @property {number|null} [sentTimeOffset] FetchNode sentTimeOffset\n       * @property {google.protobuf.ITimestamp|null} [sentTime] FetchNode sentTime\n       * @property {google.protobuf.ITimestamp|null} [receivedTime] FetchNode receivedTime\n       */\n\n      /**\n       * Constructs a new FetchNode.\n       * @memberof Trace.QueryPlanNode\n       * @classdesc Represents a FetchNode.\n       * @implements IFetchNode\n       * @constructor\n       * @param {Trace.QueryPlanNode.IFetchNode=} [properties] Properties to set\n       */\n      function FetchNode(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * FetchNode serviceName.\n       * @member {string} serviceName\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @instance\n       */\n\n\n      FetchNode.prototype.serviceName = \"\";\n      /**\n       * FetchNode traceParsingFailed.\n       * @member {boolean} traceParsingFailed\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @instance\n       */\n\n      FetchNode.prototype.traceParsingFailed = false;\n      /**\n       * FetchNode trace.\n       * @member {ITrace|null|undefined} trace\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @instance\n       */\n\n      FetchNode.prototype.trace = null;\n      /**\n       * FetchNode sentTimeOffset.\n       * @member {number} sentTimeOffset\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @instance\n       */\n\n      FetchNode.prototype.sentTimeOffset = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n      /**\n       * FetchNode sentTime.\n       * @member {google.protobuf.ITimestamp|null|undefined} sentTime\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @instance\n       */\n\n      FetchNode.prototype.sentTime = null;\n      /**\n       * FetchNode receivedTime.\n       * @member {google.protobuf.ITimestamp|null|undefined} receivedTime\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @instance\n       */\n\n      FetchNode.prototype.receivedTime = null;\n      /**\n       * Creates a new FetchNode instance using the specified properties.\n       * @function create\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @static\n       * @param {Trace.QueryPlanNode.IFetchNode=} [properties] Properties to set\n       * @returns {Trace.QueryPlanNode.FetchNode} FetchNode instance\n       */\n\n      FetchNode.create = function create(properties) {\n        return new FetchNode(properties);\n      };\n      /**\n       * Encodes the specified FetchNode message. Does not implicitly {@link Trace.QueryPlanNode.FetchNode.verify|verify} messages.\n       * @function encode\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @static\n       * @param {Trace.QueryPlanNode.IFetchNode} message FetchNode message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      FetchNode.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.serviceName != null && Object.hasOwnProperty.call(message, \"serviceName\")) writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).string(message.serviceName);\n        if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, \"traceParsingFailed\")) writer.uint32(\n        /* id 2, wireType 0 =*/\n        16).bool(message.traceParsingFailed);\n        if (message.trace != null && Object.hasOwnProperty.call(message, \"trace\")) $root.Trace.encode(message.trace, writer.uint32(\n        /* id 3, wireType 2 =*/\n        26).fork()).ldelim();\n        if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, \"sentTimeOffset\")) writer.uint32(\n        /* id 4, wireType 0 =*/\n        32).uint64(message.sentTimeOffset);\n        if (message.sentTime != null && Object.hasOwnProperty.call(message, \"sentTime\")) $root.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(\n        /* id 5, wireType 2 =*/\n        42).fork()).ldelim();\n        if (message.receivedTime != null && Object.hasOwnProperty.call(message, \"receivedTime\")) $root.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(\n        /* id 6, wireType 2 =*/\n        50).fork()).ldelim();\n        return writer;\n      };\n      /**\n       * Encodes the specified FetchNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.FetchNode.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @static\n       * @param {Trace.QueryPlanNode.IFetchNode} message FetchNode message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      FetchNode.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a FetchNode message from the specified reader or buffer.\n       * @function decode\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {Trace.QueryPlanNode.FetchNode} FetchNode\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      FetchNode.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.Trace.QueryPlanNode.FetchNode();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.serviceName = reader.string();\n              break;\n\n            case 2:\n              message.traceParsingFailed = reader.bool();\n              break;\n\n            case 3:\n              message.trace = $root.Trace.decode(reader, reader.uint32());\n              break;\n\n            case 4:\n              message.sentTimeOffset = reader.uint64();\n              break;\n\n            case 5:\n              message.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n              break;\n\n            case 6:\n              message.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a FetchNode message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {Trace.QueryPlanNode.FetchNode} FetchNode\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      FetchNode.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a FetchNode message.\n       * @function verify\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      FetchNode.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n        if (message.serviceName != null && message.hasOwnProperty(\"serviceName\")) if (!$util.isString(message.serviceName)) return \"serviceName: string expected\";\n        if (message.traceParsingFailed != null && message.hasOwnProperty(\"traceParsingFailed\")) if (typeof message.traceParsingFailed !== \"boolean\") return \"traceParsingFailed: boolean expected\";\n\n        if (message.trace != null && message.hasOwnProperty(\"trace\")) {\n          var error = $root.Trace.verify(message.trace);\n          if (error) return \"trace.\" + error;\n        }\n\n        if (message.sentTimeOffset != null && message.hasOwnProperty(\"sentTimeOffset\")) if (!$util.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util.isInteger(message.sentTimeOffset.low) && $util.isInteger(message.sentTimeOffset.high))) return \"sentTimeOffset: integer|Long expected\";\n\n        if (message.sentTime != null && message.hasOwnProperty(\"sentTime\")) {\n          var error = $root.google.protobuf.Timestamp.verify(message.sentTime);\n          if (error) return \"sentTime.\" + error;\n        }\n\n        if (message.receivedTime != null && message.hasOwnProperty(\"receivedTime\")) {\n          var error = $root.google.protobuf.Timestamp.verify(message.receivedTime);\n          if (error) return \"receivedTime.\" + error;\n        }\n\n        return null;\n      };\n      /**\n       * Creates a plain object from a FetchNode message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @static\n       * @param {Trace.QueryPlanNode.FetchNode} message FetchNode\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      FetchNode.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n\n        if (options.defaults) {\n          object.serviceName = \"\";\n          object.traceParsingFailed = false;\n          object.trace = null;\n\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, true);\n            object.sentTimeOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n          } else object.sentTimeOffset = options.longs === String ? \"0\" : 0;\n\n          object.sentTime = null;\n          object.receivedTime = null;\n        }\n\n        if (message.serviceName != null && message.hasOwnProperty(\"serviceName\")) object.serviceName = message.serviceName;\n        if (message.traceParsingFailed != null && message.hasOwnProperty(\"traceParsingFailed\")) object.traceParsingFailed = message.traceParsingFailed;\n        if (message.trace != null && message.hasOwnProperty(\"trace\")) object.trace = $root.Trace.toObject(message.trace, options);\n        if (message.sentTimeOffset != null && message.hasOwnProperty(\"sentTimeOffset\")) if (typeof message.sentTimeOffset === \"number\") object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;else object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;\n        if (message.sentTime != null && message.hasOwnProperty(\"sentTime\")) object.sentTime = $root.google.protobuf.Timestamp.toObject(message.sentTime, options);\n        if (message.receivedTime != null && message.hasOwnProperty(\"receivedTime\")) object.receivedTime = $root.google.protobuf.Timestamp.toObject(message.receivedTime, options);\n        return object;\n      };\n      /**\n       * Converts this FetchNode to JSON.\n       * @function toJSON\n       * @memberof Trace.QueryPlanNode.FetchNode\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      FetchNode.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return FetchNode;\n    }();\n\n    QueryPlanNode.FlattenNode = function () {\n      /**\n       * Properties of a FlattenNode.\n       * @memberof Trace.QueryPlanNode\n       * @interface IFlattenNode\n       * @property {Array.<Trace.QueryPlanNode.IResponsePathElement>|null} [responsePath] FlattenNode responsePath\n       * @property {Trace.IQueryPlanNode|null} [node] FlattenNode node\n       */\n\n      /**\n       * Constructs a new FlattenNode.\n       * @memberof Trace.QueryPlanNode\n       * @classdesc Represents a FlattenNode.\n       * @implements IFlattenNode\n       * @constructor\n       * @param {Trace.QueryPlanNode.IFlattenNode=} [properties] Properties to set\n       */\n      function FlattenNode(properties) {\n        this.responsePath = [];\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * FlattenNode responsePath.\n       * @member {Array.<Trace.QueryPlanNode.IResponsePathElement>} responsePath\n       * @memberof Trace.QueryPlanNode.FlattenNode\n       * @instance\n       */\n\n\n      FlattenNode.prototype.responsePath = $util.emptyArray;\n      /**\n       * FlattenNode node.\n       * @member {Trace.IQueryPlanNode|null|undefined} node\n       * @memberof Trace.QueryPlanNode.FlattenNode\n       * @instance\n       */\n\n      FlattenNode.prototype.node = null;\n      /**\n       * Creates a new FlattenNode instance using the specified properties.\n       * @function create\n       * @memberof Trace.QueryPlanNode.FlattenNode\n       * @static\n       * @param {Trace.QueryPlanNode.IFlattenNode=} [properties] Properties to set\n       * @returns {Trace.QueryPlanNode.FlattenNode} FlattenNode instance\n       */\n\n      FlattenNode.create = function create(properties) {\n        return new FlattenNode(properties);\n      };\n      /**\n       * Encodes the specified FlattenNode message. Does not implicitly {@link Trace.QueryPlanNode.FlattenNode.verify|verify} messages.\n       * @function encode\n       * @memberof Trace.QueryPlanNode.FlattenNode\n       * @static\n       * @param {Trace.QueryPlanNode.IFlattenNode} message FlattenNode message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      FlattenNode.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.responsePath != null && message.responsePath.length) for (var i = 0; i < message.responsePath.length; ++i) $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).fork()).ldelim();\n        if (message.node != null && Object.hasOwnProperty.call(message, \"node\")) $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(\n        /* id 2, wireType 2 =*/\n        18).fork()).ldelim();\n        return writer;\n      };\n      /**\n       * Encodes the specified FlattenNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.FlattenNode.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof Trace.QueryPlanNode.FlattenNode\n       * @static\n       * @param {Trace.QueryPlanNode.IFlattenNode} message FlattenNode message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      FlattenNode.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a FlattenNode message from the specified reader or buffer.\n       * @function decode\n       * @memberof Trace.QueryPlanNode.FlattenNode\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {Trace.QueryPlanNode.FlattenNode} FlattenNode\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      FlattenNode.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.Trace.QueryPlanNode.FlattenNode();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              if (!(message.responsePath && message.responsePath.length)) message.responsePath = [];\n              message.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));\n              break;\n\n            case 2:\n              message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a FlattenNode message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof Trace.QueryPlanNode.FlattenNode\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {Trace.QueryPlanNode.FlattenNode} FlattenNode\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      FlattenNode.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a FlattenNode message.\n       * @function verify\n       * @memberof Trace.QueryPlanNode.FlattenNode\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      FlattenNode.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n        if (message.responsePath != null && message.hasOwnProperty(\"responsePath\")) {\n          if (!Array.isArray(message.responsePath)) return \"responsePath: array expected\";\n\n          for (var i = 0; i < message.responsePath.length; ++i) {\n            var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);\n            if (error) return \"responsePath.\" + error;\n          }\n        }\n\n        if (message.node != null && message.hasOwnProperty(\"node\")) {\n          var error = $root.Trace.QueryPlanNode.verify(message.node);\n          if (error) return \"node.\" + error;\n        }\n\n        return null;\n      };\n      /**\n       * Creates a plain object from a FlattenNode message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof Trace.QueryPlanNode.FlattenNode\n       * @static\n       * @param {Trace.QueryPlanNode.FlattenNode} message FlattenNode\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      FlattenNode.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n        if (options.arrays || options.defaults) object.responsePath = [];\n        if (options.defaults) object.node = null;\n\n        if (message.responsePath && message.responsePath.length) {\n          object.responsePath = [];\n\n          for (var j = 0; j < message.responsePath.length; ++j) object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);\n        }\n\n        if (message.node != null && message.hasOwnProperty(\"node\")) object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);\n        return object;\n      };\n      /**\n       * Converts this FlattenNode to JSON.\n       * @function toJSON\n       * @memberof Trace.QueryPlanNode.FlattenNode\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      FlattenNode.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return FlattenNode;\n    }();\n\n    QueryPlanNode.ResponsePathElement = function () {\n      /**\n       * Properties of a ResponsePathElement.\n       * @memberof Trace.QueryPlanNode\n       * @interface IResponsePathElement\n       * @property {string|null} [fieldName] ResponsePathElement fieldName\n       * @property {number|null} [index] ResponsePathElement index\n       */\n\n      /**\n       * Constructs a new ResponsePathElement.\n       * @memberof Trace.QueryPlanNode\n       * @classdesc Represents a ResponsePathElement.\n       * @implements IResponsePathElement\n       * @constructor\n       * @param {Trace.QueryPlanNode.IResponsePathElement=} [properties] Properties to set\n       */\n      function ResponsePathElement(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * ResponsePathElement fieldName.\n       * @member {string} fieldName\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @instance\n       */\n\n\n      ResponsePathElement.prototype.fieldName = \"\";\n      /**\n       * ResponsePathElement index.\n       * @member {number} index\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @instance\n       */\n\n      ResponsePathElement.prototype.index = 0; // OneOf field names bound to virtual getters and setters\n\n      var $oneOfFields;\n      /**\n       * ResponsePathElement id.\n       * @member {\"fieldName\"|\"index\"|undefined} id\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @instance\n       */\n\n      Object.defineProperty(ResponsePathElement.prototype, \"id\", {\n        get: $util.oneOfGetter($oneOfFields = [\"fieldName\", \"index\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n      /**\n       * Creates a new ResponsePathElement instance using the specified properties.\n       * @function create\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @static\n       * @param {Trace.QueryPlanNode.IResponsePathElement=} [properties] Properties to set\n       * @returns {Trace.QueryPlanNode.ResponsePathElement} ResponsePathElement instance\n       */\n\n      ResponsePathElement.create = function create(properties) {\n        return new ResponsePathElement(properties);\n      };\n      /**\n       * Encodes the specified ResponsePathElement message. Does not implicitly {@link Trace.QueryPlanNode.ResponsePathElement.verify|verify} messages.\n       * @function encode\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @static\n       * @param {Trace.QueryPlanNode.IResponsePathElement} message ResponsePathElement message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ResponsePathElement.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.fieldName != null && Object.hasOwnProperty.call(message, \"fieldName\")) writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).string(message.fieldName);\n        if (message.index != null && Object.hasOwnProperty.call(message, \"index\")) writer.uint32(\n        /* id 2, wireType 0 =*/\n        16).uint32(message.index);\n        return writer;\n      };\n      /**\n       * Encodes the specified ResponsePathElement message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.ResponsePathElement.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @static\n       * @param {Trace.QueryPlanNode.IResponsePathElement} message ResponsePathElement message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      ResponsePathElement.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a ResponsePathElement message from the specified reader or buffer.\n       * @function decode\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {Trace.QueryPlanNode.ResponsePathElement} ResponsePathElement\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ResponsePathElement.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.Trace.QueryPlanNode.ResponsePathElement();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.fieldName = reader.string();\n              break;\n\n            case 2:\n              message.index = reader.uint32();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a ResponsePathElement message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {Trace.QueryPlanNode.ResponsePathElement} ResponsePathElement\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      ResponsePathElement.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a ResponsePathElement message.\n       * @function verify\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      ResponsePathElement.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n        var properties = {};\n\n        if (message.fieldName != null && message.hasOwnProperty(\"fieldName\")) {\n          properties.id = 1;\n          if (!$util.isString(message.fieldName)) return \"fieldName: string expected\";\n        }\n\n        if (message.index != null && message.hasOwnProperty(\"index\")) {\n          if (properties.id === 1) return \"id: multiple values\";\n          properties.id = 1;\n          if (!$util.isInteger(message.index)) return \"index: integer expected\";\n        }\n\n        return null;\n      };\n      /**\n       * Creates a plain object from a ResponsePathElement message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @static\n       * @param {Trace.QueryPlanNode.ResponsePathElement} message ResponsePathElement\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      ResponsePathElement.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n\n        if (message.fieldName != null && message.hasOwnProperty(\"fieldName\")) {\n          object.fieldName = message.fieldName;\n          if (options.oneofs) object.id = \"fieldName\";\n        }\n\n        if (message.index != null && message.hasOwnProperty(\"index\")) {\n          object.index = message.index;\n          if (options.oneofs) object.id = \"index\";\n        }\n\n        return object;\n      };\n      /**\n       * Converts this ResponsePathElement to JSON.\n       * @function toJSON\n       * @memberof Trace.QueryPlanNode.ResponsePathElement\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      ResponsePathElement.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return ResponsePathElement;\n    }();\n\n    return QueryPlanNode;\n  }();\n\n  return Trace;\n}();\n\n$root.ReportHeader = function () {\n  /**\n   * Properties of a ReportHeader.\n   * @exports IReportHeader\n   * @interface IReportHeader\n   * @property {string|null} [graphRef] ReportHeader graphRef\n   * @property {string|null} [hostname] ReportHeader hostname\n   * @property {string|null} [agentVersion] ReportHeader agentVersion\n   * @property {string|null} [serviceVersion] ReportHeader serviceVersion\n   * @property {string|null} [runtimeVersion] ReportHeader runtimeVersion\n   * @property {string|null} [uname] ReportHeader uname\n   * @property {string|null} [executableSchemaId] ReportHeader executableSchemaId\n   */\n\n  /**\n   * Constructs a new ReportHeader.\n   * @exports ReportHeader\n   * @classdesc Represents a ReportHeader.\n   * @implements IReportHeader\n   * @constructor\n   * @param {IReportHeader=} [properties] Properties to set\n   */\n  function ReportHeader(properties) {\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * ReportHeader graphRef.\n   * @member {string} graphRef\n   * @memberof ReportHeader\n   * @instance\n   */\n\n\n  ReportHeader.prototype.graphRef = \"\";\n  /**\n   * ReportHeader hostname.\n   * @member {string} hostname\n   * @memberof ReportHeader\n   * @instance\n   */\n\n  ReportHeader.prototype.hostname = \"\";\n  /**\n   * ReportHeader agentVersion.\n   * @member {string} agentVersion\n   * @memberof ReportHeader\n   * @instance\n   */\n\n  ReportHeader.prototype.agentVersion = \"\";\n  /**\n   * ReportHeader serviceVersion.\n   * @member {string} serviceVersion\n   * @memberof ReportHeader\n   * @instance\n   */\n\n  ReportHeader.prototype.serviceVersion = \"\";\n  /**\n   * ReportHeader runtimeVersion.\n   * @member {string} runtimeVersion\n   * @memberof ReportHeader\n   * @instance\n   */\n\n  ReportHeader.prototype.runtimeVersion = \"\";\n  /**\n   * ReportHeader uname.\n   * @member {string} uname\n   * @memberof ReportHeader\n   * @instance\n   */\n\n  ReportHeader.prototype.uname = \"\";\n  /**\n   * ReportHeader executableSchemaId.\n   * @member {string} executableSchemaId\n   * @memberof ReportHeader\n   * @instance\n   */\n\n  ReportHeader.prototype.executableSchemaId = \"\";\n  /**\n   * Creates a new ReportHeader instance using the specified properties.\n   * @function create\n   * @memberof ReportHeader\n   * @static\n   * @param {IReportHeader=} [properties] Properties to set\n   * @returns {ReportHeader} ReportHeader instance\n   */\n\n  ReportHeader.create = function create(properties) {\n    return new ReportHeader(properties);\n  };\n  /**\n   * Encodes the specified ReportHeader message. Does not implicitly {@link ReportHeader.verify|verify} messages.\n   * @function encode\n   * @memberof ReportHeader\n   * @static\n   * @param {IReportHeader} message ReportHeader message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  ReportHeader.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.hostname != null && Object.hasOwnProperty.call(message, \"hostname\")) writer.uint32(\n    /* id 5, wireType 2 =*/\n    42).string(message.hostname);\n    if (message.agentVersion != null && Object.hasOwnProperty.call(message, \"agentVersion\")) writer.uint32(\n    /* id 6, wireType 2 =*/\n    50).string(message.agentVersion);\n    if (message.serviceVersion != null && Object.hasOwnProperty.call(message, \"serviceVersion\")) writer.uint32(\n    /* id 7, wireType 2 =*/\n    58).string(message.serviceVersion);\n    if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, \"runtimeVersion\")) writer.uint32(\n    /* id 8, wireType 2 =*/\n    66).string(message.runtimeVersion);\n    if (message.uname != null && Object.hasOwnProperty.call(message, \"uname\")) writer.uint32(\n    /* id 9, wireType 2 =*/\n    74).string(message.uname);\n    if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, \"executableSchemaId\")) writer.uint32(\n    /* id 11, wireType 2 =*/\n    90).string(message.executableSchemaId);\n    if (message.graphRef != null && Object.hasOwnProperty.call(message, \"graphRef\")) writer.uint32(\n    /* id 12, wireType 2 =*/\n    98).string(message.graphRef);\n    return writer;\n  };\n  /**\n   * Encodes the specified ReportHeader message, length delimited. Does not implicitly {@link ReportHeader.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof ReportHeader\n   * @static\n   * @param {IReportHeader} message ReportHeader message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  ReportHeader.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a ReportHeader message from the specified reader or buffer.\n   * @function decode\n   * @memberof ReportHeader\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {ReportHeader} ReportHeader\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  ReportHeader.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.ReportHeader();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 12:\n          message.graphRef = reader.string();\n          break;\n\n        case 5:\n          message.hostname = reader.string();\n          break;\n\n        case 6:\n          message.agentVersion = reader.string();\n          break;\n\n        case 7:\n          message.serviceVersion = reader.string();\n          break;\n\n        case 8:\n          message.runtimeVersion = reader.string();\n          break;\n\n        case 9:\n          message.uname = reader.string();\n          break;\n\n        case 11:\n          message.executableSchemaId = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a ReportHeader message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof ReportHeader\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {ReportHeader} ReportHeader\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  ReportHeader.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a ReportHeader message.\n   * @function verify\n   * @memberof ReportHeader\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  ReportHeader.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n    if (message.graphRef != null && message.hasOwnProperty(\"graphRef\")) if (!$util.isString(message.graphRef)) return \"graphRef: string expected\";\n    if (message.hostname != null && message.hasOwnProperty(\"hostname\")) if (!$util.isString(message.hostname)) return \"hostname: string expected\";\n    if (message.agentVersion != null && message.hasOwnProperty(\"agentVersion\")) if (!$util.isString(message.agentVersion)) return \"agentVersion: string expected\";\n    if (message.serviceVersion != null && message.hasOwnProperty(\"serviceVersion\")) if (!$util.isString(message.serviceVersion)) return \"serviceVersion: string expected\";\n    if (message.runtimeVersion != null && message.hasOwnProperty(\"runtimeVersion\")) if (!$util.isString(message.runtimeVersion)) return \"runtimeVersion: string expected\";\n    if (message.uname != null && message.hasOwnProperty(\"uname\")) if (!$util.isString(message.uname)) return \"uname: string expected\";\n    if (message.executableSchemaId != null && message.hasOwnProperty(\"executableSchemaId\")) if (!$util.isString(message.executableSchemaId)) return \"executableSchemaId: string expected\";\n    return null;\n  };\n  /**\n   * Creates a plain object from a ReportHeader message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof ReportHeader\n   * @static\n   * @param {ReportHeader} message ReportHeader\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  ReportHeader.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.defaults) {\n      object.hostname = \"\";\n      object.agentVersion = \"\";\n      object.serviceVersion = \"\";\n      object.runtimeVersion = \"\";\n      object.uname = \"\";\n      object.executableSchemaId = \"\";\n      object.graphRef = \"\";\n    }\n\n    if (message.hostname != null && message.hasOwnProperty(\"hostname\")) object.hostname = message.hostname;\n    if (message.agentVersion != null && message.hasOwnProperty(\"agentVersion\")) object.agentVersion = message.agentVersion;\n    if (message.serviceVersion != null && message.hasOwnProperty(\"serviceVersion\")) object.serviceVersion = message.serviceVersion;\n    if (message.runtimeVersion != null && message.hasOwnProperty(\"runtimeVersion\")) object.runtimeVersion = message.runtimeVersion;\n    if (message.uname != null && message.hasOwnProperty(\"uname\")) object.uname = message.uname;\n    if (message.executableSchemaId != null && message.hasOwnProperty(\"executableSchemaId\")) object.executableSchemaId = message.executableSchemaId;\n    if (message.graphRef != null && message.hasOwnProperty(\"graphRef\")) object.graphRef = message.graphRef;\n    return object;\n  };\n  /**\n   * Converts this ReportHeader to JSON.\n   * @function toJSON\n   * @memberof ReportHeader\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  ReportHeader.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return ReportHeader;\n}();\n\n$root.PathErrorStats = function () {\n  /**\n   * Properties of a PathErrorStats.\n   * @exports IPathErrorStats\n   * @interface IPathErrorStats\n   * @property {Object.<string,IPathErrorStats>|null} [children] PathErrorStats children\n   * @property {number|null} [errorsCount] PathErrorStats errorsCount\n   * @property {number|null} [requestsWithErrorsCount] PathErrorStats requestsWithErrorsCount\n   */\n\n  /**\n   * Constructs a new PathErrorStats.\n   * @exports PathErrorStats\n   * @classdesc Represents a PathErrorStats.\n   * @implements IPathErrorStats\n   * @constructor\n   * @param {IPathErrorStats=} [properties] Properties to set\n   */\n  function PathErrorStats(properties) {\n    this.children = {};\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * PathErrorStats children.\n   * @member {Object.<string,IPathErrorStats>} children\n   * @memberof PathErrorStats\n   * @instance\n   */\n\n\n  PathErrorStats.prototype.children = $util.emptyObject;\n  /**\n   * PathErrorStats errorsCount.\n   * @member {number} errorsCount\n   * @memberof PathErrorStats\n   * @instance\n   */\n\n  PathErrorStats.prototype.errorsCount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * PathErrorStats requestsWithErrorsCount.\n   * @member {number} requestsWithErrorsCount\n   * @memberof PathErrorStats\n   * @instance\n   */\n\n  PathErrorStats.prototype.requestsWithErrorsCount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Creates a new PathErrorStats instance using the specified properties.\n   * @function create\n   * @memberof PathErrorStats\n   * @static\n   * @param {IPathErrorStats=} [properties] Properties to set\n   * @returns {PathErrorStats} PathErrorStats instance\n   */\n\n  PathErrorStats.create = function create(properties) {\n    return new PathErrorStats(properties);\n  };\n  /**\n   * Encodes the specified PathErrorStats message. Does not implicitly {@link PathErrorStats.verify|verify} messages.\n   * @function encode\n   * @memberof PathErrorStats\n   * @static\n   * @param {IPathErrorStats} message PathErrorStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  PathErrorStats.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.children != null && Object.hasOwnProperty.call(message, \"children\")) for (var keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {\n      writer.uint32(\n      /* id 1, wireType 2 =*/\n      10).fork().uint32(\n      /* id 1, wireType 2 =*/\n      10).string(keys[i]);\n      $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim().ldelim();\n    }\n    if (message.errorsCount != null && Object.hasOwnProperty.call(message, \"errorsCount\")) writer.uint32(\n    /* id 4, wireType 0 =*/\n    32).uint64(message.errorsCount);\n    if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, \"requestsWithErrorsCount\")) writer.uint32(\n    /* id 5, wireType 0 =*/\n    40).uint64(message.requestsWithErrorsCount);\n    return writer;\n  };\n  /**\n   * Encodes the specified PathErrorStats message, length delimited. Does not implicitly {@link PathErrorStats.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof PathErrorStats\n   * @static\n   * @param {IPathErrorStats} message PathErrorStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  PathErrorStats.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a PathErrorStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof PathErrorStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {PathErrorStats} PathErrorStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  PathErrorStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.PathErrorStats(),\n        key;\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          reader.skip().pos++;\n          if (message.children === $util.emptyObject) message.children = {};\n          key = reader.string();\n          reader.pos++;\n          message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.errorsCount = reader.uint64();\n          break;\n\n        case 5:\n          message.requestsWithErrorsCount = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a PathErrorStats message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof PathErrorStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {PathErrorStats} PathErrorStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  PathErrorStats.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a PathErrorStats message.\n   * @function verify\n   * @memberof PathErrorStats\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  PathErrorStats.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.children != null && message.hasOwnProperty(\"children\")) {\n      if (!$util.isObject(message.children)) return \"children: object expected\";\n      var key = Object.keys(message.children);\n\n      for (var i = 0; i < key.length; ++i) {\n        var error = $root.PathErrorStats.verify(message.children[key[i]]);\n        if (error) return \"children.\" + error;\n      }\n    }\n\n    if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\")) if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high))) return \"errorsCount: integer|Long expected\";\n    if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\")) if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high))) return \"requestsWithErrorsCount: integer|Long expected\";\n    return null;\n  };\n  /**\n   * Creates a plain object from a PathErrorStats message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PathErrorStats\n   * @static\n   * @param {PathErrorStats} message PathErrorStats\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  PathErrorStats.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n    if (options.objects || options.defaults) object.children = {};\n\n    if (options.defaults) {\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.errorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.errorsCount = options.longs === String ? \"0\" : 0;\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.requestsWithErrorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.requestsWithErrorsCount = options.longs === String ? \"0\" : 0;\n    }\n\n    var keys2;\n\n    if (message.children && (keys2 = Object.keys(message.children)).length) {\n      object.children = {};\n\n      for (var j = 0; j < keys2.length; ++j) object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);\n    }\n\n    if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\")) if (typeof message.errorsCount === \"number\") object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;else object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;\n    if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\")) if (typeof message.requestsWithErrorsCount === \"number\") object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;else object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n    return object;\n  };\n  /**\n   * Converts this PathErrorStats to JSON.\n   * @function toJSON\n   * @memberof PathErrorStats\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  PathErrorStats.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return PathErrorStats;\n}();\n\n$root.QueryLatencyStats = function () {\n  /**\n   * Properties of a QueryLatencyStats.\n   * @exports IQueryLatencyStats\n   * @interface IQueryLatencyStats\n   * @property {$protobuf.ToArray.<number>|Array.<number>|null} [latencyCount] QueryLatencyStats latencyCount\n   * @property {number|null} [requestCount] QueryLatencyStats requestCount\n   * @property {number|null} [cacheHits] QueryLatencyStats cacheHits\n   * @property {number|null} [persistedQueryHits] QueryLatencyStats persistedQueryHits\n   * @property {number|null} [persistedQueryMisses] QueryLatencyStats persistedQueryMisses\n   * @property {$protobuf.ToArray.<number>|Array.<number>|null} [cacheLatencyCount] QueryLatencyStats cacheLatencyCount\n   * @property {IPathErrorStats|null} [rootErrorStats] QueryLatencyStats rootErrorStats\n   * @property {number|null} [requestsWithErrorsCount] QueryLatencyStats requestsWithErrorsCount\n   * @property {$protobuf.ToArray.<number>|Array.<number>|null} [publicCacheTtlCount] QueryLatencyStats publicCacheTtlCount\n   * @property {$protobuf.ToArray.<number>|Array.<number>|null} [privateCacheTtlCount] QueryLatencyStats privateCacheTtlCount\n   * @property {number|null} [registeredOperationCount] QueryLatencyStats registeredOperationCount\n   * @property {number|null} [forbiddenOperationCount] QueryLatencyStats forbiddenOperationCount\n   */\n\n  /**\n   * Constructs a new QueryLatencyStats.\n   * @exports QueryLatencyStats\n   * @classdesc Represents a QueryLatencyStats.\n   * @implements IQueryLatencyStats\n   * @constructor\n   * @param {IQueryLatencyStats=} [properties] Properties to set\n   */\n  function QueryLatencyStats(properties) {\n    this.latencyCount = [];\n    this.cacheLatencyCount = [];\n    this.publicCacheTtlCount = [];\n    this.privateCacheTtlCount = [];\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * QueryLatencyStats latencyCount.\n   * @member {Array.<number>} latencyCount\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n\n  QueryLatencyStats.prototype.latencyCount = $util.emptyArray;\n  /**\n   * QueryLatencyStats requestCount.\n   * @member {number} requestCount\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.requestCount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * QueryLatencyStats cacheHits.\n   * @member {number} cacheHits\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.cacheHits = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * QueryLatencyStats persistedQueryHits.\n   * @member {number} persistedQueryHits\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.persistedQueryHits = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * QueryLatencyStats persistedQueryMisses.\n   * @member {number} persistedQueryMisses\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.persistedQueryMisses = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * QueryLatencyStats cacheLatencyCount.\n   * @member {Array.<number>} cacheLatencyCount\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;\n  /**\n   * QueryLatencyStats rootErrorStats.\n   * @member {IPathErrorStats|null|undefined} rootErrorStats\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.rootErrorStats = null;\n  /**\n   * QueryLatencyStats requestsWithErrorsCount.\n   * @member {number} requestsWithErrorsCount\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.requestsWithErrorsCount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * QueryLatencyStats publicCacheTtlCount.\n   * @member {Array.<number>} publicCacheTtlCount\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;\n  /**\n   * QueryLatencyStats privateCacheTtlCount.\n   * @member {Array.<number>} privateCacheTtlCount\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;\n  /**\n   * QueryLatencyStats registeredOperationCount.\n   * @member {number} registeredOperationCount\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.registeredOperationCount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * QueryLatencyStats forbiddenOperationCount.\n   * @member {number} forbiddenOperationCount\n   * @memberof QueryLatencyStats\n   * @instance\n   */\n\n  QueryLatencyStats.prototype.forbiddenOperationCount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Creates a new QueryLatencyStats instance using the specified properties.\n   * @function create\n   * @memberof QueryLatencyStats\n   * @static\n   * @param {IQueryLatencyStats=} [properties] Properties to set\n   * @returns {QueryLatencyStats} QueryLatencyStats instance\n   */\n\n  QueryLatencyStats.create = function create(properties) {\n    return new QueryLatencyStats(properties);\n  };\n  /**\n   * Encodes the specified QueryLatencyStats message. Does not implicitly {@link QueryLatencyStats.verify|verify} messages.\n   * @function encode\n   * @memberof QueryLatencyStats\n   * @static\n   * @param {IQueryLatencyStats} message QueryLatencyStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  QueryLatencyStats.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.requestCount != null && Object.hasOwnProperty.call(message, \"requestCount\")) writer.uint32(\n    /* id 2, wireType 0 =*/\n    16).uint64(message.requestCount);\n    if (message.cacheHits != null && Object.hasOwnProperty.call(message, \"cacheHits\")) writer.uint32(\n    /* id 3, wireType 0 =*/\n    24).uint64(message.cacheHits);\n    if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, \"persistedQueryHits\")) writer.uint32(\n    /* id 4, wireType 0 =*/\n    32).uint64(message.persistedQueryHits);\n    if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, \"persistedQueryMisses\")) writer.uint32(\n    /* id 5, wireType 0 =*/\n    40).uint64(message.persistedQueryMisses);\n    if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, \"rootErrorStats\")) $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(\n    /* id 7, wireType 2 =*/\n    58).fork()).ldelim();\n    if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, \"requestsWithErrorsCount\")) writer.uint32(\n    /* id 8, wireType 0 =*/\n    64).uint64(message.requestsWithErrorsCount);\n    if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, \"registeredOperationCount\")) writer.uint32(\n    /* id 11, wireType 0 =*/\n    88).uint64(message.registeredOperationCount);\n    if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, \"forbiddenOperationCount\")) writer.uint32(\n    /* id 12, wireType 0 =*/\n    96).uint64(message.forbiddenOperationCount);\n    var array13;\n    if (message.latencyCount != null && message.latencyCount.toArray) array13 = message.latencyCount.toArray();else array13 = message.latencyCount;\n\n    if (array13 != null && array13.length) {\n      writer.uint32(\n      /* id 13, wireType 2 =*/\n      106).fork();\n\n      for (var i = 0; i < array13.length; ++i) writer.sint64(array13[i]);\n\n      writer.ldelim();\n    }\n\n    var array14;\n    if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray) array14 = message.cacheLatencyCount.toArray();else array14 = message.cacheLatencyCount;\n\n    if (array14 != null && array14.length) {\n      writer.uint32(\n      /* id 14, wireType 2 =*/\n      114).fork();\n\n      for (var i = 0; i < array14.length; ++i) writer.sint64(array14[i]);\n\n      writer.ldelim();\n    }\n\n    var array15;\n    if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray) array15 = message.publicCacheTtlCount.toArray();else array15 = message.publicCacheTtlCount;\n\n    if (array15 != null && array15.length) {\n      writer.uint32(\n      /* id 15, wireType 2 =*/\n      122).fork();\n\n      for (var i = 0; i < array15.length; ++i) writer.sint64(array15[i]);\n\n      writer.ldelim();\n    }\n\n    var array16;\n    if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray) array16 = message.privateCacheTtlCount.toArray();else array16 = message.privateCacheTtlCount;\n\n    if (array16 != null && array16.length) {\n      writer.uint32(\n      /* id 16, wireType 2 =*/\n      130).fork();\n\n      for (var i = 0; i < array16.length; ++i) writer.sint64(array16[i]);\n\n      writer.ldelim();\n    }\n\n    return writer;\n  };\n  /**\n   * Encodes the specified QueryLatencyStats message, length delimited. Does not implicitly {@link QueryLatencyStats.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof QueryLatencyStats\n   * @static\n   * @param {IQueryLatencyStats} message QueryLatencyStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  QueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a QueryLatencyStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof QueryLatencyStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {QueryLatencyStats} QueryLatencyStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  QueryLatencyStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.QueryLatencyStats();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 13:\n          if (!(message.latencyCount && message.latencyCount.length)) message.latencyCount = [];\n\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.latencyCount.push(reader.sint64());\n          } else message.latencyCount.push(reader.sint64());\n\n          break;\n\n        case 2:\n          message.requestCount = reader.uint64();\n          break;\n\n        case 3:\n          message.cacheHits = reader.uint64();\n          break;\n\n        case 4:\n          message.persistedQueryHits = reader.uint64();\n          break;\n\n        case 5:\n          message.persistedQueryMisses = reader.uint64();\n          break;\n\n        case 14:\n          if (!(message.cacheLatencyCount && message.cacheLatencyCount.length)) message.cacheLatencyCount = [];\n\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.cacheLatencyCount.push(reader.sint64());\n          } else message.cacheLatencyCount.push(reader.sint64());\n\n          break;\n\n        case 7:\n          message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());\n          break;\n\n        case 8:\n          message.requestsWithErrorsCount = reader.uint64();\n          break;\n\n        case 15:\n          if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length)) message.publicCacheTtlCount = [];\n\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.publicCacheTtlCount.push(reader.sint64());\n          } else message.publicCacheTtlCount.push(reader.sint64());\n\n          break;\n\n        case 16:\n          if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length)) message.privateCacheTtlCount = [];\n\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.privateCacheTtlCount.push(reader.sint64());\n          } else message.privateCacheTtlCount.push(reader.sint64());\n\n          break;\n\n        case 11:\n          message.registeredOperationCount = reader.uint64();\n          break;\n\n        case 12:\n          message.forbiddenOperationCount = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a QueryLatencyStats message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof QueryLatencyStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {QueryLatencyStats} QueryLatencyStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  QueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a QueryLatencyStats message.\n   * @function verify\n   * @memberof QueryLatencyStats\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  QueryLatencyStats.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.latencyCount != null && message.hasOwnProperty(\"latencyCount\")) {\n      var array13;\n      if (message.latencyCount != null && message.latencyCount.toArray) array13 = message.latencyCount.toArray();else array13 = message.latencyCount;\n      if (!Array.isArray(array13)) return \"latencyCount: array expected\";\n\n      for (var i = 0; i < array13.length; ++i) if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high))) return \"latencyCount: integer|Long[] expected\";\n    }\n\n    if (message.requestCount != null && message.hasOwnProperty(\"requestCount\")) if (!$util.isInteger(message.requestCount) && !(message.requestCount && $util.isInteger(message.requestCount.low) && $util.isInteger(message.requestCount.high))) return \"requestCount: integer|Long expected\";\n    if (message.cacheHits != null && message.hasOwnProperty(\"cacheHits\")) if (!$util.isInteger(message.cacheHits) && !(message.cacheHits && $util.isInteger(message.cacheHits.low) && $util.isInteger(message.cacheHits.high))) return \"cacheHits: integer|Long expected\";\n    if (message.persistedQueryHits != null && message.hasOwnProperty(\"persistedQueryHits\")) if (!$util.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util.isInteger(message.persistedQueryHits.low) && $util.isInteger(message.persistedQueryHits.high))) return \"persistedQueryHits: integer|Long expected\";\n    if (message.persistedQueryMisses != null && message.hasOwnProperty(\"persistedQueryMisses\")) if (!$util.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util.isInteger(message.persistedQueryMisses.low) && $util.isInteger(message.persistedQueryMisses.high))) return \"persistedQueryMisses: integer|Long expected\";\n\n    if (message.cacheLatencyCount != null && message.hasOwnProperty(\"cacheLatencyCount\")) {\n      var array14;\n      if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray) array14 = message.cacheLatencyCount.toArray();else array14 = message.cacheLatencyCount;\n      if (!Array.isArray(array14)) return \"cacheLatencyCount: array expected\";\n\n      for (var i = 0; i < array14.length; ++i) if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high))) return \"cacheLatencyCount: integer|Long[] expected\";\n    }\n\n    if (message.rootErrorStats != null && message.hasOwnProperty(\"rootErrorStats\")) {\n      var error = $root.PathErrorStats.verify(message.rootErrorStats);\n      if (error) return \"rootErrorStats.\" + error;\n    }\n\n    if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\")) if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high))) return \"requestsWithErrorsCount: integer|Long expected\";\n\n    if (message.publicCacheTtlCount != null && message.hasOwnProperty(\"publicCacheTtlCount\")) {\n      var array15;\n      if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray) array15 = message.publicCacheTtlCount.toArray();else array15 = message.publicCacheTtlCount;\n      if (!Array.isArray(array15)) return \"publicCacheTtlCount: array expected\";\n\n      for (var i = 0; i < array15.length; ++i) if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high))) return \"publicCacheTtlCount: integer|Long[] expected\";\n    }\n\n    if (message.privateCacheTtlCount != null && message.hasOwnProperty(\"privateCacheTtlCount\")) {\n      var array16;\n      if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray) array16 = message.privateCacheTtlCount.toArray();else array16 = message.privateCacheTtlCount;\n      if (!Array.isArray(array16)) return \"privateCacheTtlCount: array expected\";\n\n      for (var i = 0; i < array16.length; ++i) if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high))) return \"privateCacheTtlCount: integer|Long[] expected\";\n    }\n\n    if (message.registeredOperationCount != null && message.hasOwnProperty(\"registeredOperationCount\")) if (!$util.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util.isInteger(message.registeredOperationCount.low) && $util.isInteger(message.registeredOperationCount.high))) return \"registeredOperationCount: integer|Long expected\";\n    if (message.forbiddenOperationCount != null && message.hasOwnProperty(\"forbiddenOperationCount\")) if (!$util.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util.isInteger(message.forbiddenOperationCount.low) && $util.isInteger(message.forbiddenOperationCount.high))) return \"forbiddenOperationCount: integer|Long expected\";\n    return null;\n  };\n  /**\n   * Creates a plain object from a QueryLatencyStats message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof QueryLatencyStats\n   * @static\n   * @param {QueryLatencyStats} message QueryLatencyStats\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  QueryLatencyStats.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.arrays || options.defaults) {\n      object.latencyCount = [];\n      object.cacheLatencyCount = [];\n      object.publicCacheTtlCount = [];\n      object.privateCacheTtlCount = [];\n    }\n\n    if (options.defaults) {\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.requestCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.requestCount = options.longs === String ? \"0\" : 0;\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.cacheHits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.cacheHits = options.longs === String ? \"0\" : 0;\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.persistedQueryHits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.persistedQueryHits = options.longs === String ? \"0\" : 0;\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.persistedQueryMisses = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.persistedQueryMisses = options.longs === String ? \"0\" : 0;\n\n      object.rootErrorStats = null;\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.requestsWithErrorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.requestsWithErrorsCount = options.longs === String ? \"0\" : 0;\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.registeredOperationCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.registeredOperationCount = options.longs === String ? \"0\" : 0;\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.forbiddenOperationCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.forbiddenOperationCount = options.longs === String ? \"0\" : 0;\n    }\n\n    if (message.requestCount != null && message.hasOwnProperty(\"requestCount\")) if (typeof message.requestCount === \"number\") object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;else object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;\n    if (message.cacheHits != null && message.hasOwnProperty(\"cacheHits\")) if (typeof message.cacheHits === \"number\") object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;else object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;\n    if (message.persistedQueryHits != null && message.hasOwnProperty(\"persistedQueryHits\")) if (typeof message.persistedQueryHits === \"number\") object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;else object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;\n    if (message.persistedQueryMisses != null && message.hasOwnProperty(\"persistedQueryMisses\")) if (typeof message.persistedQueryMisses === \"number\") object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;else object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;\n    if (message.rootErrorStats != null && message.hasOwnProperty(\"rootErrorStats\")) object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);\n    if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\")) if (typeof message.requestsWithErrorsCount === \"number\") object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;else object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n    if (message.registeredOperationCount != null && message.hasOwnProperty(\"registeredOperationCount\")) if (typeof message.registeredOperationCount === \"number\") object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;else object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;\n    if (message.forbiddenOperationCount != null && message.hasOwnProperty(\"forbiddenOperationCount\")) if (typeof message.forbiddenOperationCount === \"number\") object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;else object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;\n\n    if (message.latencyCount && message.latencyCount.length) {\n      object.latencyCount = [];\n\n      for (var j = 0; j < message.latencyCount.length; ++j) if (typeof message.latencyCount[j] === \"number\") object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];else object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];\n    }\n\n    if (message.cacheLatencyCount && message.cacheLatencyCount.length) {\n      object.cacheLatencyCount = [];\n\n      for (var j = 0; j < message.cacheLatencyCount.length; ++j) if (typeof message.cacheLatencyCount[j] === \"number\") object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];else object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];\n    }\n\n    if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {\n      object.publicCacheTtlCount = [];\n\n      for (var j = 0; j < message.publicCacheTtlCount.length; ++j) if (typeof message.publicCacheTtlCount[j] === \"number\") object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];else object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];\n    }\n\n    if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {\n      object.privateCacheTtlCount = [];\n\n      for (var j = 0; j < message.privateCacheTtlCount.length; ++j) if (typeof message.privateCacheTtlCount[j] === \"number\") object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];else object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];\n    }\n\n    return object;\n  };\n  /**\n   * Converts this QueryLatencyStats to JSON.\n   * @function toJSON\n   * @memberof QueryLatencyStats\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  QueryLatencyStats.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return QueryLatencyStats;\n}();\n\n$root.StatsContext = function () {\n  /**\n   * Properties of a StatsContext.\n   * @exports IStatsContext\n   * @interface IStatsContext\n   * @property {string|null} [clientReferenceId] StatsContext clientReferenceId\n   * @property {string|null} [clientName] StatsContext clientName\n   * @property {string|null} [clientVersion] StatsContext clientVersion\n   */\n\n  /**\n   * Constructs a new StatsContext.\n   * @exports StatsContext\n   * @classdesc Represents a StatsContext.\n   * @implements IStatsContext\n   * @constructor\n   * @param {IStatsContext=} [properties] Properties to set\n   */\n  function StatsContext(properties) {\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * StatsContext clientReferenceId.\n   * @member {string} clientReferenceId\n   * @memberof StatsContext\n   * @instance\n   */\n\n\n  StatsContext.prototype.clientReferenceId = \"\";\n  /**\n   * StatsContext clientName.\n   * @member {string} clientName\n   * @memberof StatsContext\n   * @instance\n   */\n\n  StatsContext.prototype.clientName = \"\";\n  /**\n   * StatsContext clientVersion.\n   * @member {string} clientVersion\n   * @memberof StatsContext\n   * @instance\n   */\n\n  StatsContext.prototype.clientVersion = \"\";\n  /**\n   * Creates a new StatsContext instance using the specified properties.\n   * @function create\n   * @memberof StatsContext\n   * @static\n   * @param {IStatsContext=} [properties] Properties to set\n   * @returns {StatsContext} StatsContext instance\n   */\n\n  StatsContext.create = function create(properties) {\n    return new StatsContext(properties);\n  };\n  /**\n   * Encodes the specified StatsContext message. Does not implicitly {@link StatsContext.verify|verify} messages.\n   * @function encode\n   * @memberof StatsContext\n   * @static\n   * @param {IStatsContext} message StatsContext message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  StatsContext.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.clientReferenceId != null && Object.hasOwnProperty.call(message, \"clientReferenceId\")) writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).string(message.clientReferenceId);\n    if (message.clientName != null && Object.hasOwnProperty.call(message, \"clientName\")) writer.uint32(\n    /* id 2, wireType 2 =*/\n    18).string(message.clientName);\n    if (message.clientVersion != null && Object.hasOwnProperty.call(message, \"clientVersion\")) writer.uint32(\n    /* id 3, wireType 2 =*/\n    26).string(message.clientVersion);\n    return writer;\n  };\n  /**\n   * Encodes the specified StatsContext message, length delimited. Does not implicitly {@link StatsContext.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof StatsContext\n   * @static\n   * @param {IStatsContext} message StatsContext message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  StatsContext.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a StatsContext message from the specified reader or buffer.\n   * @function decode\n   * @memberof StatsContext\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {StatsContext} StatsContext\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  StatsContext.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.StatsContext();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.clientReferenceId = reader.string();\n          break;\n\n        case 2:\n          message.clientName = reader.string();\n          break;\n\n        case 3:\n          message.clientVersion = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a StatsContext message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof StatsContext\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {StatsContext} StatsContext\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  StatsContext.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a StatsContext message.\n   * @function verify\n   * @memberof StatsContext\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  StatsContext.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n    if (message.clientReferenceId != null && message.hasOwnProperty(\"clientReferenceId\")) if (!$util.isString(message.clientReferenceId)) return \"clientReferenceId: string expected\";\n    if (message.clientName != null && message.hasOwnProperty(\"clientName\")) if (!$util.isString(message.clientName)) return \"clientName: string expected\";\n    if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\")) if (!$util.isString(message.clientVersion)) return \"clientVersion: string expected\";\n    return null;\n  };\n  /**\n   * Creates a plain object from a StatsContext message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof StatsContext\n   * @static\n   * @param {StatsContext} message StatsContext\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  StatsContext.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.defaults) {\n      object.clientReferenceId = \"\";\n      object.clientName = \"\";\n      object.clientVersion = \"\";\n    }\n\n    if (message.clientReferenceId != null && message.hasOwnProperty(\"clientReferenceId\")) object.clientReferenceId = message.clientReferenceId;\n    if (message.clientName != null && message.hasOwnProperty(\"clientName\")) object.clientName = message.clientName;\n    if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\")) object.clientVersion = message.clientVersion;\n    return object;\n  };\n  /**\n   * Converts this StatsContext to JSON.\n   * @function toJSON\n   * @memberof StatsContext\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  StatsContext.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return StatsContext;\n}();\n\n$root.ContextualizedQueryLatencyStats = function () {\n  /**\n   * Properties of a ContextualizedQueryLatencyStats.\n   * @exports IContextualizedQueryLatencyStats\n   * @interface IContextualizedQueryLatencyStats\n   * @property {IQueryLatencyStats|null} [queryLatencyStats] ContextualizedQueryLatencyStats queryLatencyStats\n   * @property {IStatsContext|null} [context] ContextualizedQueryLatencyStats context\n   */\n\n  /**\n   * Constructs a new ContextualizedQueryLatencyStats.\n   * @exports ContextualizedQueryLatencyStats\n   * @classdesc Represents a ContextualizedQueryLatencyStats.\n   * @implements IContextualizedQueryLatencyStats\n   * @constructor\n   * @param {IContextualizedQueryLatencyStats=} [properties] Properties to set\n   */\n  function ContextualizedQueryLatencyStats(properties) {\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * ContextualizedQueryLatencyStats queryLatencyStats.\n   * @member {IQueryLatencyStats|null|undefined} queryLatencyStats\n   * @memberof ContextualizedQueryLatencyStats\n   * @instance\n   */\n\n\n  ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;\n  /**\n   * ContextualizedQueryLatencyStats context.\n   * @member {IStatsContext|null|undefined} context\n   * @memberof ContextualizedQueryLatencyStats\n   * @instance\n   */\n\n  ContextualizedQueryLatencyStats.prototype.context = null;\n  /**\n   * Creates a new ContextualizedQueryLatencyStats instance using the specified properties.\n   * @function create\n   * @memberof ContextualizedQueryLatencyStats\n   * @static\n   * @param {IContextualizedQueryLatencyStats=} [properties] Properties to set\n   * @returns {ContextualizedQueryLatencyStats} ContextualizedQueryLatencyStats instance\n   */\n\n  ContextualizedQueryLatencyStats.create = function create(properties) {\n    return new ContextualizedQueryLatencyStats(properties);\n  };\n  /**\n   * Encodes the specified ContextualizedQueryLatencyStats message. Does not implicitly {@link ContextualizedQueryLatencyStats.verify|verify} messages.\n   * @function encode\n   * @memberof ContextualizedQueryLatencyStats\n   * @static\n   * @param {IContextualizedQueryLatencyStats} message ContextualizedQueryLatencyStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  ContextualizedQueryLatencyStats.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, \"queryLatencyStats\")) $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).fork()).ldelim();\n    if (message.context != null && Object.hasOwnProperty.call(message, \"context\")) $root.StatsContext.encode(message.context, writer.uint32(\n    /* id 2, wireType 2 =*/\n    18).fork()).ldelim();\n    return writer;\n  };\n  /**\n   * Encodes the specified ContextualizedQueryLatencyStats message, length delimited. Does not implicitly {@link ContextualizedQueryLatencyStats.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof ContextualizedQueryLatencyStats\n   * @static\n   * @param {IContextualizedQueryLatencyStats} message ContextualizedQueryLatencyStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  ContextualizedQueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a ContextualizedQueryLatencyStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof ContextualizedQueryLatencyStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {ContextualizedQueryLatencyStats} ContextualizedQueryLatencyStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  ContextualizedQueryLatencyStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.ContextualizedQueryLatencyStats();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.context = $root.StatsContext.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a ContextualizedQueryLatencyStats message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof ContextualizedQueryLatencyStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {ContextualizedQueryLatencyStats} ContextualizedQueryLatencyStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  ContextualizedQueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a ContextualizedQueryLatencyStats message.\n   * @function verify\n   * @memberof ContextualizedQueryLatencyStats\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  ContextualizedQueryLatencyStats.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\")) {\n      var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);\n      if (error) return \"queryLatencyStats.\" + error;\n    }\n\n    if (message.context != null && message.hasOwnProperty(\"context\")) {\n      var error = $root.StatsContext.verify(message.context);\n      if (error) return \"context.\" + error;\n    }\n\n    return null;\n  };\n  /**\n   * Creates a plain object from a ContextualizedQueryLatencyStats message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof ContextualizedQueryLatencyStats\n   * @static\n   * @param {ContextualizedQueryLatencyStats} message ContextualizedQueryLatencyStats\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  ContextualizedQueryLatencyStats.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.defaults) {\n      object.queryLatencyStats = null;\n      object.context = null;\n    }\n\n    if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\")) object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);\n    if (message.context != null && message.hasOwnProperty(\"context\")) object.context = $root.StatsContext.toObject(message.context, options);\n    return object;\n  };\n  /**\n   * Converts this ContextualizedQueryLatencyStats to JSON.\n   * @function toJSON\n   * @memberof ContextualizedQueryLatencyStats\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  ContextualizedQueryLatencyStats.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return ContextualizedQueryLatencyStats;\n}();\n\n$root.ContextualizedTypeStats = function () {\n  /**\n   * Properties of a ContextualizedTypeStats.\n   * @exports IContextualizedTypeStats\n   * @interface IContextualizedTypeStats\n   * @property {IStatsContext|null} [context] ContextualizedTypeStats context\n   * @property {Object.<string,ITypeStat>|null} [perTypeStat] ContextualizedTypeStats perTypeStat\n   */\n\n  /**\n   * Constructs a new ContextualizedTypeStats.\n   * @exports ContextualizedTypeStats\n   * @classdesc Represents a ContextualizedTypeStats.\n   * @implements IContextualizedTypeStats\n   * @constructor\n   * @param {IContextualizedTypeStats=} [properties] Properties to set\n   */\n  function ContextualizedTypeStats(properties) {\n    this.perTypeStat = {};\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * ContextualizedTypeStats context.\n   * @member {IStatsContext|null|undefined} context\n   * @memberof ContextualizedTypeStats\n   * @instance\n   */\n\n\n  ContextualizedTypeStats.prototype.context = null;\n  /**\n   * ContextualizedTypeStats perTypeStat.\n   * @member {Object.<string,ITypeStat>} perTypeStat\n   * @memberof ContextualizedTypeStats\n   * @instance\n   */\n\n  ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;\n  /**\n   * Creates a new ContextualizedTypeStats instance using the specified properties.\n   * @function create\n   * @memberof ContextualizedTypeStats\n   * @static\n   * @param {IContextualizedTypeStats=} [properties] Properties to set\n   * @returns {ContextualizedTypeStats} ContextualizedTypeStats instance\n   */\n\n  ContextualizedTypeStats.create = function create(properties) {\n    return new ContextualizedTypeStats(properties);\n  };\n  /**\n   * Encodes the specified ContextualizedTypeStats message. Does not implicitly {@link ContextualizedTypeStats.verify|verify} messages.\n   * @function encode\n   * @memberof ContextualizedTypeStats\n   * @static\n   * @param {IContextualizedTypeStats} message ContextualizedTypeStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  ContextualizedTypeStats.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.context != null && Object.hasOwnProperty.call(message, \"context\")) $root.StatsContext.encode(message.context, writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).fork()).ldelim();\n    if (message.perTypeStat != null && Object.hasOwnProperty.call(message, \"perTypeStat\")) for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {\n      writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork().uint32(\n      /* id 1, wireType 2 =*/\n      10).string(keys[i]);\n      $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim().ldelim();\n    }\n    return writer;\n  };\n  /**\n   * Encodes the specified ContextualizedTypeStats message, length delimited. Does not implicitly {@link ContextualizedTypeStats.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof ContextualizedTypeStats\n   * @static\n   * @param {IContextualizedTypeStats} message ContextualizedTypeStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  ContextualizedTypeStats.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a ContextualizedTypeStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof ContextualizedTypeStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {ContextualizedTypeStats} ContextualizedTypeStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  ContextualizedTypeStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.ContextualizedTypeStats(),\n        key;\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.context = $root.StatsContext.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          reader.skip().pos++;\n          if (message.perTypeStat === $util.emptyObject) message.perTypeStat = {};\n          key = reader.string();\n          reader.pos++;\n          message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a ContextualizedTypeStats message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof ContextualizedTypeStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {ContextualizedTypeStats} ContextualizedTypeStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  ContextualizedTypeStats.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a ContextualizedTypeStats message.\n   * @function verify\n   * @memberof ContextualizedTypeStats\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  ContextualizedTypeStats.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.context != null && message.hasOwnProperty(\"context\")) {\n      var error = $root.StatsContext.verify(message.context);\n      if (error) return \"context.\" + error;\n    }\n\n    if (message.perTypeStat != null && message.hasOwnProperty(\"perTypeStat\")) {\n      if (!$util.isObject(message.perTypeStat)) return \"perTypeStat: object expected\";\n      var key = Object.keys(message.perTypeStat);\n\n      for (var i = 0; i < key.length; ++i) {\n        var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);\n        if (error) return \"perTypeStat.\" + error;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Creates a plain object from a ContextualizedTypeStats message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof ContextualizedTypeStats\n   * @static\n   * @param {ContextualizedTypeStats} message ContextualizedTypeStats\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  ContextualizedTypeStats.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n    if (options.objects || options.defaults) object.perTypeStat = {};\n    if (options.defaults) object.context = null;\n    if (message.context != null && message.hasOwnProperty(\"context\")) object.context = $root.StatsContext.toObject(message.context, options);\n    var keys2;\n\n    if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {\n      object.perTypeStat = {};\n\n      for (var j = 0; j < keys2.length; ++j) object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);\n    }\n\n    return object;\n  };\n  /**\n   * Converts this ContextualizedTypeStats to JSON.\n   * @function toJSON\n   * @memberof ContextualizedTypeStats\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  ContextualizedTypeStats.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return ContextualizedTypeStats;\n}();\n\n$root.FieldStat = function () {\n  /**\n   * Properties of a FieldStat.\n   * @exports IFieldStat\n   * @interface IFieldStat\n   * @property {string|null} [returnType] FieldStat returnType\n   * @property {number|null} [errorsCount] FieldStat errorsCount\n   * @property {number|null} [count] FieldStat count\n   * @property {number|null} [requestsWithErrorsCount] FieldStat requestsWithErrorsCount\n   * @property {$protobuf.ToArray.<number>|Array.<number>|null} [latencyCount] FieldStat latencyCount\n   */\n\n  /**\n   * Constructs a new FieldStat.\n   * @exports FieldStat\n   * @classdesc Represents a FieldStat.\n   * @implements IFieldStat\n   * @constructor\n   * @param {IFieldStat=} [properties] Properties to set\n   */\n  function FieldStat(properties) {\n    this.latencyCount = [];\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * FieldStat returnType.\n   * @member {string} returnType\n   * @memberof FieldStat\n   * @instance\n   */\n\n\n  FieldStat.prototype.returnType = \"\";\n  /**\n   * FieldStat errorsCount.\n   * @member {number} errorsCount\n   * @memberof FieldStat\n   * @instance\n   */\n\n  FieldStat.prototype.errorsCount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * FieldStat count.\n   * @member {number} count\n   * @memberof FieldStat\n   * @instance\n   */\n\n  FieldStat.prototype.count = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * FieldStat requestsWithErrorsCount.\n   * @member {number} requestsWithErrorsCount\n   * @memberof FieldStat\n   * @instance\n   */\n\n  FieldStat.prototype.requestsWithErrorsCount = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * FieldStat latencyCount.\n   * @member {Array.<number>} latencyCount\n   * @memberof FieldStat\n   * @instance\n   */\n\n  FieldStat.prototype.latencyCount = $util.emptyArray;\n  /**\n   * Creates a new FieldStat instance using the specified properties.\n   * @function create\n   * @memberof FieldStat\n   * @static\n   * @param {IFieldStat=} [properties] Properties to set\n   * @returns {FieldStat} FieldStat instance\n   */\n\n  FieldStat.create = function create(properties) {\n    return new FieldStat(properties);\n  };\n  /**\n   * Encodes the specified FieldStat message. Does not implicitly {@link FieldStat.verify|verify} messages.\n   * @function encode\n   * @memberof FieldStat\n   * @static\n   * @param {IFieldStat} message FieldStat message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  FieldStat.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.returnType != null && Object.hasOwnProperty.call(message, \"returnType\")) writer.uint32(\n    /* id 3, wireType 2 =*/\n    26).string(message.returnType);\n    if (message.errorsCount != null && Object.hasOwnProperty.call(message, \"errorsCount\")) writer.uint32(\n    /* id 4, wireType 0 =*/\n    32).uint64(message.errorsCount);\n    if (message.count != null && Object.hasOwnProperty.call(message, \"count\")) writer.uint32(\n    /* id 5, wireType 0 =*/\n    40).uint64(message.count);\n    if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, \"requestsWithErrorsCount\")) writer.uint32(\n    /* id 6, wireType 0 =*/\n    48).uint64(message.requestsWithErrorsCount);\n    var array9;\n    if (message.latencyCount != null && message.latencyCount.toArray) array9 = message.latencyCount.toArray();else array9 = message.latencyCount;\n\n    if (array9 != null && array9.length) {\n      writer.uint32(\n      /* id 9, wireType 2 =*/\n      74).fork();\n\n      for (var i = 0; i < array9.length; ++i) writer.sint64(array9[i]);\n\n      writer.ldelim();\n    }\n\n    return writer;\n  };\n  /**\n   * Encodes the specified FieldStat message, length delimited. Does not implicitly {@link FieldStat.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof FieldStat\n   * @static\n   * @param {IFieldStat} message FieldStat message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  FieldStat.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a FieldStat message from the specified reader or buffer.\n   * @function decode\n   * @memberof FieldStat\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {FieldStat} FieldStat\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  FieldStat.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.FieldStat();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 3:\n          message.returnType = reader.string();\n          break;\n\n        case 4:\n          message.errorsCount = reader.uint64();\n          break;\n\n        case 5:\n          message.count = reader.uint64();\n          break;\n\n        case 6:\n          message.requestsWithErrorsCount = reader.uint64();\n          break;\n\n        case 9:\n          if (!(message.latencyCount && message.latencyCount.length)) message.latencyCount = [];\n\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.latencyCount.push(reader.sint64());\n          } else message.latencyCount.push(reader.sint64());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a FieldStat message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof FieldStat\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {FieldStat} FieldStat\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  FieldStat.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a FieldStat message.\n   * @function verify\n   * @memberof FieldStat\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  FieldStat.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n    if (message.returnType != null && message.hasOwnProperty(\"returnType\")) if (!$util.isString(message.returnType)) return \"returnType: string expected\";\n    if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\")) if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high))) return \"errorsCount: integer|Long expected\";\n    if (message.count != null && message.hasOwnProperty(\"count\")) if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high))) return \"count: integer|Long expected\";\n    if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\")) if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high))) return \"requestsWithErrorsCount: integer|Long expected\";\n\n    if (message.latencyCount != null && message.hasOwnProperty(\"latencyCount\")) {\n      var array9;\n      if (message.latencyCount != null && message.latencyCount.toArray) array9 = message.latencyCount.toArray();else array9 = message.latencyCount;\n      if (!Array.isArray(array9)) return \"latencyCount: array expected\";\n\n      for (var i = 0; i < array9.length; ++i) if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high))) return \"latencyCount: integer|Long[] expected\";\n    }\n\n    return null;\n  };\n  /**\n   * Creates a plain object from a FieldStat message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof FieldStat\n   * @static\n   * @param {FieldStat} message FieldStat\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  FieldStat.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n    if (options.arrays || options.defaults) object.latencyCount = [];\n\n    if (options.defaults) {\n      object.returnType = \"\";\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.errorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.errorsCount = options.longs === String ? \"0\" : 0;\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.count = options.longs === String ? \"0\" : 0;\n\n      if ($util.Long) {\n        var long = new $util.Long(0, 0, true);\n        object.requestsWithErrorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n      } else object.requestsWithErrorsCount = options.longs === String ? \"0\" : 0;\n    }\n\n    if (message.returnType != null && message.hasOwnProperty(\"returnType\")) object.returnType = message.returnType;\n    if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\")) if (typeof message.errorsCount === \"number\") object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;else object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;\n    if (message.count != null && message.hasOwnProperty(\"count\")) if (typeof message.count === \"number\") object.count = options.longs === String ? String(message.count) : message.count;else object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true) : message.count;\n    if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\")) if (typeof message.requestsWithErrorsCount === \"number\") object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;else object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n\n    if (message.latencyCount && message.latencyCount.length) {\n      object.latencyCount = [];\n\n      for (var j = 0; j < message.latencyCount.length; ++j) if (typeof message.latencyCount[j] === \"number\") object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];else object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];\n    }\n\n    return object;\n  };\n  /**\n   * Converts this FieldStat to JSON.\n   * @function toJSON\n   * @memberof FieldStat\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  FieldStat.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return FieldStat;\n}();\n\n$root.TypeStat = function () {\n  /**\n   * Properties of a TypeStat.\n   * @exports ITypeStat\n   * @interface ITypeStat\n   * @property {Object.<string,IFieldStat>|null} [perFieldStat] TypeStat perFieldStat\n   */\n\n  /**\n   * Constructs a new TypeStat.\n   * @exports TypeStat\n   * @classdesc Represents a TypeStat.\n   * @implements ITypeStat\n   * @constructor\n   * @param {ITypeStat=} [properties] Properties to set\n   */\n  function TypeStat(properties) {\n    this.perFieldStat = {};\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * TypeStat perFieldStat.\n   * @member {Object.<string,IFieldStat>} perFieldStat\n   * @memberof TypeStat\n   * @instance\n   */\n\n\n  TypeStat.prototype.perFieldStat = $util.emptyObject;\n  /**\n   * Creates a new TypeStat instance using the specified properties.\n   * @function create\n   * @memberof TypeStat\n   * @static\n   * @param {ITypeStat=} [properties] Properties to set\n   * @returns {TypeStat} TypeStat instance\n   */\n\n  TypeStat.create = function create(properties) {\n    return new TypeStat(properties);\n  };\n  /**\n   * Encodes the specified TypeStat message. Does not implicitly {@link TypeStat.verify|verify} messages.\n   * @function encode\n   * @memberof TypeStat\n   * @static\n   * @param {ITypeStat} message TypeStat message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  TypeStat.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.perFieldStat != null && Object.hasOwnProperty.call(message, \"perFieldStat\")) for (var keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {\n      writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork().uint32(\n      /* id 1, wireType 2 =*/\n      10).string(keys[i]);\n      $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim().ldelim();\n    }\n    return writer;\n  };\n  /**\n   * Encodes the specified TypeStat message, length delimited. Does not implicitly {@link TypeStat.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof TypeStat\n   * @static\n   * @param {ITypeStat} message TypeStat message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  TypeStat.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a TypeStat message from the specified reader or buffer.\n   * @function decode\n   * @memberof TypeStat\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {TypeStat} TypeStat\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  TypeStat.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.TypeStat(),\n        key;\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 3:\n          reader.skip().pos++;\n          if (message.perFieldStat === $util.emptyObject) message.perFieldStat = {};\n          key = reader.string();\n          reader.pos++;\n          message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a TypeStat message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof TypeStat\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {TypeStat} TypeStat\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  TypeStat.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a TypeStat message.\n   * @function verify\n   * @memberof TypeStat\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  TypeStat.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.perFieldStat != null && message.hasOwnProperty(\"perFieldStat\")) {\n      if (!$util.isObject(message.perFieldStat)) return \"perFieldStat: object expected\";\n      var key = Object.keys(message.perFieldStat);\n\n      for (var i = 0; i < key.length; ++i) {\n        var error = $root.FieldStat.verify(message.perFieldStat[key[i]]);\n        if (error) return \"perFieldStat.\" + error;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Creates a plain object from a TypeStat message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof TypeStat\n   * @static\n   * @param {TypeStat} message TypeStat\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  TypeStat.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n    if (options.objects || options.defaults) object.perFieldStat = {};\n    var keys2;\n\n    if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {\n      object.perFieldStat = {};\n\n      for (var j = 0; j < keys2.length; ++j) object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);\n    }\n\n    return object;\n  };\n  /**\n   * Converts this TypeStat to JSON.\n   * @function toJSON\n   * @memberof TypeStat\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  TypeStat.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return TypeStat;\n}();\n\n$root.Field = function () {\n  /**\n   * Properties of a Field.\n   * @exports IField\n   * @interface IField\n   * @property {string|null} [name] Field name\n   * @property {string|null} [returnType] Field returnType\n   */\n\n  /**\n   * Constructs a new Field.\n   * @exports Field\n   * @classdesc Represents a Field.\n   * @implements IField\n   * @constructor\n   * @param {IField=} [properties] Properties to set\n   */\n  function Field(properties) {\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Field name.\n   * @member {string} name\n   * @memberof Field\n   * @instance\n   */\n\n\n  Field.prototype.name = \"\";\n  /**\n   * Field returnType.\n   * @member {string} returnType\n   * @memberof Field\n   * @instance\n   */\n\n  Field.prototype.returnType = \"\";\n  /**\n   * Creates a new Field instance using the specified properties.\n   * @function create\n   * @memberof Field\n   * @static\n   * @param {IField=} [properties] Properties to set\n   * @returns {Field} Field instance\n   */\n\n  Field.create = function create(properties) {\n    return new Field(properties);\n  };\n  /**\n   * Encodes the specified Field message. Does not implicitly {@link Field.verify|verify} messages.\n   * @function encode\n   * @memberof Field\n   * @static\n   * @param {IField} message Field message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Field.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.name != null && Object.hasOwnProperty.call(message, \"name\")) writer.uint32(\n    /* id 2, wireType 2 =*/\n    18).string(message.name);\n    if (message.returnType != null && Object.hasOwnProperty.call(message, \"returnType\")) writer.uint32(\n    /* id 3, wireType 2 =*/\n    26).string(message.returnType);\n    return writer;\n  };\n  /**\n   * Encodes the specified Field message, length delimited. Does not implicitly {@link Field.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Field\n   * @static\n   * @param {IField} message Field message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Field.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a Field message from the specified reader or buffer.\n   * @function decode\n   * @memberof Field\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Field} Field\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Field.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.Field();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 2:\n          message.name = reader.string();\n          break;\n\n        case 3:\n          message.returnType = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a Field message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Field\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Field} Field\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Field.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a Field message.\n   * @function verify\n   * @memberof Field\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  Field.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n    if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n    if (message.returnType != null && message.hasOwnProperty(\"returnType\")) if (!$util.isString(message.returnType)) return \"returnType: string expected\";\n    return null;\n  };\n  /**\n   * Creates a plain object from a Field message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Field\n   * @static\n   * @param {Field} message Field\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Field.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.defaults) {\n      object.name = \"\";\n      object.returnType = \"\";\n    }\n\n    if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n    if (message.returnType != null && message.hasOwnProperty(\"returnType\")) object.returnType = message.returnType;\n    return object;\n  };\n  /**\n   * Converts this Field to JSON.\n   * @function toJSON\n   * @memberof Field\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Field.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return Field;\n}();\n\n$root.Type = function () {\n  /**\n   * Properties of a Type.\n   * @exports IType\n   * @interface IType\n   * @property {string|null} [name] Type name\n   * @property {Array.<IField>|null} [field] Type field\n   */\n\n  /**\n   * Constructs a new Type.\n   * @exports Type\n   * @classdesc Represents a Type.\n   * @implements IType\n   * @constructor\n   * @param {IType=} [properties] Properties to set\n   */\n  function Type(properties) {\n    this.field = [];\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Type name.\n   * @member {string} name\n   * @memberof Type\n   * @instance\n   */\n\n\n  Type.prototype.name = \"\";\n  /**\n   * Type field.\n   * @member {Array.<IField>} field\n   * @memberof Type\n   * @instance\n   */\n\n  Type.prototype.field = $util.emptyArray;\n  /**\n   * Creates a new Type instance using the specified properties.\n   * @function create\n   * @memberof Type\n   * @static\n   * @param {IType=} [properties] Properties to set\n   * @returns {Type} Type instance\n   */\n\n  Type.create = function create(properties) {\n    return new Type(properties);\n  };\n  /**\n   * Encodes the specified Type message. Does not implicitly {@link Type.verify|verify} messages.\n   * @function encode\n   * @memberof Type\n   * @static\n   * @param {IType} message Type message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Type.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.name != null && Object.hasOwnProperty.call(message, \"name\")) writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).string(message.name);\n    if (message.field != null && message.field.length) for (var i = 0; i < message.field.length; ++i) $root.Field.encode(message.field[i], writer.uint32(\n    /* id 2, wireType 2 =*/\n    18).fork()).ldelim();\n    return writer;\n  };\n  /**\n   * Encodes the specified Type message, length delimited. Does not implicitly {@link Type.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Type\n   * @static\n   * @param {IType} message Type message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Type.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a Type message from the specified reader or buffer.\n   * @function decode\n   * @memberof Type\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Type} Type\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Type.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.Type();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n\n        case 2:\n          if (!(message.field && message.field.length)) message.field = [];\n          message.field.push($root.Field.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a Type message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Type\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Type} Type\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Type.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a Type message.\n   * @function verify\n   * @memberof Type\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  Type.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n    if (message.name != null && message.hasOwnProperty(\"name\")) if (!$util.isString(message.name)) return \"name: string expected\";\n\n    if (message.field != null && message.hasOwnProperty(\"field\")) {\n      if (!Array.isArray(message.field)) return \"field: array expected\";\n\n      for (var i = 0; i < message.field.length; ++i) {\n        var error = $root.Field.verify(message.field[i]);\n        if (error) return \"field.\" + error;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Creates a plain object from a Type message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Type\n   * @static\n   * @param {Type} message Type\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Type.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n    if (options.arrays || options.defaults) object.field = [];\n    if (options.defaults) object.name = \"\";\n    if (message.name != null && message.hasOwnProperty(\"name\")) object.name = message.name;\n\n    if (message.field && message.field.length) {\n      object.field = [];\n\n      for (var j = 0; j < message.field.length; ++j) object.field[j] = $root.Field.toObject(message.field[j], options);\n    }\n\n    return object;\n  };\n  /**\n   * Converts this Type to JSON.\n   * @function toJSON\n   * @memberof Type\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Type.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return Type;\n}();\n\n$root.Report = function () {\n  /**\n   * Properties of a Report.\n   * @exports IReport\n   * @interface IReport\n   * @property {IReportHeader|null} [header] Report header\n   * @property {Object.<string,ITracesAndStats>|null} [tracesPerQuery] Report tracesPerQuery\n   * @property {google.protobuf.ITimestamp|null} [endTime] Report endTime\n   */\n\n  /**\n   * Constructs a new Report.\n   * @exports Report\n   * @classdesc Represents a Report.\n   * @implements IReport\n   * @constructor\n   * @param {IReport=} [properties] Properties to set\n   */\n  function Report(properties) {\n    this.tracesPerQuery = {};\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Report header.\n   * @member {IReportHeader|null|undefined} header\n   * @memberof Report\n   * @instance\n   */\n\n\n  Report.prototype.header = null;\n  /**\n   * Report tracesPerQuery.\n   * @member {Object.<string,ITracesAndStats>} tracesPerQuery\n   * @memberof Report\n   * @instance\n   */\n\n  Report.prototype.tracesPerQuery = $util.emptyObject;\n  /**\n   * Report endTime.\n   * @member {google.protobuf.ITimestamp|null|undefined} endTime\n   * @memberof Report\n   * @instance\n   */\n\n  Report.prototype.endTime = null;\n  /**\n   * Creates a new Report instance using the specified properties.\n   * @function create\n   * @memberof Report\n   * @static\n   * @param {IReport=} [properties] Properties to set\n   * @returns {Report} Report instance\n   */\n\n  Report.create = function create(properties) {\n    return new Report(properties);\n  };\n  /**\n   * Encodes the specified Report message. Does not implicitly {@link Report.verify|verify} messages.\n   * @function encode\n   * @memberof Report\n   * @static\n   * @param {IReport} message Report message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Report.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.header != null && Object.hasOwnProperty.call(message, \"header\")) $root.ReportHeader.encode(message.header, writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).fork()).ldelim();\n    if (message.endTime != null && Object.hasOwnProperty.call(message, \"endTime\")) $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(\n    /* id 2, wireType 2 =*/\n    18).fork()).ldelim();\n    if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, \"tracesPerQuery\")) for (var keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {\n      writer.uint32(\n      /* id 5, wireType 2 =*/\n      42).fork().uint32(\n      /* id 1, wireType 2 =*/\n      10).string(keys[i]);\n      $root.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim().ldelim();\n    }\n    return writer;\n  };\n  /**\n   * Encodes the specified Report message, length delimited. Does not implicitly {@link Report.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Report\n   * @static\n   * @param {IReport} message Report message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Report.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a Report message from the specified reader or buffer.\n   * @function decode\n   * @memberof Report\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Report} Report\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Report.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.Report(),\n        key;\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.header = $root.ReportHeader.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          reader.skip().pos++;\n          if (message.tracesPerQuery === $util.emptyObject) message.tracesPerQuery = {};\n          key = reader.string();\n          reader.pos++;\n          message.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a Report message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Report\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Report} Report\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Report.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a Report message.\n   * @function verify\n   * @memberof Report\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  Report.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.header != null && message.hasOwnProperty(\"header\")) {\n      var error = $root.ReportHeader.verify(message.header);\n      if (error) return \"header.\" + error;\n    }\n\n    if (message.tracesPerQuery != null && message.hasOwnProperty(\"tracesPerQuery\")) {\n      if (!$util.isObject(message.tracesPerQuery)) return \"tracesPerQuery: object expected\";\n      var key = Object.keys(message.tracesPerQuery);\n\n      for (var i = 0; i < key.length; ++i) {\n        var error = $root.TracesAndStats.verify(message.tracesPerQuery[key[i]]);\n        if (error) return \"tracesPerQuery.\" + error;\n      }\n    }\n\n    if (message.endTime != null && message.hasOwnProperty(\"endTime\")) {\n      var error = $root.google.protobuf.Timestamp.verify(message.endTime);\n      if (error) return \"endTime.\" + error;\n    }\n\n    return null;\n  };\n  /**\n   * Creates a plain object from a Report message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Report\n   * @static\n   * @param {Report} message Report\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Report.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n    if (options.objects || options.defaults) object.tracesPerQuery = {};\n\n    if (options.defaults) {\n      object.header = null;\n      object.endTime = null;\n    }\n\n    if (message.header != null && message.hasOwnProperty(\"header\")) object.header = $root.ReportHeader.toObject(message.header, options);\n    if (message.endTime != null && message.hasOwnProperty(\"endTime\")) object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);\n    var keys2;\n\n    if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {\n      object.tracesPerQuery = {};\n\n      for (var j = 0; j < keys2.length; ++j) object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);\n    }\n\n    return object;\n  };\n  /**\n   * Converts this Report to JSON.\n   * @function toJSON\n   * @memberof Report\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Report.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return Report;\n}();\n\n$root.ContextualizedStats = function () {\n  /**\n   * Properties of a ContextualizedStats.\n   * @exports IContextualizedStats\n   * @interface IContextualizedStats\n   * @property {IStatsContext|null} [context] ContextualizedStats context\n   * @property {IQueryLatencyStats|null} [queryLatencyStats] ContextualizedStats queryLatencyStats\n   * @property {Object.<string,ITypeStat>|null} [perTypeStat] ContextualizedStats perTypeStat\n   */\n\n  /**\n   * Constructs a new ContextualizedStats.\n   * @exports ContextualizedStats\n   * @classdesc Represents a ContextualizedStats.\n   * @implements IContextualizedStats\n   * @constructor\n   * @param {IContextualizedStats=} [properties] Properties to set\n   */\n  function ContextualizedStats(properties) {\n    this.perTypeStat = {};\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * ContextualizedStats context.\n   * @member {IStatsContext|null|undefined} context\n   * @memberof ContextualizedStats\n   * @instance\n   */\n\n\n  ContextualizedStats.prototype.context = null;\n  /**\n   * ContextualizedStats queryLatencyStats.\n   * @member {IQueryLatencyStats|null|undefined} queryLatencyStats\n   * @memberof ContextualizedStats\n   * @instance\n   */\n\n  ContextualizedStats.prototype.queryLatencyStats = null;\n  /**\n   * ContextualizedStats perTypeStat.\n   * @member {Object.<string,ITypeStat>} perTypeStat\n   * @memberof ContextualizedStats\n   * @instance\n   */\n\n  ContextualizedStats.prototype.perTypeStat = $util.emptyObject;\n  /**\n   * Creates a new ContextualizedStats instance using the specified properties.\n   * @function create\n   * @memberof ContextualizedStats\n   * @static\n   * @param {IContextualizedStats=} [properties] Properties to set\n   * @returns {ContextualizedStats} ContextualizedStats instance\n   */\n\n  ContextualizedStats.create = function create(properties) {\n    return new ContextualizedStats(properties);\n  };\n  /**\n   * Encodes the specified ContextualizedStats message. Does not implicitly {@link ContextualizedStats.verify|verify} messages.\n   * @function encode\n   * @memberof ContextualizedStats\n   * @static\n   * @param {IContextualizedStats} message ContextualizedStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  ContextualizedStats.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.context != null && Object.hasOwnProperty.call(message, \"context\")) $root.StatsContext.encode(message.context, writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).fork()).ldelim();\n    if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, \"queryLatencyStats\")) $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(\n    /* id 2, wireType 2 =*/\n    18).fork()).ldelim();\n    if (message.perTypeStat != null && Object.hasOwnProperty.call(message, \"perTypeStat\")) for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {\n      writer.uint32(\n      /* id 3, wireType 2 =*/\n      26).fork().uint32(\n      /* id 1, wireType 2 =*/\n      10).string(keys[i]);\n      $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork()).ldelim().ldelim();\n    }\n    return writer;\n  };\n  /**\n   * Encodes the specified ContextualizedStats message, length delimited. Does not implicitly {@link ContextualizedStats.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof ContextualizedStats\n   * @static\n   * @param {IContextualizedStats} message ContextualizedStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  ContextualizedStats.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a ContextualizedStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof ContextualizedStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {ContextualizedStats} ContextualizedStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  ContextualizedStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.ContextualizedStats(),\n        key;\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.context = $root.StatsContext.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          reader.skip().pos++;\n          if (message.perTypeStat === $util.emptyObject) message.perTypeStat = {};\n          key = reader.string();\n          reader.pos++;\n          message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a ContextualizedStats message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof ContextualizedStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {ContextualizedStats} ContextualizedStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  ContextualizedStats.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a ContextualizedStats message.\n   * @function verify\n   * @memberof ContextualizedStats\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  ContextualizedStats.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.context != null && message.hasOwnProperty(\"context\")) {\n      var error = $root.StatsContext.verify(message.context);\n      if (error) return \"context.\" + error;\n    }\n\n    if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\")) {\n      var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);\n      if (error) return \"queryLatencyStats.\" + error;\n    }\n\n    if (message.perTypeStat != null && message.hasOwnProperty(\"perTypeStat\")) {\n      if (!$util.isObject(message.perTypeStat)) return \"perTypeStat: object expected\";\n      var key = Object.keys(message.perTypeStat);\n\n      for (var i = 0; i < key.length; ++i) {\n        var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);\n        if (error) return \"perTypeStat.\" + error;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Creates a plain object from a ContextualizedStats message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof ContextualizedStats\n   * @static\n   * @param {ContextualizedStats} message ContextualizedStats\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  ContextualizedStats.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n    if (options.objects || options.defaults) object.perTypeStat = {};\n\n    if (options.defaults) {\n      object.context = null;\n      object.queryLatencyStats = null;\n    }\n\n    if (message.context != null && message.hasOwnProperty(\"context\")) object.context = $root.StatsContext.toObject(message.context, options);\n    if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\")) object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);\n    var keys2;\n\n    if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {\n      object.perTypeStat = {};\n\n      for (var j = 0; j < keys2.length; ++j) object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);\n    }\n\n    return object;\n  };\n  /**\n   * Converts this ContextualizedStats to JSON.\n   * @function toJSON\n   * @memberof ContextualizedStats\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  ContextualizedStats.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return ContextualizedStats;\n}();\n\n$root.TracesAndStats = function () {\n  /**\n   * Properties of a TracesAndStats.\n   * @exports ITracesAndStats\n   * @interface ITracesAndStats\n   * @property {Array.<ITrace|Uint8Array>|null} [trace] TracesAndStats trace\n   * @property {$protobuf.ToArray.<IContextualizedStats>|Array.<IContextualizedStats>|null} [statsWithContext] TracesAndStats statsWithContext\n   * @property {Array.<ITrace|Uint8Array>|null} [internalTracesContributingToStats] TracesAndStats internalTracesContributingToStats\n   */\n\n  /**\n   * Constructs a new TracesAndStats.\n   * @exports TracesAndStats\n   * @classdesc Represents a TracesAndStats.\n   * @implements ITracesAndStats\n   * @constructor\n   * @param {ITracesAndStats=} [properties] Properties to set\n   */\n  function TracesAndStats(properties) {\n    this.trace = [];\n    this.statsWithContext = [];\n    this.internalTracesContributingToStats = [];\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * TracesAndStats trace.\n   * @member {Array.<ITrace|Uint8Array>} trace\n   * @memberof TracesAndStats\n   * @instance\n   */\n\n\n  TracesAndStats.prototype.trace = $util.emptyArray;\n  /**\n   * TracesAndStats statsWithContext.\n   * @member {Array.<IContextualizedStats>} statsWithContext\n   * @memberof TracesAndStats\n   * @instance\n   */\n\n  TracesAndStats.prototype.statsWithContext = $util.emptyArray;\n  /**\n   * TracesAndStats internalTracesContributingToStats.\n   * @member {Array.<ITrace|Uint8Array>} internalTracesContributingToStats\n   * @memberof TracesAndStats\n   * @instance\n   */\n\n  TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;\n  /**\n   * Creates a new TracesAndStats instance using the specified properties.\n   * @function create\n   * @memberof TracesAndStats\n   * @static\n   * @param {ITracesAndStats=} [properties] Properties to set\n   * @returns {TracesAndStats} TracesAndStats instance\n   */\n\n  TracesAndStats.create = function create(properties) {\n    return new TracesAndStats(properties);\n  };\n  /**\n   * Encodes the specified TracesAndStats message. Does not implicitly {@link TracesAndStats.verify|verify} messages.\n   * @function encode\n   * @memberof TracesAndStats\n   * @static\n   * @param {ITracesAndStats} message TracesAndStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  TracesAndStats.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.trace != null && message.trace.length) for (var i = 0; i < message.trace.length; ++i) if (message.trace[i] instanceof Uint8Array) {\n      writer.uint32(\n      /* id 1, wireType 2 =*/\n      10);\n      writer.bytes(message.trace[i]);\n    } else $root.Trace.encode(message.trace[i], writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).fork()).ldelim();\n    var array2;\n    if (message.statsWithContext != null && message.statsWithContext.toArray) array2 = message.statsWithContext.toArray();else array2 = message.statsWithContext;\n    if (array2 != null && array2.length) for (var i = 0; i < array2.length; ++i) $root.ContextualizedStats.encode(array2[i], writer.uint32(\n    /* id 2, wireType 2 =*/\n    18).fork()).ldelim();\n    if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length) for (var i = 0; i < message.internalTracesContributingToStats.length; ++i) if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {\n      writer.uint32(\n      /* id 3, wireType 2 =*/\n      26);\n      writer.bytes(message.internalTracesContributingToStats[i]);\n    } else $root.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(\n    /* id 3, wireType 2 =*/\n    26).fork()).ldelim();\n    return writer;\n  };\n  /**\n   * Encodes the specified TracesAndStats message, length delimited. Does not implicitly {@link TracesAndStats.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof TracesAndStats\n   * @static\n   * @param {ITracesAndStats} message TracesAndStats message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  TracesAndStats.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a TracesAndStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof TracesAndStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {TracesAndStats} TracesAndStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  TracesAndStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.TracesAndStats();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.trace && message.trace.length)) message.trace = [];\n          message.trace.push($root.Trace.decode(reader, reader.uint32()));\n          break;\n\n        case 2:\n          if (!(message.statsWithContext && message.statsWithContext.length)) message.statsWithContext = [];\n          message.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));\n          break;\n\n        case 3:\n          if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length)) message.internalTracesContributingToStats = [];\n          message.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a TracesAndStats message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof TracesAndStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {TracesAndStats} TracesAndStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  TracesAndStats.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a TracesAndStats message.\n   * @function verify\n   * @memberof TracesAndStats\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  TracesAndStats.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.trace != null && message.hasOwnProperty(\"trace\")) {\n      if (!Array.isArray(message.trace)) return \"trace: array expected\";\n\n      for (var i = 0; i < message.trace.length; ++i) if (!(message.trace[i] instanceof Uint8Array)) {\n        var error = $root.Trace.verify(message.trace[i]);\n        if (error) return \"trace.\" + error;\n      }\n    }\n\n    if (message.statsWithContext != null && message.hasOwnProperty(\"statsWithContext\")) {\n      var array2;\n      if (message.statsWithContext != null && message.statsWithContext.toArray) array2 = message.statsWithContext.toArray();else array2 = message.statsWithContext;\n      if (!Array.isArray(array2)) return \"statsWithContext: array expected\";\n\n      for (var i = 0; i < array2.length; ++i) {\n        var error = $root.ContextualizedStats.verify(array2[i]);\n        if (error) return \"statsWithContext.\" + error;\n      }\n    }\n\n    if (message.internalTracesContributingToStats != null && message.hasOwnProperty(\"internalTracesContributingToStats\")) {\n      if (!Array.isArray(message.internalTracesContributingToStats)) return \"internalTracesContributingToStats: array expected\";\n\n      for (var i = 0; i < message.internalTracesContributingToStats.length; ++i) if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {\n        var error = $root.Trace.verify(message.internalTracesContributingToStats[i]);\n        if (error) return \"internalTracesContributingToStats.\" + error;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Creates a plain object from a TracesAndStats message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof TracesAndStats\n   * @static\n   * @param {TracesAndStats} message TracesAndStats\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  TracesAndStats.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.arrays || options.defaults) {\n      object.trace = [];\n      object.statsWithContext = [];\n      object.internalTracesContributingToStats = [];\n    }\n\n    if (message.trace && message.trace.length) {\n      object.trace = [];\n\n      for (var j = 0; j < message.trace.length; ++j) object.trace[j] = $root.Trace.toObject(message.trace[j], options);\n    }\n\n    if (message.statsWithContext && message.statsWithContext.length) {\n      object.statsWithContext = [];\n\n      for (var j = 0; j < message.statsWithContext.length; ++j) object.statsWithContext[j] = $root.ContextualizedStats.toObject(message.statsWithContext[j], options);\n    }\n\n    if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {\n      object.internalTracesContributingToStats = [];\n\n      for (var j = 0; j < message.internalTracesContributingToStats.length; ++j) object.internalTracesContributingToStats[j] = $root.Trace.toObject(message.internalTracesContributingToStats[j], options);\n    }\n\n    return object;\n  };\n  /**\n   * Converts this TracesAndStats to JSON.\n   * @function toJSON\n   * @memberof TracesAndStats\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  TracesAndStats.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return TracesAndStats;\n}();\n\n$root.google = function () {\n  /**\n   * Namespace google.\n   * @exports google\n   * @namespace\n   */\n  var google = {};\n\n  google.protobuf = function () {\n    /**\n     * Namespace protobuf.\n     * @memberof google\n     * @namespace\n     */\n    var protobuf = {};\n\n    protobuf.Timestamp = function () {\n      /**\n       * Properties of a Timestamp.\n       * @memberof google.protobuf\n       * @interface ITimestamp\n       * @property {number|null} [seconds] Timestamp seconds\n       * @property {number|null} [nanos] Timestamp nanos\n       */\n\n      /**\n       * Constructs a new Timestamp.\n       * @memberof google.protobuf\n       * @classdesc Represents a Timestamp.\n       * @implements ITimestamp\n       * @constructor\n       * @param {google.protobuf.ITimestamp=} [properties] Properties to set\n       */\n      function Timestamp(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * Timestamp seconds.\n       * @member {number} seconds\n       * @memberof google.protobuf.Timestamp\n       * @instance\n       */\n\n\n      Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n      /**\n       * Timestamp nanos.\n       * @member {number} nanos\n       * @memberof google.protobuf.Timestamp\n       * @instance\n       */\n\n      Timestamp.prototype.nanos = 0;\n      /**\n       * Creates a new Timestamp instance using the specified properties.\n       * @function create\n       * @memberof google.protobuf.Timestamp\n       * @static\n       * @param {google.protobuf.ITimestamp=} [properties] Properties to set\n       * @returns {google.protobuf.Timestamp} Timestamp instance\n       */\n\n      Timestamp.create = function create(properties) {\n        return new Timestamp(properties);\n      };\n      /**\n       * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.\n       * @function encode\n       * @memberof google.protobuf.Timestamp\n       * @static\n       * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      Timestamp.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\")) writer.uint32(\n        /* id 1, wireType 0 =*/\n        8).int64(message.seconds);\n        if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\")) writer.uint32(\n        /* id 2, wireType 0 =*/\n        16).int32(message.nanos);\n        return writer;\n      };\n      /**\n       * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof google.protobuf.Timestamp\n       * @static\n       * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      Timestamp.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a Timestamp message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.Timestamp\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.Timestamp} Timestamp\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      Timestamp.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.Timestamp();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.seconds = reader.int64();\n              break;\n\n            case 2:\n              message.nanos = reader.int32();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a Timestamp message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof google.protobuf.Timestamp\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {google.protobuf.Timestamp} Timestamp\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      Timestamp.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a Timestamp message.\n       * @function verify\n       * @memberof google.protobuf.Timestamp\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      Timestamp.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n        if (message.seconds != null && message.hasOwnProperty(\"seconds\")) if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high))) return \"seconds: integer|Long expected\";\n        if (message.nanos != null && message.hasOwnProperty(\"nanos\")) if (!$util.isInteger(message.nanos)) return \"nanos: integer expected\";\n        return null;\n      };\n      /**\n       * Creates a plain object from a Timestamp message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof google.protobuf.Timestamp\n       * @static\n       * @param {google.protobuf.Timestamp} message Timestamp\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      Timestamp.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n\n        if (options.defaults) {\n          if ($util.Long) {\n            var long = new $util.Long(0, 0, false);\n            object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n          } else object.seconds = options.longs === String ? \"0\" : 0;\n\n          object.nanos = 0;\n        }\n\n        if (message.seconds != null && message.hasOwnProperty(\"seconds\")) if (typeof message.seconds === \"number\") object.seconds = options.longs === String ? String(message.seconds) : message.seconds;else object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;\n        if (message.nanos != null && message.hasOwnProperty(\"nanos\")) object.nanos = message.nanos;\n        return object;\n      };\n      /**\n       * Converts this Timestamp to JSON.\n       * @function toJSON\n       * @memberof google.protobuf.Timestamp\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      Timestamp.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return Timestamp;\n    }();\n\n    return protobuf;\n  }();\n\n  return google;\n}();\n\nmodule.exports = $root;","map":{"version":3,"sources":["C:/Users/Sallam/Desktop/projects/next-step/server/node_modules/apollo-reporting-protobuf/dist/protobuf.js"],"names":["$protobuf","require","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","Trace","properties","keys","Object","i","length","prototype","startTime","endTime","durationNs","Long","fromBits","root","signature","unexecutedOperationBody","unexecutedOperationName","details","clientName","clientVersion","clientAddress","clientReferenceId","http","cachePolicy","queryPlan","fullQueryCacheHit","persistedQueryHit","persistedQueryRegister","registeredOperation","forbiddenOperation","create","encode","message","writer","hasOwnProperty","call","google","protobuf","Timestamp","uint32","fork","ldelim","Details","string","HTTP","uint64","Node","CachePolicy","bool","QueryPlanNode","encodeDelimited","decode","reader","end","undefined","len","pos","tag","skipType","decodeDelimited","verify","error","isInteger","low","high","isString","toObject","options","object","defaults","long","longs","String","toString","Number","toNumber","LongBits","toJSON","constructor","toJSONOptions","scope","maxAgeNs","int32","int64","enums","Scope","valuesById","values","variablesJson","emptyObject","operationName","key","skip","isObject","objects","keys2","j","Error","location","emptyArray","timeNs","json","Location","push","Array","isArray","arrays","requestHeaders","responseHeaders","method","host","path","statusCode","secure","protocol","Values","Method","value","line","column","child","responseName","index","originalFieldName","type","parentType","$oneOfFields","defineProperty","get","oneOfGetter","set","oneOfSetter","id","oneofs","sequence","parallel","fetch","flatten","SequenceNode","ParallelNode","FetchNode","FlattenNode","node","nodes","serviceName","traceParsingFailed","trace","sentTimeOffset","sentTime","receivedTime","responsePath","ResponsePathElement","fieldName","ReportHeader","graphRef","hostname","agentVersion","serviceVersion","runtimeVersion","uname","executableSchemaId","PathErrorStats","children","errorsCount","requestsWithErrorsCount","QueryLatencyStats","latencyCount","cacheLatencyCount","publicCacheTtlCount","privateCacheTtlCount","requestCount","cacheHits","persistedQueryHits","persistedQueryMisses","rootErrorStats","registeredOperationCount","forbiddenOperationCount","array13","toArray","sint64","array14","array15","array16","end2","StatsContext","ContextualizedQueryLatencyStats","queryLatencyStats","context","ContextualizedTypeStats","perTypeStat","TypeStat","FieldStat","returnType","count","array9","perFieldStat","Field","name","Type","field","Report","tracesPerQuery","header","TracesAndStats","ContextualizedStats","statsWithContext","internalTracesContributingToStats","Uint8Array","bytes","array2","seconds","nanos","module","exports"],"mappings":"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","sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"@apollo/protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.Trace = (function() {\n\n    /**\n     * Properties of a Trace.\n     * @exports ITrace\n     * @interface ITrace\n     * @property {google.protobuf.ITimestamp|null} [startTime] Trace startTime\n     * @property {google.protobuf.ITimestamp|null} [endTime] Trace endTime\n     * @property {number|null} [durationNs] Trace durationNs\n     * @property {Trace.INode|null} [root] Trace root\n     * @property {string|null} [signature] Trace signature\n     * @property {string|null} [unexecutedOperationBody] Trace unexecutedOperationBody\n     * @property {string|null} [unexecutedOperationName] Trace unexecutedOperationName\n     * @property {Trace.IDetails|null} [details] Trace details\n     * @property {string|null} [clientName] Trace clientName\n     * @property {string|null} [clientVersion] Trace clientVersion\n     * @property {string|null} [clientAddress] Trace clientAddress\n     * @property {string|null} [clientReferenceId] Trace clientReferenceId\n     * @property {Trace.IHTTP|null} [http] Trace http\n     * @property {Trace.ICachePolicy|null} [cachePolicy] Trace cachePolicy\n     * @property {Trace.IQueryPlanNode|null} [queryPlan] Trace queryPlan\n     * @property {boolean|null} [fullQueryCacheHit] Trace fullQueryCacheHit\n     * @property {boolean|null} [persistedQueryHit] Trace persistedQueryHit\n     * @property {boolean|null} [persistedQueryRegister] Trace persistedQueryRegister\n     * @property {boolean|null} [registeredOperation] Trace registeredOperation\n     * @property {boolean|null} [forbiddenOperation] Trace forbiddenOperation\n     */\n\n    /**\n     * Constructs a new Trace.\n     * @exports Trace\n     * @classdesc Represents a Trace.\n     * @implements ITrace\n     * @constructor\n     * @param {ITrace=} [properties] Properties to set\n     */\n    function Trace(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Trace startTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} startTime\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.startTime = null;\n\n    /**\n     * Trace endTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} endTime\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.endTime = null;\n\n    /**\n     * Trace durationNs.\n     * @member {number} durationNs\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.durationNs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Trace root.\n     * @member {Trace.INode|null|undefined} root\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.root = null;\n\n    /**\n     * Trace signature.\n     * @member {string} signature\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.signature = \"\";\n\n    /**\n     * Trace unexecutedOperationBody.\n     * @member {string} unexecutedOperationBody\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.unexecutedOperationBody = \"\";\n\n    /**\n     * Trace unexecutedOperationName.\n     * @member {string} unexecutedOperationName\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.unexecutedOperationName = \"\";\n\n    /**\n     * Trace details.\n     * @member {Trace.IDetails|null|undefined} details\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.details = null;\n\n    /**\n     * Trace clientName.\n     * @member {string} clientName\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.clientName = \"\";\n\n    /**\n     * Trace clientVersion.\n     * @member {string} clientVersion\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.clientVersion = \"\";\n\n    /**\n     * Trace clientAddress.\n     * @member {string} clientAddress\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.clientAddress = \"\";\n\n    /**\n     * Trace clientReferenceId.\n     * @member {string} clientReferenceId\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.clientReferenceId = \"\";\n\n    /**\n     * Trace http.\n     * @member {Trace.IHTTP|null|undefined} http\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.http = null;\n\n    /**\n     * Trace cachePolicy.\n     * @member {Trace.ICachePolicy|null|undefined} cachePolicy\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.cachePolicy = null;\n\n    /**\n     * Trace queryPlan.\n     * @member {Trace.IQueryPlanNode|null|undefined} queryPlan\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.queryPlan = null;\n\n    /**\n     * Trace fullQueryCacheHit.\n     * @member {boolean} fullQueryCacheHit\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.fullQueryCacheHit = false;\n\n    /**\n     * Trace persistedQueryHit.\n     * @member {boolean} persistedQueryHit\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.persistedQueryHit = false;\n\n    /**\n     * Trace persistedQueryRegister.\n     * @member {boolean} persistedQueryRegister\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.persistedQueryRegister = false;\n\n    /**\n     * Trace registeredOperation.\n     * @member {boolean} registeredOperation\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.registeredOperation = false;\n\n    /**\n     * Trace forbiddenOperation.\n     * @member {boolean} forbiddenOperation\n     * @memberof Trace\n     * @instance\n     */\n    Trace.prototype.forbiddenOperation = false;\n\n    /**\n     * Creates a new Trace instance using the specified properties.\n     * @function create\n     * @memberof Trace\n     * @static\n     * @param {ITrace=} [properties] Properties to set\n     * @returns {Trace} Trace instance\n     */\n    Trace.create = function create(properties) {\n        return new Trace(properties);\n    };\n\n    /**\n     * Encodes the specified Trace message. Does not implicitly {@link Trace.verify|verify} messages.\n     * @function encode\n     * @memberof Trace\n     * @static\n     * @param {ITrace} message Trace message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Trace.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.endTime != null && Object.hasOwnProperty.call(message, \"endTime\"))\n            $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        if (message.startTime != null && Object.hasOwnProperty.call(message, \"startTime\"))\n            $root.google.protobuf.Timestamp.encode(message.startTime, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n        if (message.details != null && Object.hasOwnProperty.call(message, \"details\"))\n            $root.Trace.Details.encode(message.details, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n        if (message.clientName != null && Object.hasOwnProperty.call(message, \"clientName\"))\n            writer.uint32(/* id 7, wireType 2 =*/58).string(message.clientName);\n        if (message.clientVersion != null && Object.hasOwnProperty.call(message, \"clientVersion\"))\n            writer.uint32(/* id 8, wireType 2 =*/66).string(message.clientVersion);\n        if (message.clientAddress != null && Object.hasOwnProperty.call(message, \"clientAddress\"))\n            writer.uint32(/* id 9, wireType 2 =*/74).string(message.clientAddress);\n        if (message.http != null && Object.hasOwnProperty.call(message, \"http\"))\n            $root.Trace.HTTP.encode(message.http, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n        if (message.durationNs != null && Object.hasOwnProperty.call(message, \"durationNs\"))\n            writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.durationNs);\n        if (message.root != null && Object.hasOwnProperty.call(message, \"root\"))\n            $root.Trace.Node.encode(message.root, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n        if (message.cachePolicy != null && Object.hasOwnProperty.call(message, \"cachePolicy\"))\n            $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();\n        if (message.signature != null && Object.hasOwnProperty.call(message, \"signature\"))\n            writer.uint32(/* id 19, wireType 2 =*/154).string(message.signature);\n        if (message.fullQueryCacheHit != null && Object.hasOwnProperty.call(message, \"fullQueryCacheHit\"))\n            writer.uint32(/* id 20, wireType 0 =*/160).bool(message.fullQueryCacheHit);\n        if (message.persistedQueryHit != null && Object.hasOwnProperty.call(message, \"persistedQueryHit\"))\n            writer.uint32(/* id 21, wireType 0 =*/168).bool(message.persistedQueryHit);\n        if (message.persistedQueryRegister != null && Object.hasOwnProperty.call(message, \"persistedQueryRegister\"))\n            writer.uint32(/* id 22, wireType 0 =*/176).bool(message.persistedQueryRegister);\n        if (message.clientReferenceId != null && Object.hasOwnProperty.call(message, \"clientReferenceId\"))\n            writer.uint32(/* id 23, wireType 2 =*/186).string(message.clientReferenceId);\n        if (message.registeredOperation != null && Object.hasOwnProperty.call(message, \"registeredOperation\"))\n            writer.uint32(/* id 24, wireType 0 =*/192).bool(message.registeredOperation);\n        if (message.forbiddenOperation != null && Object.hasOwnProperty.call(message, \"forbiddenOperation\"))\n            writer.uint32(/* id 25, wireType 0 =*/200).bool(message.forbiddenOperation);\n        if (message.queryPlan != null && Object.hasOwnProperty.call(message, \"queryPlan\"))\n            $root.Trace.QueryPlanNode.encode(message.queryPlan, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();\n        if (message.unexecutedOperationBody != null && Object.hasOwnProperty.call(message, \"unexecutedOperationBody\"))\n            writer.uint32(/* id 27, wireType 2 =*/218).string(message.unexecutedOperationBody);\n        if (message.unexecutedOperationName != null && Object.hasOwnProperty.call(message, \"unexecutedOperationName\"))\n            writer.uint32(/* id 28, wireType 2 =*/226).string(message.unexecutedOperationName);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Trace message, length delimited. Does not implicitly {@link Trace.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Trace\n     * @static\n     * @param {ITrace} message Trace message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Trace.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Trace message from the specified reader or buffer.\n     * @function decode\n     * @memberof Trace\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Trace} Trace\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Trace.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 4:\n                message.startTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 3:\n                message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            case 11:\n                message.durationNs = reader.uint64();\n                break;\n            case 14:\n                message.root = $root.Trace.Node.decode(reader, reader.uint32());\n                break;\n            case 19:\n                message.signature = reader.string();\n                break;\n            case 27:\n                message.unexecutedOperationBody = reader.string();\n                break;\n            case 28:\n                message.unexecutedOperationName = reader.string();\n                break;\n            case 6:\n                message.details = $root.Trace.Details.decode(reader, reader.uint32());\n                break;\n            case 7:\n                message.clientName = reader.string();\n                break;\n            case 8:\n                message.clientVersion = reader.string();\n                break;\n            case 9:\n                message.clientAddress = reader.string();\n                break;\n            case 23:\n                message.clientReferenceId = reader.string();\n                break;\n            case 10:\n                message.http = $root.Trace.HTTP.decode(reader, reader.uint32());\n                break;\n            case 18:\n                message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());\n                break;\n            case 26:\n                message.queryPlan = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());\n                break;\n            case 20:\n                message.fullQueryCacheHit = reader.bool();\n                break;\n            case 21:\n                message.persistedQueryHit = reader.bool();\n                break;\n            case 22:\n                message.persistedQueryRegister = reader.bool();\n                break;\n            case 24:\n                message.registeredOperation = reader.bool();\n                break;\n            case 25:\n                message.forbiddenOperation = reader.bool();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Trace message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Trace\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Trace} Trace\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Trace.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Trace message.\n     * @function verify\n     * @memberof Trace\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Trace.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.startTime != null && message.hasOwnProperty(\"startTime\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.startTime);\n            if (error)\n                return \"startTime.\" + error;\n        }\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.endTime);\n            if (error)\n                return \"endTime.\" + error;\n        }\n        if (message.durationNs != null && message.hasOwnProperty(\"durationNs\"))\n            if (!$util.isInteger(message.durationNs) && !(message.durationNs && $util.isInteger(message.durationNs.low) && $util.isInteger(message.durationNs.high)))\n                return \"durationNs: integer|Long expected\";\n        if (message.root != null && message.hasOwnProperty(\"root\")) {\n            var error = $root.Trace.Node.verify(message.root);\n            if (error)\n                return \"root.\" + error;\n        }\n        if (message.signature != null && message.hasOwnProperty(\"signature\"))\n            if (!$util.isString(message.signature))\n                return \"signature: string expected\";\n        if (message.unexecutedOperationBody != null && message.hasOwnProperty(\"unexecutedOperationBody\"))\n            if (!$util.isString(message.unexecutedOperationBody))\n                return \"unexecutedOperationBody: string expected\";\n        if (message.unexecutedOperationName != null && message.hasOwnProperty(\"unexecutedOperationName\"))\n            if (!$util.isString(message.unexecutedOperationName))\n                return \"unexecutedOperationName: string expected\";\n        if (message.details != null && message.hasOwnProperty(\"details\")) {\n            var error = $root.Trace.Details.verify(message.details);\n            if (error)\n                return \"details.\" + error;\n        }\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            if (!$util.isString(message.clientName))\n                return \"clientName: string expected\";\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            if (!$util.isString(message.clientVersion))\n                return \"clientVersion: string expected\";\n        if (message.clientAddress != null && message.hasOwnProperty(\"clientAddress\"))\n            if (!$util.isString(message.clientAddress))\n                return \"clientAddress: string expected\";\n        if (message.clientReferenceId != null && message.hasOwnProperty(\"clientReferenceId\"))\n            if (!$util.isString(message.clientReferenceId))\n                return \"clientReferenceId: string expected\";\n        if (message.http != null && message.hasOwnProperty(\"http\")) {\n            var error = $root.Trace.HTTP.verify(message.http);\n            if (error)\n                return \"http.\" + error;\n        }\n        if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\")) {\n            var error = $root.Trace.CachePolicy.verify(message.cachePolicy);\n            if (error)\n                return \"cachePolicy.\" + error;\n        }\n        if (message.queryPlan != null && message.hasOwnProperty(\"queryPlan\")) {\n            var error = $root.Trace.QueryPlanNode.verify(message.queryPlan);\n            if (error)\n                return \"queryPlan.\" + error;\n        }\n        if (message.fullQueryCacheHit != null && message.hasOwnProperty(\"fullQueryCacheHit\"))\n            if (typeof message.fullQueryCacheHit !== \"boolean\")\n                return \"fullQueryCacheHit: boolean expected\";\n        if (message.persistedQueryHit != null && message.hasOwnProperty(\"persistedQueryHit\"))\n            if (typeof message.persistedQueryHit !== \"boolean\")\n                return \"persistedQueryHit: boolean expected\";\n        if (message.persistedQueryRegister != null && message.hasOwnProperty(\"persistedQueryRegister\"))\n            if (typeof message.persistedQueryRegister !== \"boolean\")\n                return \"persistedQueryRegister: boolean expected\";\n        if (message.registeredOperation != null && message.hasOwnProperty(\"registeredOperation\"))\n            if (typeof message.registeredOperation !== \"boolean\")\n                return \"registeredOperation: boolean expected\";\n        if (message.forbiddenOperation != null && message.hasOwnProperty(\"forbiddenOperation\"))\n            if (typeof message.forbiddenOperation !== \"boolean\")\n                return \"forbiddenOperation: boolean expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a Trace message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Trace\n     * @static\n     * @param {Trace} message Trace\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Trace.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.endTime = null;\n            object.startTime = null;\n            object.details = null;\n            object.clientName = \"\";\n            object.clientVersion = \"\";\n            object.clientAddress = \"\";\n            object.http = null;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.durationNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.durationNs = options.longs === String ? \"0\" : 0;\n            object.root = null;\n            object.cachePolicy = null;\n            object.signature = \"\";\n            object.fullQueryCacheHit = false;\n            object.persistedQueryHit = false;\n            object.persistedQueryRegister = false;\n            object.clientReferenceId = \"\";\n            object.registeredOperation = false;\n            object.forbiddenOperation = false;\n            object.queryPlan = null;\n            object.unexecutedOperationBody = \"\";\n            object.unexecutedOperationName = \"\";\n        }\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n            object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);\n        if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n            object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);\n        if (message.details != null && message.hasOwnProperty(\"details\"))\n            object.details = $root.Trace.Details.toObject(message.details, options);\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            object.clientName = message.clientName;\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            object.clientVersion = message.clientVersion;\n        if (message.clientAddress != null && message.hasOwnProperty(\"clientAddress\"))\n            object.clientAddress = message.clientAddress;\n        if (message.http != null && message.hasOwnProperty(\"http\"))\n            object.http = $root.Trace.HTTP.toObject(message.http, options);\n        if (message.durationNs != null && message.hasOwnProperty(\"durationNs\"))\n            if (typeof message.durationNs === \"number\")\n                object.durationNs = options.longs === String ? String(message.durationNs) : message.durationNs;\n            else\n                object.durationNs = options.longs === String ? $util.Long.prototype.toString.call(message.durationNs) : options.longs === Number ? new $util.LongBits(message.durationNs.low >>> 0, message.durationNs.high >>> 0).toNumber(true) : message.durationNs;\n        if (message.root != null && message.hasOwnProperty(\"root\"))\n            object.root = $root.Trace.Node.toObject(message.root, options);\n        if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\"))\n            object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);\n        if (message.signature != null && message.hasOwnProperty(\"signature\"))\n            object.signature = message.signature;\n        if (message.fullQueryCacheHit != null && message.hasOwnProperty(\"fullQueryCacheHit\"))\n            object.fullQueryCacheHit = message.fullQueryCacheHit;\n        if (message.persistedQueryHit != null && message.hasOwnProperty(\"persistedQueryHit\"))\n            object.persistedQueryHit = message.persistedQueryHit;\n        if (message.persistedQueryRegister != null && message.hasOwnProperty(\"persistedQueryRegister\"))\n            object.persistedQueryRegister = message.persistedQueryRegister;\n        if (message.clientReferenceId != null && message.hasOwnProperty(\"clientReferenceId\"))\n            object.clientReferenceId = message.clientReferenceId;\n        if (message.registeredOperation != null && message.hasOwnProperty(\"registeredOperation\"))\n            object.registeredOperation = message.registeredOperation;\n        if (message.forbiddenOperation != null && message.hasOwnProperty(\"forbiddenOperation\"))\n            object.forbiddenOperation = message.forbiddenOperation;\n        if (message.queryPlan != null && message.hasOwnProperty(\"queryPlan\"))\n            object.queryPlan = $root.Trace.QueryPlanNode.toObject(message.queryPlan, options);\n        if (message.unexecutedOperationBody != null && message.hasOwnProperty(\"unexecutedOperationBody\"))\n            object.unexecutedOperationBody = message.unexecutedOperationBody;\n        if (message.unexecutedOperationName != null && message.hasOwnProperty(\"unexecutedOperationName\"))\n            object.unexecutedOperationName = message.unexecutedOperationName;\n        return object;\n    };\n\n    /**\n     * Converts this Trace to JSON.\n     * @function toJSON\n     * @memberof Trace\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Trace.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    Trace.CachePolicy = (function() {\n\n        /**\n         * Properties of a CachePolicy.\n         * @memberof Trace\n         * @interface ICachePolicy\n         * @property {Trace.CachePolicy.Scope|null} [scope] CachePolicy scope\n         * @property {number|null} [maxAgeNs] CachePolicy maxAgeNs\n         */\n\n        /**\n         * Constructs a new CachePolicy.\n         * @memberof Trace\n         * @classdesc Represents a CachePolicy.\n         * @implements ICachePolicy\n         * @constructor\n         * @param {Trace.ICachePolicy=} [properties] Properties to set\n         */\n        function CachePolicy(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CachePolicy scope.\n         * @member {Trace.CachePolicy.Scope} scope\n         * @memberof Trace.CachePolicy\n         * @instance\n         */\n        CachePolicy.prototype.scope = 0;\n\n        /**\n         * CachePolicy maxAgeNs.\n         * @member {number} maxAgeNs\n         * @memberof Trace.CachePolicy\n         * @instance\n         */\n        CachePolicy.prototype.maxAgeNs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n        /**\n         * Creates a new CachePolicy instance using the specified properties.\n         * @function create\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.ICachePolicy=} [properties] Properties to set\n         * @returns {Trace.CachePolicy} CachePolicy instance\n         */\n        CachePolicy.create = function create(properties) {\n            return new CachePolicy(properties);\n        };\n\n        /**\n         * Encodes the specified CachePolicy message. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.ICachePolicy} message CachePolicy message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CachePolicy.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.scope != null && Object.hasOwnProperty.call(message, \"scope\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scope);\n            if (message.maxAgeNs != null && Object.hasOwnProperty.call(message, \"maxAgeNs\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.maxAgeNs);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CachePolicy message, length delimited. Does not implicitly {@link Trace.CachePolicy.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.ICachePolicy} message CachePolicy message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CachePolicy.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CachePolicy message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.CachePolicy} CachePolicy\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CachePolicy.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.CachePolicy();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.scope = reader.int32();\n                    break;\n                case 2:\n                    message.maxAgeNs = reader.int64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CachePolicy message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.CachePolicy} CachePolicy\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CachePolicy.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CachePolicy message.\n         * @function verify\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CachePolicy.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                switch (message.scope) {\n                default:\n                    return \"scope: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                    break;\n                }\n            if (message.maxAgeNs != null && message.hasOwnProperty(\"maxAgeNs\"))\n                if (!$util.isInteger(message.maxAgeNs) && !(message.maxAgeNs && $util.isInteger(message.maxAgeNs.low) && $util.isInteger(message.maxAgeNs.high)))\n                    return \"maxAgeNs: integer|Long expected\";\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a CachePolicy message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.CachePolicy\n         * @static\n         * @param {Trace.CachePolicy} message CachePolicy\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CachePolicy.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.scope = options.enums === String ? \"UNKNOWN\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, false);\n                    object.maxAgeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.maxAgeNs = options.longs === String ? \"0\" : 0;\n            }\n            if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                object.scope = options.enums === String ? $root.Trace.CachePolicy.Scope[message.scope] : message.scope;\n            if (message.maxAgeNs != null && message.hasOwnProperty(\"maxAgeNs\"))\n                if (typeof message.maxAgeNs === \"number\")\n                    object.maxAgeNs = options.longs === String ? String(message.maxAgeNs) : message.maxAgeNs;\n                else\n                    object.maxAgeNs = options.longs === String ? $util.Long.prototype.toString.call(message.maxAgeNs) : options.longs === Number ? new $util.LongBits(message.maxAgeNs.low >>> 0, message.maxAgeNs.high >>> 0).toNumber() : message.maxAgeNs;\n            return object;\n        };\n\n        /**\n         * Converts this CachePolicy to JSON.\n         * @function toJSON\n         * @memberof Trace.CachePolicy\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CachePolicy.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        /**\n         * Scope enum.\n         * @name Trace.CachePolicy.Scope\n         * @enum {string}\n         * @property {number} UNKNOWN=0 UNKNOWN value\n         * @property {number} PUBLIC=1 PUBLIC value\n         * @property {number} PRIVATE=2 PRIVATE value\n         */\n        CachePolicy.Scope = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"UNKNOWN\"] = 0;\n            values[valuesById[1] = \"PUBLIC\"] = 1;\n            values[valuesById[2] = \"PRIVATE\"] = 2;\n            return values;\n        })();\n\n        return CachePolicy;\n    })();\n\n    Trace.Details = (function() {\n\n        /**\n         * Properties of a Details.\n         * @memberof Trace\n         * @interface IDetails\n         * @property {Object.<string,string>|null} [variablesJson] Details variablesJson\n         * @property {string|null} [operationName] Details operationName\n         */\n\n        /**\n         * Constructs a new Details.\n         * @memberof Trace\n         * @classdesc Represents a Details.\n         * @implements IDetails\n         * @constructor\n         * @param {Trace.IDetails=} [properties] Properties to set\n         */\n        function Details(properties) {\n            this.variablesJson = {};\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Details variablesJson.\n         * @member {Object.<string,string>} variablesJson\n         * @memberof Trace.Details\n         * @instance\n         */\n        Details.prototype.variablesJson = $util.emptyObject;\n\n        /**\n         * Details operationName.\n         * @member {string} operationName\n         * @memberof Trace.Details\n         * @instance\n         */\n        Details.prototype.operationName = \"\";\n\n        /**\n         * Creates a new Details instance using the specified properties.\n         * @function create\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.IDetails=} [properties] Properties to set\n         * @returns {Trace.Details} Details instance\n         */\n        Details.create = function create(properties) {\n            return new Details(properties);\n        };\n\n        /**\n         * Encodes the specified Details message. Does not implicitly {@link Trace.Details.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.IDetails} message Details message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Details.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.operationName != null && Object.hasOwnProperty.call(message, \"operationName\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.operationName);\n            if (message.variablesJson != null && Object.hasOwnProperty.call(message, \"variablesJson\"))\n                for (var keys = Object.keys(message.variablesJson), i = 0; i < keys.length; ++i)\n                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.variablesJson[keys[i]]).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Details message, length delimited. Does not implicitly {@link Trace.Details.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.IDetails} message Details message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Details.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Details message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Details\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Details} Details\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Details.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Details(), key;\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 4:\n                    reader.skip().pos++;\n                    if (message.variablesJson === $util.emptyObject)\n                        message.variablesJson = {};\n                    key = reader.string();\n                    reader.pos++;\n                    message.variablesJson[key] = reader.string();\n                    break;\n                case 3:\n                    message.operationName = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Details message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Details\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Details} Details\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Details.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Details message.\n         * @function verify\n         * @memberof Trace.Details\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Details.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.variablesJson != null && message.hasOwnProperty(\"variablesJson\")) {\n                if (!$util.isObject(message.variablesJson))\n                    return \"variablesJson: object expected\";\n                var key = Object.keys(message.variablesJson);\n                for (var i = 0; i < key.length; ++i)\n                    if (!$util.isString(message.variablesJson[key[i]]))\n                        return \"variablesJson: string{k:string} expected\";\n            }\n            if (message.operationName != null && message.hasOwnProperty(\"operationName\"))\n                if (!$util.isString(message.operationName))\n                    return \"operationName: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a Details message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Details\n         * @static\n         * @param {Trace.Details} message Details\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Details.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.objects || options.defaults)\n                object.variablesJson = {};\n            if (options.defaults)\n                object.operationName = \"\";\n            if (message.operationName != null && message.hasOwnProperty(\"operationName\"))\n                object.operationName = message.operationName;\n            var keys2;\n            if (message.variablesJson && (keys2 = Object.keys(message.variablesJson)).length) {\n                object.variablesJson = {};\n                for (var j = 0; j < keys2.length; ++j)\n                    object.variablesJson[keys2[j]] = message.variablesJson[keys2[j]];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this Details to JSON.\n         * @function toJSON\n         * @memberof Trace.Details\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Details.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Details;\n    })();\n\n    Trace.Error = (function() {\n\n        /**\n         * Properties of an Error.\n         * @memberof Trace\n         * @interface IError\n         * @property {string|null} [message] Error message\n         * @property {Array.<Trace.ILocation>|null} [location] Error location\n         * @property {number|null} [timeNs] Error timeNs\n         * @property {string|null} [json] Error json\n         */\n\n        /**\n         * Constructs a new Error.\n         * @memberof Trace\n         * @classdesc Represents an Error.\n         * @implements IError\n         * @constructor\n         * @param {Trace.IError=} [properties] Properties to set\n         */\n        function Error(properties) {\n            this.location = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Error message.\n         * @member {string} message\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.message = \"\";\n\n        /**\n         * Error location.\n         * @member {Array.<Trace.ILocation>} location\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.location = $util.emptyArray;\n\n        /**\n         * Error timeNs.\n         * @member {number} timeNs\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.timeNs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n        /**\n         * Error json.\n         * @member {string} json\n         * @memberof Trace.Error\n         * @instance\n         */\n        Error.prototype.json = \"\";\n\n        /**\n         * Creates a new Error instance using the specified properties.\n         * @function create\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.IError=} [properties] Properties to set\n         * @returns {Trace.Error} Error instance\n         */\n        Error.create = function create(properties) {\n            return new Error(properties);\n        };\n\n        /**\n         * Encodes the specified Error message. Does not implicitly {@link Trace.Error.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.IError} message Error message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Error.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.message != null && Object.hasOwnProperty.call(message, \"message\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);\n            if (message.location != null && message.location.length)\n                for (var i = 0; i < message.location.length; ++i)\n                    $root.Trace.Location.encode(message.location[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.timeNs != null && Object.hasOwnProperty.call(message, \"timeNs\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timeNs);\n            if (message.json != null && Object.hasOwnProperty.call(message, \"json\"))\n                writer.uint32(/* id 4, wireType 2 =*/34).string(message.json);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Error message, length delimited. Does not implicitly {@link Trace.Error.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.IError} message Error message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Error.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an Error message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Error\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Error} Error\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Error.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Error();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.message = reader.string();\n                    break;\n                case 2:\n                    if (!(message.location && message.location.length))\n                        message.location = [];\n                    message.location.push($root.Trace.Location.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.timeNs = reader.uint64();\n                    break;\n                case 4:\n                    message.json = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an Error message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Error\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Error} Error\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Error.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an Error message.\n         * @function verify\n         * @memberof Trace.Error\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Error.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                if (!$util.isString(message.message))\n                    return \"message: string expected\";\n            if (message.location != null && message.hasOwnProperty(\"location\")) {\n                if (!Array.isArray(message.location))\n                    return \"location: array expected\";\n                for (var i = 0; i < message.location.length; ++i) {\n                    var error = $root.Trace.Location.verify(message.location[i]);\n                    if (error)\n                        return \"location.\" + error;\n                }\n            }\n            if (message.timeNs != null && message.hasOwnProperty(\"timeNs\"))\n                if (!$util.isInteger(message.timeNs) && !(message.timeNs && $util.isInteger(message.timeNs.low) && $util.isInteger(message.timeNs.high)))\n                    return \"timeNs: integer|Long expected\";\n            if (message.json != null && message.hasOwnProperty(\"json\"))\n                if (!$util.isString(message.json))\n                    return \"json: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a plain object from an Error message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Error\n         * @static\n         * @param {Trace.Error} message Error\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Error.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.location = [];\n            if (options.defaults) {\n                object.message = \"\";\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, true);\n                    object.timeNs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.timeNs = options.longs === String ? \"0\" : 0;\n                object.json = \"\";\n            }\n            if (message.message != null && message.hasOwnProperty(\"message\"))\n                object.message = message.message;\n            if (message.location && message.location.length) {\n                object.location = [];\n                for (var j = 0; j < message.location.length; ++j)\n                    object.location[j] = $root.Trace.Location.toObject(message.location[j], options);\n            }\n            if (message.timeNs != null && message.hasOwnProperty(\"timeNs\"))\n                if (typeof message.timeNs === \"number\")\n                    object.timeNs = options.longs === String ? String(message.timeNs) : message.timeNs;\n                else\n                    object.timeNs = options.longs === String ? $util.Long.prototype.toString.call(message.timeNs) : options.longs === Number ? new $util.LongBits(message.timeNs.low >>> 0, message.timeNs.high >>> 0).toNumber(true) : message.timeNs;\n            if (message.json != null && message.hasOwnProperty(\"json\"))\n                object.json = message.json;\n            return object;\n        };\n\n        /**\n         * Converts this Error to JSON.\n         * @function toJSON\n         * @memberof Trace.Error\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Error.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Error;\n    })();\n\n    Trace.HTTP = (function() {\n\n        /**\n         * Properties of a HTTP.\n         * @memberof Trace\n         * @interface IHTTP\n         * @property {Trace.HTTP.Method|null} [method] HTTP method\n         * @property {string|null} [host] HTTP host\n         * @property {string|null} [path] HTTP path\n         * @property {Object.<string,Trace.HTTP.IValues>|null} [requestHeaders] HTTP requestHeaders\n         * @property {Object.<string,Trace.HTTP.IValues>|null} [responseHeaders] HTTP responseHeaders\n         * @property {number|null} [statusCode] HTTP statusCode\n         * @property {boolean|null} [secure] HTTP secure\n         * @property {string|null} [protocol] HTTP protocol\n         */\n\n        /**\n         * Constructs a new HTTP.\n         * @memberof Trace\n         * @classdesc Represents a HTTP.\n         * @implements IHTTP\n         * @constructor\n         * @param {Trace.IHTTP=} [properties] Properties to set\n         */\n        function HTTP(properties) {\n            this.requestHeaders = {};\n            this.responseHeaders = {};\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * HTTP method.\n         * @member {Trace.HTTP.Method} method\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.method = 0;\n\n        /**\n         * HTTP host.\n         * @member {string} host\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.host = \"\";\n\n        /**\n         * HTTP path.\n         * @member {string} path\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.path = \"\";\n\n        /**\n         * HTTP requestHeaders.\n         * @member {Object.<string,Trace.HTTP.IValues>} requestHeaders\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.requestHeaders = $util.emptyObject;\n\n        /**\n         * HTTP responseHeaders.\n         * @member {Object.<string,Trace.HTTP.IValues>} responseHeaders\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.responseHeaders = $util.emptyObject;\n\n        /**\n         * HTTP statusCode.\n         * @member {number} statusCode\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.statusCode = 0;\n\n        /**\n         * HTTP secure.\n         * @member {boolean} secure\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.secure = false;\n\n        /**\n         * HTTP protocol.\n         * @member {string} protocol\n         * @memberof Trace.HTTP\n         * @instance\n         */\n        HTTP.prototype.protocol = \"\";\n\n        /**\n         * Creates a new HTTP instance using the specified properties.\n         * @function create\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.IHTTP=} [properties] Properties to set\n         * @returns {Trace.HTTP} HTTP instance\n         */\n        HTTP.create = function create(properties) {\n            return new HTTP(properties);\n        };\n\n        /**\n         * Encodes the specified HTTP message. Does not implicitly {@link Trace.HTTP.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.IHTTP} message HTTP message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HTTP.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.method != null && Object.hasOwnProperty.call(message, \"method\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.method);\n            if (message.host != null && Object.hasOwnProperty.call(message, \"host\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);\n            if (message.path != null && Object.hasOwnProperty.call(message, \"path\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.path);\n            if (message.requestHeaders != null && Object.hasOwnProperty.call(message, \"requestHeaders\"))\n                for (var keys = Object.keys(message.requestHeaders), i = 0; i < keys.length; ++i) {\n                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                    $root.Trace.HTTP.Values.encode(message.requestHeaders[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                }\n            if (message.responseHeaders != null && Object.hasOwnProperty.call(message, \"responseHeaders\"))\n                for (var keys = Object.keys(message.responseHeaders), i = 0; i < keys.length; ++i) {\n                    writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                    $root.Trace.HTTP.Values.encode(message.responseHeaders[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                }\n            if (message.statusCode != null && Object.hasOwnProperty.call(message, \"statusCode\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.statusCode);\n            if (message.secure != null && Object.hasOwnProperty.call(message, \"secure\"))\n                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.secure);\n            if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                writer.uint32(/* id 9, wireType 2 =*/74).string(message.protocol);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified HTTP message, length delimited. Does not implicitly {@link Trace.HTTP.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.IHTTP} message HTTP message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        HTTP.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a HTTP message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.HTTP\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.HTTP} HTTP\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HTTP.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.HTTP(), key;\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.method = reader.int32();\n                    break;\n                case 2:\n                    message.host = reader.string();\n                    break;\n                case 3:\n                    message.path = reader.string();\n                    break;\n                case 4:\n                    reader.skip().pos++;\n                    if (message.requestHeaders === $util.emptyObject)\n                        message.requestHeaders = {};\n                    key = reader.string();\n                    reader.pos++;\n                    message.requestHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    reader.skip().pos++;\n                    if (message.responseHeaders === $util.emptyObject)\n                        message.responseHeaders = {};\n                    key = reader.string();\n                    reader.pos++;\n                    message.responseHeaders[key] = $root.Trace.HTTP.Values.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.statusCode = reader.uint32();\n                    break;\n                case 8:\n                    message.secure = reader.bool();\n                    break;\n                case 9:\n                    message.protocol = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a HTTP message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.HTTP\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.HTTP} HTTP\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        HTTP.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a HTTP message.\n         * @function verify\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        HTTP.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.method != null && message.hasOwnProperty(\"method\"))\n                switch (message.method) {\n                default:\n                    return \"method: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                case 9:\n                    break;\n                }\n            if (message.host != null && message.hasOwnProperty(\"host\"))\n                if (!$util.isString(message.host))\n                    return \"host: string expected\";\n            if (message.path != null && message.hasOwnProperty(\"path\"))\n                if (!$util.isString(message.path))\n                    return \"path: string expected\";\n            if (message.requestHeaders != null && message.hasOwnProperty(\"requestHeaders\")) {\n                if (!$util.isObject(message.requestHeaders))\n                    return \"requestHeaders: object expected\";\n                var key = Object.keys(message.requestHeaders);\n                for (var i = 0; i < key.length; ++i) {\n                    var error = $root.Trace.HTTP.Values.verify(message.requestHeaders[key[i]]);\n                    if (error)\n                        return \"requestHeaders.\" + error;\n                }\n            }\n            if (message.responseHeaders != null && message.hasOwnProperty(\"responseHeaders\")) {\n                if (!$util.isObject(message.responseHeaders))\n                    return \"responseHeaders: object expected\";\n                var key = Object.keys(message.responseHeaders);\n                for (var i = 0; i < key.length; ++i) {\n                    var error = $root.Trace.HTTP.Values.verify(message.responseHeaders[key[i]]);\n                    if (error)\n                        return \"responseHeaders.\" + error;\n                }\n            }\n            if (message.statusCode != null && message.hasOwnProperty(\"statusCode\"))\n                if (!$util.isInteger(message.statusCode))\n                    return \"statusCode: integer expected\";\n            if (message.secure != null && message.hasOwnProperty(\"secure\"))\n                if (typeof message.secure !== \"boolean\")\n                    return \"secure: boolean expected\";\n            if (message.protocol != null && message.hasOwnProperty(\"protocol\"))\n                if (!$util.isString(message.protocol))\n                    return \"protocol: string expected\";\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a HTTP message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.HTTP\n         * @static\n         * @param {Trace.HTTP} message HTTP\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        HTTP.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.objects || options.defaults) {\n                object.requestHeaders = {};\n                object.responseHeaders = {};\n            }\n            if (options.defaults) {\n                object.method = options.enums === String ? \"UNKNOWN\" : 0;\n                object.host = \"\";\n                object.path = \"\";\n                object.statusCode = 0;\n                object.secure = false;\n                object.protocol = \"\";\n            }\n            if (message.method != null && message.hasOwnProperty(\"method\"))\n                object.method = options.enums === String ? $root.Trace.HTTP.Method[message.method] : message.method;\n            if (message.host != null && message.hasOwnProperty(\"host\"))\n                object.host = message.host;\n            if (message.path != null && message.hasOwnProperty(\"path\"))\n                object.path = message.path;\n            var keys2;\n            if (message.requestHeaders && (keys2 = Object.keys(message.requestHeaders)).length) {\n                object.requestHeaders = {};\n                for (var j = 0; j < keys2.length; ++j)\n                    object.requestHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.requestHeaders[keys2[j]], options);\n            }\n            if (message.responseHeaders && (keys2 = Object.keys(message.responseHeaders)).length) {\n                object.responseHeaders = {};\n                for (var j = 0; j < keys2.length; ++j)\n                    object.responseHeaders[keys2[j]] = $root.Trace.HTTP.Values.toObject(message.responseHeaders[keys2[j]], options);\n            }\n            if (message.statusCode != null && message.hasOwnProperty(\"statusCode\"))\n                object.statusCode = message.statusCode;\n            if (message.secure != null && message.hasOwnProperty(\"secure\"))\n                object.secure = message.secure;\n            if (message.protocol != null && message.hasOwnProperty(\"protocol\"))\n                object.protocol = message.protocol;\n            return object;\n        };\n\n        /**\n         * Converts this HTTP to JSON.\n         * @function toJSON\n         * @memberof Trace.HTTP\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        HTTP.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        HTTP.Values = (function() {\n\n            /**\n             * Properties of a Values.\n             * @memberof Trace.HTTP\n             * @interface IValues\n             * @property {Array.<string>|null} [value] Values value\n             */\n\n            /**\n             * Constructs a new Values.\n             * @memberof Trace.HTTP\n             * @classdesc Represents a Values.\n             * @implements IValues\n             * @constructor\n             * @param {Trace.HTTP.IValues=} [properties] Properties to set\n             */\n            function Values(properties) {\n                this.value = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Values value.\n             * @member {Array.<string>} value\n             * @memberof Trace.HTTP.Values\n             * @instance\n             */\n            Values.prototype.value = $util.emptyArray;\n\n            /**\n             * Creates a new Values instance using the specified properties.\n             * @function create\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.IValues=} [properties] Properties to set\n             * @returns {Trace.HTTP.Values} Values instance\n             */\n            Values.create = function create(properties) {\n                return new Values(properties);\n            };\n\n            /**\n             * Encodes the specified Values message. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.IValues} message Values message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Values.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.value != null && message.value.length)\n                    for (var i = 0; i < message.value.length; ++i)\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.value[i]);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Values message, length delimited. Does not implicitly {@link Trace.HTTP.Values.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.IValues} message Values message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Values.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Values message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.HTTP.Values} Values\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Values.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.HTTP.Values();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.value && message.value.length))\n                            message.value = [];\n                        message.value.push(reader.string());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Values message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.HTTP.Values} Values\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Values.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Values message.\n             * @function verify\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Values.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.value != null && message.hasOwnProperty(\"value\")) {\n                    if (!Array.isArray(message.value))\n                        return \"value: array expected\";\n                    for (var i = 0; i < message.value.length; ++i)\n                        if (!$util.isString(message.value[i]))\n                            return \"value: string[] expected\";\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a Values message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.HTTP.Values\n             * @static\n             * @param {Trace.HTTP.Values} message Values\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Values.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.value = [];\n                if (message.value && message.value.length) {\n                    object.value = [];\n                    for (var j = 0; j < message.value.length; ++j)\n                        object.value[j] = message.value[j];\n                }\n                return object;\n            };\n\n            /**\n             * Converts this Values to JSON.\n             * @function toJSON\n             * @memberof Trace.HTTP.Values\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Values.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Values;\n        })();\n\n        /**\n         * Method enum.\n         * @name Trace.HTTP.Method\n         * @enum {string}\n         * @property {number} UNKNOWN=0 UNKNOWN value\n         * @property {number} OPTIONS=1 OPTIONS value\n         * @property {number} GET=2 GET value\n         * @property {number} HEAD=3 HEAD value\n         * @property {number} POST=4 POST value\n         * @property {number} PUT=5 PUT value\n         * @property {number} DELETE=6 DELETE value\n         * @property {number} TRACE=7 TRACE value\n         * @property {number} CONNECT=8 CONNECT value\n         * @property {number} PATCH=9 PATCH value\n         */\n        HTTP.Method = (function() {\n            var valuesById = {}, values = Object.create(valuesById);\n            values[valuesById[0] = \"UNKNOWN\"] = 0;\n            values[valuesById[1] = \"OPTIONS\"] = 1;\n            values[valuesById[2] = \"GET\"] = 2;\n            values[valuesById[3] = \"HEAD\"] = 3;\n            values[valuesById[4] = \"POST\"] = 4;\n            values[valuesById[5] = \"PUT\"] = 5;\n            values[valuesById[6] = \"DELETE\"] = 6;\n            values[valuesById[7] = \"TRACE\"] = 7;\n            values[valuesById[8] = \"CONNECT\"] = 8;\n            values[valuesById[9] = \"PATCH\"] = 9;\n            return values;\n        })();\n\n        return HTTP;\n    })();\n\n    Trace.Location = (function() {\n\n        /**\n         * Properties of a Location.\n         * @memberof Trace\n         * @interface ILocation\n         * @property {number|null} [line] Location line\n         * @property {number|null} [column] Location column\n         */\n\n        /**\n         * Constructs a new Location.\n         * @memberof Trace\n         * @classdesc Represents a Location.\n         * @implements ILocation\n         * @constructor\n         * @param {Trace.ILocation=} [properties] Properties to set\n         */\n        function Location(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Location line.\n         * @member {number} line\n         * @memberof Trace.Location\n         * @instance\n         */\n        Location.prototype.line = 0;\n\n        /**\n         * Location column.\n         * @member {number} column\n         * @memberof Trace.Location\n         * @instance\n         */\n        Location.prototype.column = 0;\n\n        /**\n         * Creates a new Location instance using the specified properties.\n         * @function create\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.ILocation=} [properties] Properties to set\n         * @returns {Trace.Location} Location instance\n         */\n        Location.create = function create(properties) {\n            return new Location(properties);\n        };\n\n        /**\n         * Encodes the specified Location message. Does not implicitly {@link Trace.Location.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.ILocation} message Location message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Location.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.line != null && Object.hasOwnProperty.call(message, \"line\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.line);\n            if (message.column != null && Object.hasOwnProperty.call(message, \"column\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.column);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Location message, length delimited. Does not implicitly {@link Trace.Location.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.ILocation} message Location message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Location.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Location message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Location\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Location} Location\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Location.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Location();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.line = reader.uint32();\n                    break;\n                case 2:\n                    message.column = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Location message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Location\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Location} Location\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Location.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Location message.\n         * @function verify\n         * @memberof Trace.Location\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Location.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.line != null && message.hasOwnProperty(\"line\"))\n                if (!$util.isInteger(message.line))\n                    return \"line: integer expected\";\n            if (message.column != null && message.hasOwnProperty(\"column\"))\n                if (!$util.isInteger(message.column))\n                    return \"column: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a Location message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Location\n         * @static\n         * @param {Trace.Location} message Location\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Location.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.line = 0;\n                object.column = 0;\n            }\n            if (message.line != null && message.hasOwnProperty(\"line\"))\n                object.line = message.line;\n            if (message.column != null && message.hasOwnProperty(\"column\"))\n                object.column = message.column;\n            return object;\n        };\n\n        /**\n         * Converts this Location to JSON.\n         * @function toJSON\n         * @memberof Trace.Location\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Location.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Location;\n    })();\n\n    Trace.Node = (function() {\n\n        /**\n         * Properties of a Node.\n         * @memberof Trace\n         * @interface INode\n         * @property {string|null} [responseName] Node responseName\n         * @property {number|null} [index] Node index\n         * @property {string|null} [originalFieldName] Node originalFieldName\n         * @property {string|null} [type] Node type\n         * @property {string|null} [parentType] Node parentType\n         * @property {Trace.ICachePolicy|null} [cachePolicy] Node cachePolicy\n         * @property {number|null} [startTime] Node startTime\n         * @property {number|null} [endTime] Node endTime\n         * @property {Array.<Trace.IError>|null} [error] Node error\n         * @property {Array.<Trace.INode>|null} [child] Node child\n         */\n\n        /**\n         * Constructs a new Node.\n         * @memberof Trace\n         * @classdesc Represents a Node.\n         * @implements INode\n         * @constructor\n         * @param {Trace.INode=} [properties] Properties to set\n         */\n        function Node(properties) {\n            this.error = [];\n            this.child = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * Node responseName.\n         * @member {string} responseName\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.responseName = \"\";\n\n        /**\n         * Node index.\n         * @member {number} index\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.index = 0;\n\n        /**\n         * Node originalFieldName.\n         * @member {string} originalFieldName\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.originalFieldName = \"\";\n\n        /**\n         * Node type.\n         * @member {string} type\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.type = \"\";\n\n        /**\n         * Node parentType.\n         * @member {string} parentType\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.parentType = \"\";\n\n        /**\n         * Node cachePolicy.\n         * @member {Trace.ICachePolicy|null|undefined} cachePolicy\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.cachePolicy = null;\n\n        /**\n         * Node startTime.\n         * @member {number} startTime\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n        /**\n         * Node endTime.\n         * @member {number} endTime\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n        /**\n         * Node error.\n         * @member {Array.<Trace.IError>} error\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.error = $util.emptyArray;\n\n        /**\n         * Node child.\n         * @member {Array.<Trace.INode>} child\n         * @memberof Trace.Node\n         * @instance\n         */\n        Node.prototype.child = $util.emptyArray;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * Node id.\n         * @member {\"responseName\"|\"index\"|undefined} id\n         * @memberof Trace.Node\n         * @instance\n         */\n        Object.defineProperty(Node.prototype, \"id\", {\n            get: $util.oneOfGetter($oneOfFields = [\"responseName\", \"index\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new Node instance using the specified properties.\n         * @function create\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.INode=} [properties] Properties to set\n         * @returns {Trace.Node} Node instance\n         */\n        Node.create = function create(properties) {\n            return new Node(properties);\n        };\n\n        /**\n         * Encodes the specified Node message. Does not implicitly {@link Trace.Node.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.INode} message Node message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Node.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.responseName != null && Object.hasOwnProperty.call(message, \"responseName\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).string(message.responseName);\n            if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n            if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);\n            if (message.cachePolicy != null && Object.hasOwnProperty.call(message, \"cachePolicy\"))\n                $root.Trace.CachePolicy.encode(message.cachePolicy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n            if (message.startTime != null && Object.hasOwnProperty.call(message, \"startTime\"))\n                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.startTime);\n            if (message.endTime != null && Object.hasOwnProperty.call(message, \"endTime\"))\n                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.endTime);\n            if (message.error != null && message.error.length)\n                for (var i = 0; i < message.error.length; ++i)\n                    $root.Trace.Error.encode(message.error[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n            if (message.child != null && message.child.length)\n                for (var i = 0; i < message.child.length; ++i)\n                    $root.Trace.Node.encode(message.child[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();\n            if (message.parentType != null && Object.hasOwnProperty.call(message, \"parentType\"))\n                writer.uint32(/* id 13, wireType 2 =*/106).string(message.parentType);\n            if (message.originalFieldName != null && Object.hasOwnProperty.call(message, \"originalFieldName\"))\n                writer.uint32(/* id 14, wireType 2 =*/114).string(message.originalFieldName);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified Node message, length delimited. Does not implicitly {@link Trace.Node.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.INode} message Node message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        Node.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a Node message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.Node\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.Node} Node\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Node.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.Node();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.responseName = reader.string();\n                    break;\n                case 2:\n                    message.index = reader.uint32();\n                    break;\n                case 14:\n                    message.originalFieldName = reader.string();\n                    break;\n                case 3:\n                    message.type = reader.string();\n                    break;\n                case 13:\n                    message.parentType = reader.string();\n                    break;\n                case 5:\n                    message.cachePolicy = $root.Trace.CachePolicy.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.startTime = reader.uint64();\n                    break;\n                case 9:\n                    message.endTime = reader.uint64();\n                    break;\n                case 11:\n                    if (!(message.error && message.error.length))\n                        message.error = [];\n                    message.error.push($root.Trace.Error.decode(reader, reader.uint32()));\n                    break;\n                case 12:\n                    if (!(message.child && message.child.length))\n                        message.child = [];\n                    message.child.push($root.Trace.Node.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a Node message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.Node\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.Node} Node\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Node.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a Node message.\n         * @function verify\n         * @memberof Trace.Node\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        Node.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.responseName != null && message.hasOwnProperty(\"responseName\")) {\n                properties.id = 1;\n                if (!$util.isString(message.responseName))\n                    return \"responseName: string expected\";\n            }\n            if (message.index != null && message.hasOwnProperty(\"index\")) {\n                if (properties.id === 1)\n                    return \"id: multiple values\";\n                properties.id = 1;\n                if (!$util.isInteger(message.index))\n                    return \"index: integer expected\";\n            }\n            if (message.originalFieldName != null && message.hasOwnProperty(\"originalFieldName\"))\n                if (!$util.isString(message.originalFieldName))\n                    return \"originalFieldName: string expected\";\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                if (!$util.isString(message.type))\n                    return \"type: string expected\";\n            if (message.parentType != null && message.hasOwnProperty(\"parentType\"))\n                if (!$util.isString(message.parentType))\n                    return \"parentType: string expected\";\n            if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\")) {\n                var error = $root.Trace.CachePolicy.verify(message.cachePolicy);\n                if (error)\n                    return \"cachePolicy.\" + error;\n            }\n            if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))\n                    return \"startTime: integer|Long expected\";\n            if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))\n                    return \"endTime: integer|Long expected\";\n            if (message.error != null && message.hasOwnProperty(\"error\")) {\n                if (!Array.isArray(message.error))\n                    return \"error: array expected\";\n                for (var i = 0; i < message.error.length; ++i) {\n                    var error = $root.Trace.Error.verify(message.error[i]);\n                    if (error)\n                        return \"error.\" + error;\n                }\n            }\n            if (message.child != null && message.hasOwnProperty(\"child\")) {\n                if (!Array.isArray(message.child))\n                    return \"child: array expected\";\n                for (var i = 0; i < message.child.length; ++i) {\n                    var error = $root.Trace.Node.verify(message.child[i]);\n                    if (error)\n                        return \"child.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a Node message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.Node\n         * @static\n         * @param {Trace.Node} message Node\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        Node.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.error = [];\n                object.child = [];\n            }\n            if (options.defaults) {\n                object.type = \"\";\n                object.cachePolicy = null;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, true);\n                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.startTime = options.longs === String ? \"0\" : 0;\n                if ($util.Long) {\n                    var long = new $util.Long(0, 0, true);\n                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                } else\n                    object.endTime = options.longs === String ? \"0\" : 0;\n                object.parentType = \"\";\n                object.originalFieldName = \"\";\n            }\n            if (message.responseName != null && message.hasOwnProperty(\"responseName\")) {\n                object.responseName = message.responseName;\n                if (options.oneofs)\n                    object.id = \"responseName\";\n            }\n            if (message.index != null && message.hasOwnProperty(\"index\")) {\n                object.index = message.index;\n                if (options.oneofs)\n                    object.id = \"index\";\n            }\n            if (message.type != null && message.hasOwnProperty(\"type\"))\n                object.type = message.type;\n            if (message.cachePolicy != null && message.hasOwnProperty(\"cachePolicy\"))\n                object.cachePolicy = $root.Trace.CachePolicy.toObject(message.cachePolicy, options);\n            if (message.startTime != null && message.hasOwnProperty(\"startTime\"))\n                if (typeof message.startTime === \"number\")\n                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;\n                else\n                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;\n            if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n                if (typeof message.endTime === \"number\")\n                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;\n                else\n                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;\n            if (message.error && message.error.length) {\n                object.error = [];\n                for (var j = 0; j < message.error.length; ++j)\n                    object.error[j] = $root.Trace.Error.toObject(message.error[j], options);\n            }\n            if (message.child && message.child.length) {\n                object.child = [];\n                for (var j = 0; j < message.child.length; ++j)\n                    object.child[j] = $root.Trace.Node.toObject(message.child[j], options);\n            }\n            if (message.parentType != null && message.hasOwnProperty(\"parentType\"))\n                object.parentType = message.parentType;\n            if (message.originalFieldName != null && message.hasOwnProperty(\"originalFieldName\"))\n                object.originalFieldName = message.originalFieldName;\n            return object;\n        };\n\n        /**\n         * Converts this Node to JSON.\n         * @function toJSON\n         * @memberof Trace.Node\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        Node.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return Node;\n    })();\n\n    Trace.QueryPlanNode = (function() {\n\n        /**\n         * Properties of a QueryPlanNode.\n         * @memberof Trace\n         * @interface IQueryPlanNode\n         * @property {Trace.QueryPlanNode.ISequenceNode|null} [sequence] QueryPlanNode sequence\n         * @property {Trace.QueryPlanNode.IParallelNode|null} [parallel] QueryPlanNode parallel\n         * @property {Trace.QueryPlanNode.IFetchNode|null} [fetch] QueryPlanNode fetch\n         * @property {Trace.QueryPlanNode.IFlattenNode|null} [flatten] QueryPlanNode flatten\n         */\n\n        /**\n         * Constructs a new QueryPlanNode.\n         * @memberof Trace\n         * @classdesc Represents a QueryPlanNode.\n         * @implements IQueryPlanNode\n         * @constructor\n         * @param {Trace.IQueryPlanNode=} [properties] Properties to set\n         */\n        function QueryPlanNode(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * QueryPlanNode sequence.\n         * @member {Trace.QueryPlanNode.ISequenceNode|null|undefined} sequence\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        QueryPlanNode.prototype.sequence = null;\n\n        /**\n         * QueryPlanNode parallel.\n         * @member {Trace.QueryPlanNode.IParallelNode|null|undefined} parallel\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        QueryPlanNode.prototype.parallel = null;\n\n        /**\n         * QueryPlanNode fetch.\n         * @member {Trace.QueryPlanNode.IFetchNode|null|undefined} fetch\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        QueryPlanNode.prototype.fetch = null;\n\n        /**\n         * QueryPlanNode flatten.\n         * @member {Trace.QueryPlanNode.IFlattenNode|null|undefined} flatten\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        QueryPlanNode.prototype.flatten = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * QueryPlanNode node.\n         * @member {\"sequence\"|\"parallel\"|\"fetch\"|\"flatten\"|undefined} node\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         */\n        Object.defineProperty(QueryPlanNode.prototype, \"node\", {\n            get: $util.oneOfGetter($oneOfFields = [\"sequence\", \"parallel\", \"fetch\", \"flatten\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new QueryPlanNode instance using the specified properties.\n         * @function create\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {Trace.IQueryPlanNode=} [properties] Properties to set\n         * @returns {Trace.QueryPlanNode} QueryPlanNode instance\n         */\n        QueryPlanNode.create = function create(properties) {\n            return new QueryPlanNode(properties);\n        };\n\n        /**\n         * Encodes the specified QueryPlanNode message. Does not implicitly {@link Trace.QueryPlanNode.verify|verify} messages.\n         * @function encode\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {Trace.IQueryPlanNode} message QueryPlanNode message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        QueryPlanNode.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.sequence != null && Object.hasOwnProperty.call(message, \"sequence\"))\n                $root.Trace.QueryPlanNode.SequenceNode.encode(message.sequence, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.parallel != null && Object.hasOwnProperty.call(message, \"parallel\"))\n                $root.Trace.QueryPlanNode.ParallelNode.encode(message.parallel, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.fetch != null && Object.hasOwnProperty.call(message, \"fetch\"))\n                $root.Trace.QueryPlanNode.FetchNode.encode(message.fetch, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.flatten != null && Object.hasOwnProperty.call(message, \"flatten\"))\n                $root.Trace.QueryPlanNode.FlattenNode.encode(message.flatten, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified QueryPlanNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {Trace.IQueryPlanNode} message QueryPlanNode message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        QueryPlanNode.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a QueryPlanNode message from the specified reader or buffer.\n         * @function decode\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Trace.QueryPlanNode} QueryPlanNode\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        QueryPlanNode.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.sequence = $root.Trace.QueryPlanNode.SequenceNode.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.parallel = $root.Trace.QueryPlanNode.ParallelNode.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.fetch = $root.Trace.QueryPlanNode.FetchNode.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.flatten = $root.Trace.QueryPlanNode.FlattenNode.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a QueryPlanNode message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {Trace.QueryPlanNode} QueryPlanNode\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        QueryPlanNode.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a QueryPlanNode message.\n         * @function verify\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        QueryPlanNode.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.sequence != null && message.hasOwnProperty(\"sequence\")) {\n                properties.node = 1;\n                {\n                    var error = $root.Trace.QueryPlanNode.SequenceNode.verify(message.sequence);\n                    if (error)\n                        return \"sequence.\" + error;\n                }\n            }\n            if (message.parallel != null && message.hasOwnProperty(\"parallel\")) {\n                if (properties.node === 1)\n                    return \"node: multiple values\";\n                properties.node = 1;\n                {\n                    var error = $root.Trace.QueryPlanNode.ParallelNode.verify(message.parallel);\n                    if (error)\n                        return \"parallel.\" + error;\n                }\n            }\n            if (message.fetch != null && message.hasOwnProperty(\"fetch\")) {\n                if (properties.node === 1)\n                    return \"node: multiple values\";\n                properties.node = 1;\n                {\n                    var error = $root.Trace.QueryPlanNode.FetchNode.verify(message.fetch);\n                    if (error)\n                        return \"fetch.\" + error;\n                }\n            }\n            if (message.flatten != null && message.hasOwnProperty(\"flatten\")) {\n                if (properties.node === 1)\n                    return \"node: multiple values\";\n                properties.node = 1;\n                {\n                    var error = $root.Trace.QueryPlanNode.FlattenNode.verify(message.flatten);\n                    if (error)\n                        return \"flatten.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a plain object from a QueryPlanNode message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof Trace.QueryPlanNode\n         * @static\n         * @param {Trace.QueryPlanNode} message QueryPlanNode\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        QueryPlanNode.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.sequence != null && message.hasOwnProperty(\"sequence\")) {\n                object.sequence = $root.Trace.QueryPlanNode.SequenceNode.toObject(message.sequence, options);\n                if (options.oneofs)\n                    object.node = \"sequence\";\n            }\n            if (message.parallel != null && message.hasOwnProperty(\"parallel\")) {\n                object.parallel = $root.Trace.QueryPlanNode.ParallelNode.toObject(message.parallel, options);\n                if (options.oneofs)\n                    object.node = \"parallel\";\n            }\n            if (message.fetch != null && message.hasOwnProperty(\"fetch\")) {\n                object.fetch = $root.Trace.QueryPlanNode.FetchNode.toObject(message.fetch, options);\n                if (options.oneofs)\n                    object.node = \"fetch\";\n            }\n            if (message.flatten != null && message.hasOwnProperty(\"flatten\")) {\n                object.flatten = $root.Trace.QueryPlanNode.FlattenNode.toObject(message.flatten, options);\n                if (options.oneofs)\n                    object.node = \"flatten\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this QueryPlanNode to JSON.\n         * @function toJSON\n         * @memberof Trace.QueryPlanNode\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        QueryPlanNode.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        QueryPlanNode.SequenceNode = (function() {\n\n            /**\n             * Properties of a SequenceNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface ISequenceNode\n             * @property {Array.<Trace.IQueryPlanNode>|null} [nodes] SequenceNode nodes\n             */\n\n            /**\n             * Constructs a new SequenceNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a SequenceNode.\n             * @implements ISequenceNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.ISequenceNode=} [properties] Properties to set\n             */\n            function SequenceNode(properties) {\n                this.nodes = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * SequenceNode nodes.\n             * @member {Array.<Trace.IQueryPlanNode>} nodes\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @instance\n             */\n            SequenceNode.prototype.nodes = $util.emptyArray;\n\n            /**\n             * Creates a new SequenceNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {Trace.QueryPlanNode.ISequenceNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.SequenceNode} SequenceNode instance\n             */\n            SequenceNode.create = function create(properties) {\n                return new SequenceNode(properties);\n            };\n\n            /**\n             * Encodes the specified SequenceNode message. Does not implicitly {@link Trace.QueryPlanNode.SequenceNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {Trace.QueryPlanNode.ISequenceNode} message SequenceNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SequenceNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.nodes != null && message.nodes.length)\n                    for (var i = 0; i < message.nodes.length; ++i)\n                        $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified SequenceNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.SequenceNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {Trace.QueryPlanNode.ISequenceNode} message SequenceNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SequenceNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a SequenceNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.SequenceNode} SequenceNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SequenceNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.SequenceNode();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.nodes && message.nodes.length))\n                            message.nodes = [];\n                        message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a SequenceNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.SequenceNode} SequenceNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SequenceNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a SequenceNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SequenceNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.nodes != null && message.hasOwnProperty(\"nodes\")) {\n                    if (!Array.isArray(message.nodes))\n                        return \"nodes: array expected\";\n                    for (var i = 0; i < message.nodes.length; ++i) {\n                        var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);\n                        if (error)\n                            return \"nodes.\" + error;\n                    }\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a SequenceNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @static\n             * @param {Trace.QueryPlanNode.SequenceNode} message SequenceNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SequenceNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.nodes = [];\n                if (message.nodes && message.nodes.length) {\n                    object.nodes = [];\n                    for (var j = 0; j < message.nodes.length; ++j)\n                        object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);\n                }\n                return object;\n            };\n\n            /**\n             * Converts this SequenceNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.SequenceNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SequenceNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return SequenceNode;\n        })();\n\n        QueryPlanNode.ParallelNode = (function() {\n\n            /**\n             * Properties of a ParallelNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface IParallelNode\n             * @property {Array.<Trace.IQueryPlanNode>|null} [nodes] ParallelNode nodes\n             */\n\n            /**\n             * Constructs a new ParallelNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a ParallelNode.\n             * @implements IParallelNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.IParallelNode=} [properties] Properties to set\n             */\n            function ParallelNode(properties) {\n                this.nodes = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * ParallelNode nodes.\n             * @member {Array.<Trace.IQueryPlanNode>} nodes\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @instance\n             */\n            ParallelNode.prototype.nodes = $util.emptyArray;\n\n            /**\n             * Creates a new ParallelNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {Trace.QueryPlanNode.IParallelNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.ParallelNode} ParallelNode instance\n             */\n            ParallelNode.create = function create(properties) {\n                return new ParallelNode(properties);\n            };\n\n            /**\n             * Encodes the specified ParallelNode message. Does not implicitly {@link Trace.QueryPlanNode.ParallelNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {Trace.QueryPlanNode.IParallelNode} message ParallelNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ParallelNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.nodes != null && message.nodes.length)\n                    for (var i = 0; i < message.nodes.length; ++i)\n                        $root.Trace.QueryPlanNode.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified ParallelNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.ParallelNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {Trace.QueryPlanNode.IParallelNode} message ParallelNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ParallelNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a ParallelNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.ParallelNode} ParallelNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ParallelNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ParallelNode();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.nodes && message.nodes.length))\n                            message.nodes = [];\n                        message.nodes.push($root.Trace.QueryPlanNode.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a ParallelNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.ParallelNode} ParallelNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ParallelNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a ParallelNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ParallelNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.nodes != null && message.hasOwnProperty(\"nodes\")) {\n                    if (!Array.isArray(message.nodes))\n                        return \"nodes: array expected\";\n                    for (var i = 0; i < message.nodes.length; ++i) {\n                        var error = $root.Trace.QueryPlanNode.verify(message.nodes[i]);\n                        if (error)\n                            return \"nodes.\" + error;\n                    }\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a ParallelNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @static\n             * @param {Trace.QueryPlanNode.ParallelNode} message ParallelNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ParallelNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.nodes = [];\n                if (message.nodes && message.nodes.length) {\n                    object.nodes = [];\n                    for (var j = 0; j < message.nodes.length; ++j)\n                        object.nodes[j] = $root.Trace.QueryPlanNode.toObject(message.nodes[j], options);\n                }\n                return object;\n            };\n\n            /**\n             * Converts this ParallelNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.ParallelNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ParallelNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ParallelNode;\n        })();\n\n        QueryPlanNode.FetchNode = (function() {\n\n            /**\n             * Properties of a FetchNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface IFetchNode\n             * @property {string|null} [serviceName] FetchNode serviceName\n             * @property {boolean|null} [traceParsingFailed] FetchNode traceParsingFailed\n             * @property {ITrace|null} [trace] FetchNode trace\n             * @property {number|null} [sentTimeOffset] FetchNode sentTimeOffset\n             * @property {google.protobuf.ITimestamp|null} [sentTime] FetchNode sentTime\n             * @property {google.protobuf.ITimestamp|null} [receivedTime] FetchNode receivedTime\n             */\n\n            /**\n             * Constructs a new FetchNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a FetchNode.\n             * @implements IFetchNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.IFetchNode=} [properties] Properties to set\n             */\n            function FetchNode(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * FetchNode serviceName.\n             * @member {string} serviceName\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.serviceName = \"\";\n\n            /**\n             * FetchNode traceParsingFailed.\n             * @member {boolean} traceParsingFailed\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.traceParsingFailed = false;\n\n            /**\n             * FetchNode trace.\n             * @member {ITrace|null|undefined} trace\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.trace = null;\n\n            /**\n             * FetchNode sentTimeOffset.\n             * @member {number} sentTimeOffset\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.sentTimeOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n            /**\n             * FetchNode sentTime.\n             * @member {google.protobuf.ITimestamp|null|undefined} sentTime\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.sentTime = null;\n\n            /**\n             * FetchNode receivedTime.\n             * @member {google.protobuf.ITimestamp|null|undefined} receivedTime\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             */\n            FetchNode.prototype.receivedTime = null;\n\n            /**\n             * Creates a new FetchNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFetchNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.FetchNode} FetchNode instance\n             */\n            FetchNode.create = function create(properties) {\n                return new FetchNode(properties);\n            };\n\n            /**\n             * Encodes the specified FetchNode message. Does not implicitly {@link Trace.QueryPlanNode.FetchNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFetchNode} message FetchNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            FetchNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.serviceName != null && Object.hasOwnProperty.call(message, \"serviceName\"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.serviceName);\n                if (message.traceParsingFailed != null && Object.hasOwnProperty.call(message, \"traceParsingFailed\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.traceParsingFailed);\n                if (message.trace != null && Object.hasOwnProperty.call(message, \"trace\"))\n                    $root.Trace.encode(message.trace, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                if (message.sentTimeOffset != null && Object.hasOwnProperty.call(message, \"sentTimeOffset\"))\n                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.sentTimeOffset);\n                if (message.sentTime != null && Object.hasOwnProperty.call(message, \"sentTime\"))\n                    $root.google.protobuf.Timestamp.encode(message.sentTime, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                if (message.receivedTime != null && Object.hasOwnProperty.call(message, \"receivedTime\"))\n                    $root.google.protobuf.Timestamp.encode(message.receivedTime, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified FetchNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.FetchNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFetchNode} message FetchNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            FetchNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a FetchNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.FetchNode} FetchNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FetchNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FetchNode();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.serviceName = reader.string();\n                        break;\n                    case 2:\n                        message.traceParsingFailed = reader.bool();\n                        break;\n                    case 3:\n                        message.trace = $root.Trace.decode(reader, reader.uint32());\n                        break;\n                    case 4:\n                        message.sentTimeOffset = reader.uint64();\n                        break;\n                    case 5:\n                        message.sentTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                        break;\n                    case 6:\n                        message.receivedTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a FetchNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.FetchNode} FetchNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FetchNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a FetchNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            FetchNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.serviceName != null && message.hasOwnProperty(\"serviceName\"))\n                    if (!$util.isString(message.serviceName))\n                        return \"serviceName: string expected\";\n                if (message.traceParsingFailed != null && message.hasOwnProperty(\"traceParsingFailed\"))\n                    if (typeof message.traceParsingFailed !== \"boolean\")\n                        return \"traceParsingFailed: boolean expected\";\n                if (message.trace != null && message.hasOwnProperty(\"trace\")) {\n                    var error = $root.Trace.verify(message.trace);\n                    if (error)\n                        return \"trace.\" + error;\n                }\n                if (message.sentTimeOffset != null && message.hasOwnProperty(\"sentTimeOffset\"))\n                    if (!$util.isInteger(message.sentTimeOffset) && !(message.sentTimeOffset && $util.isInteger(message.sentTimeOffset.low) && $util.isInteger(message.sentTimeOffset.high)))\n                        return \"sentTimeOffset: integer|Long expected\";\n                if (message.sentTime != null && message.hasOwnProperty(\"sentTime\")) {\n                    var error = $root.google.protobuf.Timestamp.verify(message.sentTime);\n                    if (error)\n                        return \"sentTime.\" + error;\n                }\n                if (message.receivedTime != null && message.hasOwnProperty(\"receivedTime\")) {\n                    var error = $root.google.protobuf.Timestamp.verify(message.receivedTime);\n                    if (error)\n                        return \"receivedTime.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a FetchNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @static\n             * @param {Trace.QueryPlanNode.FetchNode} message FetchNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            FetchNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    object.serviceName = \"\";\n                    object.traceParsingFailed = false;\n                    object.trace = null;\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, true);\n                        object.sentTimeOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.sentTimeOffset = options.longs === String ? \"0\" : 0;\n                    object.sentTime = null;\n                    object.receivedTime = null;\n                }\n                if (message.serviceName != null && message.hasOwnProperty(\"serviceName\"))\n                    object.serviceName = message.serviceName;\n                if (message.traceParsingFailed != null && message.hasOwnProperty(\"traceParsingFailed\"))\n                    object.traceParsingFailed = message.traceParsingFailed;\n                if (message.trace != null && message.hasOwnProperty(\"trace\"))\n                    object.trace = $root.Trace.toObject(message.trace, options);\n                if (message.sentTimeOffset != null && message.hasOwnProperty(\"sentTimeOffset\"))\n                    if (typeof message.sentTimeOffset === \"number\")\n                        object.sentTimeOffset = options.longs === String ? String(message.sentTimeOffset) : message.sentTimeOffset;\n                    else\n                        object.sentTimeOffset = options.longs === String ? $util.Long.prototype.toString.call(message.sentTimeOffset) : options.longs === Number ? new $util.LongBits(message.sentTimeOffset.low >>> 0, message.sentTimeOffset.high >>> 0).toNumber(true) : message.sentTimeOffset;\n                if (message.sentTime != null && message.hasOwnProperty(\"sentTime\"))\n                    object.sentTime = $root.google.protobuf.Timestamp.toObject(message.sentTime, options);\n                if (message.receivedTime != null && message.hasOwnProperty(\"receivedTime\"))\n                    object.receivedTime = $root.google.protobuf.Timestamp.toObject(message.receivedTime, options);\n                return object;\n            };\n\n            /**\n             * Converts this FetchNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.FetchNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            FetchNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return FetchNode;\n        })();\n\n        QueryPlanNode.FlattenNode = (function() {\n\n            /**\n             * Properties of a FlattenNode.\n             * @memberof Trace.QueryPlanNode\n             * @interface IFlattenNode\n             * @property {Array.<Trace.QueryPlanNode.IResponsePathElement>|null} [responsePath] FlattenNode responsePath\n             * @property {Trace.IQueryPlanNode|null} [node] FlattenNode node\n             */\n\n            /**\n             * Constructs a new FlattenNode.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a FlattenNode.\n             * @implements IFlattenNode\n             * @constructor\n             * @param {Trace.QueryPlanNode.IFlattenNode=} [properties] Properties to set\n             */\n            function FlattenNode(properties) {\n                this.responsePath = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * FlattenNode responsePath.\n             * @member {Array.<Trace.QueryPlanNode.IResponsePathElement>} responsePath\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @instance\n             */\n            FlattenNode.prototype.responsePath = $util.emptyArray;\n\n            /**\n             * FlattenNode node.\n             * @member {Trace.IQueryPlanNode|null|undefined} node\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @instance\n             */\n            FlattenNode.prototype.node = null;\n\n            /**\n             * Creates a new FlattenNode instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFlattenNode=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.FlattenNode} FlattenNode instance\n             */\n            FlattenNode.create = function create(properties) {\n                return new FlattenNode(properties);\n            };\n\n            /**\n             * Encodes the specified FlattenNode message. Does not implicitly {@link Trace.QueryPlanNode.FlattenNode.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFlattenNode} message FlattenNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            FlattenNode.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.responsePath != null && message.responsePath.length)\n                    for (var i = 0; i < message.responsePath.length; ++i)\n                        $root.Trace.QueryPlanNode.ResponsePathElement.encode(message.responsePath[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.node != null && Object.hasOwnProperty.call(message, \"node\"))\n                    $root.Trace.QueryPlanNode.encode(message.node, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n\n            /**\n             * Encodes the specified FlattenNode message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.FlattenNode.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {Trace.QueryPlanNode.IFlattenNode} message FlattenNode message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            FlattenNode.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a FlattenNode message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.FlattenNode} FlattenNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FlattenNode.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.FlattenNode();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.responsePath && message.responsePath.length))\n                            message.responsePath = [];\n                        message.responsePath.push($root.Trace.QueryPlanNode.ResponsePathElement.decode(reader, reader.uint32()));\n                        break;\n                    case 2:\n                        message.node = $root.Trace.QueryPlanNode.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a FlattenNode message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.FlattenNode} FlattenNode\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FlattenNode.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a FlattenNode message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            FlattenNode.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.responsePath != null && message.hasOwnProperty(\"responsePath\")) {\n                    if (!Array.isArray(message.responsePath))\n                        return \"responsePath: array expected\";\n                    for (var i = 0; i < message.responsePath.length; ++i) {\n                        var error = $root.Trace.QueryPlanNode.ResponsePathElement.verify(message.responsePath[i]);\n                        if (error)\n                            return \"responsePath.\" + error;\n                    }\n                }\n                if (message.node != null && message.hasOwnProperty(\"node\")) {\n                    var error = $root.Trace.QueryPlanNode.verify(message.node);\n                    if (error)\n                        return \"node.\" + error;\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a FlattenNode message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @static\n             * @param {Trace.QueryPlanNode.FlattenNode} message FlattenNode\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            FlattenNode.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.responsePath = [];\n                if (options.defaults)\n                    object.node = null;\n                if (message.responsePath && message.responsePath.length) {\n                    object.responsePath = [];\n                    for (var j = 0; j < message.responsePath.length; ++j)\n                        object.responsePath[j] = $root.Trace.QueryPlanNode.ResponsePathElement.toObject(message.responsePath[j], options);\n                }\n                if (message.node != null && message.hasOwnProperty(\"node\"))\n                    object.node = $root.Trace.QueryPlanNode.toObject(message.node, options);\n                return object;\n            };\n\n            /**\n             * Converts this FlattenNode to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.FlattenNode\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            FlattenNode.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return FlattenNode;\n        })();\n\n        QueryPlanNode.ResponsePathElement = (function() {\n\n            /**\n             * Properties of a ResponsePathElement.\n             * @memberof Trace.QueryPlanNode\n             * @interface IResponsePathElement\n             * @property {string|null} [fieldName] ResponsePathElement fieldName\n             * @property {number|null} [index] ResponsePathElement index\n             */\n\n            /**\n             * Constructs a new ResponsePathElement.\n             * @memberof Trace.QueryPlanNode\n             * @classdesc Represents a ResponsePathElement.\n             * @implements IResponsePathElement\n             * @constructor\n             * @param {Trace.QueryPlanNode.IResponsePathElement=} [properties] Properties to set\n             */\n            function ResponsePathElement(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * ResponsePathElement fieldName.\n             * @member {string} fieldName\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @instance\n             */\n            ResponsePathElement.prototype.fieldName = \"\";\n\n            /**\n             * ResponsePathElement index.\n             * @member {number} index\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @instance\n             */\n            ResponsePathElement.prototype.index = 0;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * ResponsePathElement id.\n             * @member {\"fieldName\"|\"index\"|undefined} id\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @instance\n             */\n            Object.defineProperty(ResponsePathElement.prototype, \"id\", {\n                get: $util.oneOfGetter($oneOfFields = [\"fieldName\", \"index\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Creates a new ResponsePathElement instance using the specified properties.\n             * @function create\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {Trace.QueryPlanNode.IResponsePathElement=} [properties] Properties to set\n             * @returns {Trace.QueryPlanNode.ResponsePathElement} ResponsePathElement instance\n             */\n            ResponsePathElement.create = function create(properties) {\n                return new ResponsePathElement(properties);\n            };\n\n            /**\n             * Encodes the specified ResponsePathElement message. Does not implicitly {@link Trace.QueryPlanNode.ResponsePathElement.verify|verify} messages.\n             * @function encode\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {Trace.QueryPlanNode.IResponsePathElement} message ResponsePathElement message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ResponsePathElement.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.fieldName != null && Object.hasOwnProperty.call(message, \"fieldName\"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fieldName);\n                if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified ResponsePathElement message, length delimited. Does not implicitly {@link Trace.QueryPlanNode.ResponsePathElement.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {Trace.QueryPlanNode.IResponsePathElement} message ResponsePathElement message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ResponsePathElement.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a ResponsePathElement message from the specified reader or buffer.\n             * @function decode\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {Trace.QueryPlanNode.ResponsePathElement} ResponsePathElement\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ResponsePathElement.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Trace.QueryPlanNode.ResponsePathElement();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.fieldName = reader.string();\n                        break;\n                    case 2:\n                        message.index = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a ResponsePathElement message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {Trace.QueryPlanNode.ResponsePathElement} ResponsePathElement\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ResponsePathElement.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a ResponsePathElement message.\n             * @function verify\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ResponsePathElement.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                var properties = {};\n                if (message.fieldName != null && message.hasOwnProperty(\"fieldName\")) {\n                    properties.id = 1;\n                    if (!$util.isString(message.fieldName))\n                        return \"fieldName: string expected\";\n                }\n                if (message.index != null && message.hasOwnProperty(\"index\")) {\n                    if (properties.id === 1)\n                        return \"id: multiple values\";\n                    properties.id = 1;\n                    if (!$util.isInteger(message.index))\n                        return \"index: integer expected\";\n                }\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a ResponsePathElement message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @static\n             * @param {Trace.QueryPlanNode.ResponsePathElement} message ResponsePathElement\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ResponsePathElement.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (message.fieldName != null && message.hasOwnProperty(\"fieldName\")) {\n                    object.fieldName = message.fieldName;\n                    if (options.oneofs)\n                        object.id = \"fieldName\";\n                }\n                if (message.index != null && message.hasOwnProperty(\"index\")) {\n                    object.index = message.index;\n                    if (options.oneofs)\n                        object.id = \"index\";\n                }\n                return object;\n            };\n\n            /**\n             * Converts this ResponsePathElement to JSON.\n             * @function toJSON\n             * @memberof Trace.QueryPlanNode.ResponsePathElement\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ResponsePathElement.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ResponsePathElement;\n        })();\n\n        return QueryPlanNode;\n    })();\n\n    return Trace;\n})();\n\n$root.ReportHeader = (function() {\n\n    /**\n     * Properties of a ReportHeader.\n     * @exports IReportHeader\n     * @interface IReportHeader\n     * @property {string|null} [graphRef] ReportHeader graphRef\n     * @property {string|null} [hostname] ReportHeader hostname\n     * @property {string|null} [agentVersion] ReportHeader agentVersion\n     * @property {string|null} [serviceVersion] ReportHeader serviceVersion\n     * @property {string|null} [runtimeVersion] ReportHeader runtimeVersion\n     * @property {string|null} [uname] ReportHeader uname\n     * @property {string|null} [executableSchemaId] ReportHeader executableSchemaId\n     */\n\n    /**\n     * Constructs a new ReportHeader.\n     * @exports ReportHeader\n     * @classdesc Represents a ReportHeader.\n     * @implements IReportHeader\n     * @constructor\n     * @param {IReportHeader=} [properties] Properties to set\n     */\n    function ReportHeader(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ReportHeader graphRef.\n     * @member {string} graphRef\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.graphRef = \"\";\n\n    /**\n     * ReportHeader hostname.\n     * @member {string} hostname\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.hostname = \"\";\n\n    /**\n     * ReportHeader agentVersion.\n     * @member {string} agentVersion\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.agentVersion = \"\";\n\n    /**\n     * ReportHeader serviceVersion.\n     * @member {string} serviceVersion\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.serviceVersion = \"\";\n\n    /**\n     * ReportHeader runtimeVersion.\n     * @member {string} runtimeVersion\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.runtimeVersion = \"\";\n\n    /**\n     * ReportHeader uname.\n     * @member {string} uname\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.uname = \"\";\n\n    /**\n     * ReportHeader executableSchemaId.\n     * @member {string} executableSchemaId\n     * @memberof ReportHeader\n     * @instance\n     */\n    ReportHeader.prototype.executableSchemaId = \"\";\n\n    /**\n     * Creates a new ReportHeader instance using the specified properties.\n     * @function create\n     * @memberof ReportHeader\n     * @static\n     * @param {IReportHeader=} [properties] Properties to set\n     * @returns {ReportHeader} ReportHeader instance\n     */\n    ReportHeader.create = function create(properties) {\n        return new ReportHeader(properties);\n    };\n\n    /**\n     * Encodes the specified ReportHeader message. Does not implicitly {@link ReportHeader.verify|verify} messages.\n     * @function encode\n     * @memberof ReportHeader\n     * @static\n     * @param {IReportHeader} message ReportHeader message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ReportHeader.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.hostname != null && Object.hasOwnProperty.call(message, \"hostname\"))\n            writer.uint32(/* id 5, wireType 2 =*/42).string(message.hostname);\n        if (message.agentVersion != null && Object.hasOwnProperty.call(message, \"agentVersion\"))\n            writer.uint32(/* id 6, wireType 2 =*/50).string(message.agentVersion);\n        if (message.serviceVersion != null && Object.hasOwnProperty.call(message, \"serviceVersion\"))\n            writer.uint32(/* id 7, wireType 2 =*/58).string(message.serviceVersion);\n        if (message.runtimeVersion != null && Object.hasOwnProperty.call(message, \"runtimeVersion\"))\n            writer.uint32(/* id 8, wireType 2 =*/66).string(message.runtimeVersion);\n        if (message.uname != null && Object.hasOwnProperty.call(message, \"uname\"))\n            writer.uint32(/* id 9, wireType 2 =*/74).string(message.uname);\n        if (message.executableSchemaId != null && Object.hasOwnProperty.call(message, \"executableSchemaId\"))\n            writer.uint32(/* id 11, wireType 2 =*/90).string(message.executableSchemaId);\n        if (message.graphRef != null && Object.hasOwnProperty.call(message, \"graphRef\"))\n            writer.uint32(/* id 12, wireType 2 =*/98).string(message.graphRef);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ReportHeader message, length delimited. Does not implicitly {@link ReportHeader.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ReportHeader\n     * @static\n     * @param {IReportHeader} message ReportHeader message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ReportHeader.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ReportHeader message from the specified reader or buffer.\n     * @function decode\n     * @memberof ReportHeader\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ReportHeader} ReportHeader\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ReportHeader.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ReportHeader();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 12:\n                message.graphRef = reader.string();\n                break;\n            case 5:\n                message.hostname = reader.string();\n                break;\n            case 6:\n                message.agentVersion = reader.string();\n                break;\n            case 7:\n                message.serviceVersion = reader.string();\n                break;\n            case 8:\n                message.runtimeVersion = reader.string();\n                break;\n            case 9:\n                message.uname = reader.string();\n                break;\n            case 11:\n                message.executableSchemaId = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ReportHeader message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ReportHeader\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ReportHeader} ReportHeader\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ReportHeader.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ReportHeader message.\n     * @function verify\n     * @memberof ReportHeader\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ReportHeader.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.graphRef != null && message.hasOwnProperty(\"graphRef\"))\n            if (!$util.isString(message.graphRef))\n                return \"graphRef: string expected\";\n        if (message.hostname != null && message.hasOwnProperty(\"hostname\"))\n            if (!$util.isString(message.hostname))\n                return \"hostname: string expected\";\n        if (message.agentVersion != null && message.hasOwnProperty(\"agentVersion\"))\n            if (!$util.isString(message.agentVersion))\n                return \"agentVersion: string expected\";\n        if (message.serviceVersion != null && message.hasOwnProperty(\"serviceVersion\"))\n            if (!$util.isString(message.serviceVersion))\n                return \"serviceVersion: string expected\";\n        if (message.runtimeVersion != null && message.hasOwnProperty(\"runtimeVersion\"))\n            if (!$util.isString(message.runtimeVersion))\n                return \"runtimeVersion: string expected\";\n        if (message.uname != null && message.hasOwnProperty(\"uname\"))\n            if (!$util.isString(message.uname))\n                return \"uname: string expected\";\n        if (message.executableSchemaId != null && message.hasOwnProperty(\"executableSchemaId\"))\n            if (!$util.isString(message.executableSchemaId))\n                return \"executableSchemaId: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a ReportHeader message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ReportHeader\n     * @static\n     * @param {ReportHeader} message ReportHeader\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ReportHeader.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.hostname = \"\";\n            object.agentVersion = \"\";\n            object.serviceVersion = \"\";\n            object.runtimeVersion = \"\";\n            object.uname = \"\";\n            object.executableSchemaId = \"\";\n            object.graphRef = \"\";\n        }\n        if (message.hostname != null && message.hasOwnProperty(\"hostname\"))\n            object.hostname = message.hostname;\n        if (message.agentVersion != null && message.hasOwnProperty(\"agentVersion\"))\n            object.agentVersion = message.agentVersion;\n        if (message.serviceVersion != null && message.hasOwnProperty(\"serviceVersion\"))\n            object.serviceVersion = message.serviceVersion;\n        if (message.runtimeVersion != null && message.hasOwnProperty(\"runtimeVersion\"))\n            object.runtimeVersion = message.runtimeVersion;\n        if (message.uname != null && message.hasOwnProperty(\"uname\"))\n            object.uname = message.uname;\n        if (message.executableSchemaId != null && message.hasOwnProperty(\"executableSchemaId\"))\n            object.executableSchemaId = message.executableSchemaId;\n        if (message.graphRef != null && message.hasOwnProperty(\"graphRef\"))\n            object.graphRef = message.graphRef;\n        return object;\n    };\n\n    /**\n     * Converts this ReportHeader to JSON.\n     * @function toJSON\n     * @memberof ReportHeader\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ReportHeader.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ReportHeader;\n})();\n\n$root.PathErrorStats = (function() {\n\n    /**\n     * Properties of a PathErrorStats.\n     * @exports IPathErrorStats\n     * @interface IPathErrorStats\n     * @property {Object.<string,IPathErrorStats>|null} [children] PathErrorStats children\n     * @property {number|null} [errorsCount] PathErrorStats errorsCount\n     * @property {number|null} [requestsWithErrorsCount] PathErrorStats requestsWithErrorsCount\n     */\n\n    /**\n     * Constructs a new PathErrorStats.\n     * @exports PathErrorStats\n     * @classdesc Represents a PathErrorStats.\n     * @implements IPathErrorStats\n     * @constructor\n     * @param {IPathErrorStats=} [properties] Properties to set\n     */\n    function PathErrorStats(properties) {\n        this.children = {};\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * PathErrorStats children.\n     * @member {Object.<string,IPathErrorStats>} children\n     * @memberof PathErrorStats\n     * @instance\n     */\n    PathErrorStats.prototype.children = $util.emptyObject;\n\n    /**\n     * PathErrorStats errorsCount.\n     * @member {number} errorsCount\n     * @memberof PathErrorStats\n     * @instance\n     */\n    PathErrorStats.prototype.errorsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * PathErrorStats requestsWithErrorsCount.\n     * @member {number} requestsWithErrorsCount\n     * @memberof PathErrorStats\n     * @instance\n     */\n    PathErrorStats.prototype.requestsWithErrorsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Creates a new PathErrorStats instance using the specified properties.\n     * @function create\n     * @memberof PathErrorStats\n     * @static\n     * @param {IPathErrorStats=} [properties] Properties to set\n     * @returns {PathErrorStats} PathErrorStats instance\n     */\n    PathErrorStats.create = function create(properties) {\n        return new PathErrorStats(properties);\n    };\n\n    /**\n     * Encodes the specified PathErrorStats message. Does not implicitly {@link PathErrorStats.verify|verify} messages.\n     * @function encode\n     * @memberof PathErrorStats\n     * @static\n     * @param {IPathErrorStats} message PathErrorStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PathErrorStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.children != null && Object.hasOwnProperty.call(message, \"children\"))\n            for (var keys = Object.keys(message.children), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.PathErrorStats.encode(message.children[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        if (message.errorsCount != null && Object.hasOwnProperty.call(message, \"errorsCount\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.errorsCount);\n        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, \"requestsWithErrorsCount\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.requestsWithErrorsCount);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified PathErrorStats message, length delimited. Does not implicitly {@link PathErrorStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof PathErrorStats\n     * @static\n     * @param {IPathErrorStats} message PathErrorStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    PathErrorStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a PathErrorStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof PathErrorStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PathErrorStats} PathErrorStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PathErrorStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PathErrorStats(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                reader.skip().pos++;\n                if (message.children === $util.emptyObject)\n                    message.children = {};\n                key = reader.string();\n                reader.pos++;\n                message.children[key] = $root.PathErrorStats.decode(reader, reader.uint32());\n                break;\n            case 4:\n                message.errorsCount = reader.uint64();\n                break;\n            case 5:\n                message.requestsWithErrorsCount = reader.uint64();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a PathErrorStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof PathErrorStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {PathErrorStats} PathErrorStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PathErrorStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a PathErrorStats message.\n     * @function verify\n     * @memberof PathErrorStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    PathErrorStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.children != null && message.hasOwnProperty(\"children\")) {\n            if (!$util.isObject(message.children))\n                return \"children: object expected\";\n            var key = Object.keys(message.children);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.PathErrorStats.verify(message.children[key[i]]);\n                if (error)\n                    return \"children.\" + error;\n            }\n        }\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))\n                return \"errorsCount: integer|Long expected\";\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))\n                return \"requestsWithErrorsCount: integer|Long expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a PathErrorStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof PathErrorStats\n     * @static\n     * @param {PathErrorStats} message PathErrorStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    PathErrorStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.objects || options.defaults)\n            object.children = {};\n        if (options.defaults) {\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.errorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.errorsCount = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.requestsWithErrorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.requestsWithErrorsCount = options.longs === String ? \"0\" : 0;\n        }\n        var keys2;\n        if (message.children && (keys2 = Object.keys(message.children)).length) {\n            object.children = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.children[keys2[j]] = $root.PathErrorStats.toObject(message.children[keys2[j]], options);\n        }\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (typeof message.errorsCount === \"number\")\n                object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;\n            else\n                object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (typeof message.requestsWithErrorsCount === \"number\")\n                object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;\n            else\n                object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n        return object;\n    };\n\n    /**\n     * Converts this PathErrorStats to JSON.\n     * @function toJSON\n     * @memberof PathErrorStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    PathErrorStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return PathErrorStats;\n})();\n\n$root.QueryLatencyStats = (function() {\n\n    /**\n     * Properties of a QueryLatencyStats.\n     * @exports IQueryLatencyStats\n     * @interface IQueryLatencyStats\n     * @property {$protobuf.ToArray.<number>|Array.<number>|null} [latencyCount] QueryLatencyStats latencyCount\n     * @property {number|null} [requestCount] QueryLatencyStats requestCount\n     * @property {number|null} [cacheHits] QueryLatencyStats cacheHits\n     * @property {number|null} [persistedQueryHits] QueryLatencyStats persistedQueryHits\n     * @property {number|null} [persistedQueryMisses] QueryLatencyStats persistedQueryMisses\n     * @property {$protobuf.ToArray.<number>|Array.<number>|null} [cacheLatencyCount] QueryLatencyStats cacheLatencyCount\n     * @property {IPathErrorStats|null} [rootErrorStats] QueryLatencyStats rootErrorStats\n     * @property {number|null} [requestsWithErrorsCount] QueryLatencyStats requestsWithErrorsCount\n     * @property {$protobuf.ToArray.<number>|Array.<number>|null} [publicCacheTtlCount] QueryLatencyStats publicCacheTtlCount\n     * @property {$protobuf.ToArray.<number>|Array.<number>|null} [privateCacheTtlCount] QueryLatencyStats privateCacheTtlCount\n     * @property {number|null} [registeredOperationCount] QueryLatencyStats registeredOperationCount\n     * @property {number|null} [forbiddenOperationCount] QueryLatencyStats forbiddenOperationCount\n     */\n\n    /**\n     * Constructs a new QueryLatencyStats.\n     * @exports QueryLatencyStats\n     * @classdesc Represents a QueryLatencyStats.\n     * @implements IQueryLatencyStats\n     * @constructor\n     * @param {IQueryLatencyStats=} [properties] Properties to set\n     */\n    function QueryLatencyStats(properties) {\n        this.latencyCount = [];\n        this.cacheLatencyCount = [];\n        this.publicCacheTtlCount = [];\n        this.privateCacheTtlCount = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * QueryLatencyStats latencyCount.\n     * @member {Array.<number>} latencyCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.latencyCount = $util.emptyArray;\n\n    /**\n     * QueryLatencyStats requestCount.\n     * @member {number} requestCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.requestCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * QueryLatencyStats cacheHits.\n     * @member {number} cacheHits\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.cacheHits = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * QueryLatencyStats persistedQueryHits.\n     * @member {number} persistedQueryHits\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.persistedQueryHits = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * QueryLatencyStats persistedQueryMisses.\n     * @member {number} persistedQueryMisses\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.persistedQueryMisses = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * QueryLatencyStats cacheLatencyCount.\n     * @member {Array.<number>} cacheLatencyCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.cacheLatencyCount = $util.emptyArray;\n\n    /**\n     * QueryLatencyStats rootErrorStats.\n     * @member {IPathErrorStats|null|undefined} rootErrorStats\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.rootErrorStats = null;\n\n    /**\n     * QueryLatencyStats requestsWithErrorsCount.\n     * @member {number} requestsWithErrorsCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.requestsWithErrorsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * QueryLatencyStats publicCacheTtlCount.\n     * @member {Array.<number>} publicCacheTtlCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.publicCacheTtlCount = $util.emptyArray;\n\n    /**\n     * QueryLatencyStats privateCacheTtlCount.\n     * @member {Array.<number>} privateCacheTtlCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.privateCacheTtlCount = $util.emptyArray;\n\n    /**\n     * QueryLatencyStats registeredOperationCount.\n     * @member {number} registeredOperationCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.registeredOperationCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * QueryLatencyStats forbiddenOperationCount.\n     * @member {number} forbiddenOperationCount\n     * @memberof QueryLatencyStats\n     * @instance\n     */\n    QueryLatencyStats.prototype.forbiddenOperationCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Creates a new QueryLatencyStats instance using the specified properties.\n     * @function create\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {IQueryLatencyStats=} [properties] Properties to set\n     * @returns {QueryLatencyStats} QueryLatencyStats instance\n     */\n    QueryLatencyStats.create = function create(properties) {\n        return new QueryLatencyStats(properties);\n    };\n\n    /**\n     * Encodes the specified QueryLatencyStats message. Does not implicitly {@link QueryLatencyStats.verify|verify} messages.\n     * @function encode\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {IQueryLatencyStats} message QueryLatencyStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QueryLatencyStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.requestCount != null && Object.hasOwnProperty.call(message, \"requestCount\"))\n            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.requestCount);\n        if (message.cacheHits != null && Object.hasOwnProperty.call(message, \"cacheHits\"))\n            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.cacheHits);\n        if (message.persistedQueryHits != null && Object.hasOwnProperty.call(message, \"persistedQueryHits\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.persistedQueryHits);\n        if (message.persistedQueryMisses != null && Object.hasOwnProperty.call(message, \"persistedQueryMisses\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.persistedQueryMisses);\n        if (message.rootErrorStats != null && Object.hasOwnProperty.call(message, \"rootErrorStats\"))\n            $root.PathErrorStats.encode(message.rootErrorStats, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, \"requestsWithErrorsCount\"))\n            writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.requestsWithErrorsCount);\n        if (message.registeredOperationCount != null && Object.hasOwnProperty.call(message, \"registeredOperationCount\"))\n            writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.registeredOperationCount);\n        if (message.forbiddenOperationCount != null && Object.hasOwnProperty.call(message, \"forbiddenOperationCount\"))\n            writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.forbiddenOperationCount);\n        var array13;\n        if (message.latencyCount != null && message.latencyCount.toArray)\n            array13 = message.latencyCount.toArray();\n        else\n            array13 = message.latencyCount;\n        if (array13 != null && array13.length) {\n            writer.uint32(/* id 13, wireType 2 =*/106).fork();\n            for (var i = 0; i < array13.length; ++i)\n                writer.sint64(array13[i]);\n            writer.ldelim();\n        }\n        var array14;\n        if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)\n            array14 = message.cacheLatencyCount.toArray();\n        else\n            array14 = message.cacheLatencyCount;\n        if (array14 != null && array14.length) {\n            writer.uint32(/* id 14, wireType 2 =*/114).fork();\n            for (var i = 0; i < array14.length; ++i)\n                writer.sint64(array14[i]);\n            writer.ldelim();\n        }\n        var array15;\n        if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)\n            array15 = message.publicCacheTtlCount.toArray();\n        else\n            array15 = message.publicCacheTtlCount;\n        if (array15 != null && array15.length) {\n            writer.uint32(/* id 15, wireType 2 =*/122).fork();\n            for (var i = 0; i < array15.length; ++i)\n                writer.sint64(array15[i]);\n            writer.ldelim();\n        }\n        var array16;\n        if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)\n            array16 = message.privateCacheTtlCount.toArray();\n        else\n            array16 = message.privateCacheTtlCount;\n        if (array16 != null && array16.length) {\n            writer.uint32(/* id 16, wireType 2 =*/130).fork();\n            for (var i = 0; i < array16.length; ++i)\n                writer.sint64(array16[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified QueryLatencyStats message, length delimited. Does not implicitly {@link QueryLatencyStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {IQueryLatencyStats} message QueryLatencyStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    QueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a QueryLatencyStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {QueryLatencyStats} QueryLatencyStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QueryLatencyStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.QueryLatencyStats();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 13:\n                if (!(message.latencyCount && message.latencyCount.length))\n                    message.latencyCount = [];\n                if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.latencyCount.push(reader.sint64());\n                } else\n                    message.latencyCount.push(reader.sint64());\n                break;\n            case 2:\n                message.requestCount = reader.uint64();\n                break;\n            case 3:\n                message.cacheHits = reader.uint64();\n                break;\n            case 4:\n                message.persistedQueryHits = reader.uint64();\n                break;\n            case 5:\n                message.persistedQueryMisses = reader.uint64();\n                break;\n            case 14:\n                if (!(message.cacheLatencyCount && message.cacheLatencyCount.length))\n                    message.cacheLatencyCount = [];\n                if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.cacheLatencyCount.push(reader.sint64());\n                } else\n                    message.cacheLatencyCount.push(reader.sint64());\n                break;\n            case 7:\n                message.rootErrorStats = $root.PathErrorStats.decode(reader, reader.uint32());\n                break;\n            case 8:\n                message.requestsWithErrorsCount = reader.uint64();\n                break;\n            case 15:\n                if (!(message.publicCacheTtlCount && message.publicCacheTtlCount.length))\n                    message.publicCacheTtlCount = [];\n                if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.publicCacheTtlCount.push(reader.sint64());\n                } else\n                    message.publicCacheTtlCount.push(reader.sint64());\n                break;\n            case 16:\n                if (!(message.privateCacheTtlCount && message.privateCacheTtlCount.length))\n                    message.privateCacheTtlCount = [];\n                if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.privateCacheTtlCount.push(reader.sint64());\n                } else\n                    message.privateCacheTtlCount.push(reader.sint64());\n                break;\n            case 11:\n                message.registeredOperationCount = reader.uint64();\n                break;\n            case 12:\n                message.forbiddenOperationCount = reader.uint64();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a QueryLatencyStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {QueryLatencyStats} QueryLatencyStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    QueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a QueryLatencyStats message.\n     * @function verify\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    QueryLatencyStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.latencyCount != null && message.hasOwnProperty(\"latencyCount\")) {\n            var array13;\n            if (message.latencyCount != null && message.latencyCount.toArray)\n                array13 = message.latencyCount.toArray();\n            else\n                array13 = message.latencyCount;\n            if (!Array.isArray(array13))\n                return \"latencyCount: array expected\";\n            for (var i = 0; i < array13.length; ++i)\n                if (!$util.isInteger(array13[i]) && !(array13[i] && $util.isInteger(array13[i].low) && $util.isInteger(array13[i].high)))\n                    return \"latencyCount: integer|Long[] expected\";\n        }\n        if (message.requestCount != null && message.hasOwnProperty(\"requestCount\"))\n            if (!$util.isInteger(message.requestCount) && !(message.requestCount && $util.isInteger(message.requestCount.low) && $util.isInteger(message.requestCount.high)))\n                return \"requestCount: integer|Long expected\";\n        if (message.cacheHits != null && message.hasOwnProperty(\"cacheHits\"))\n            if (!$util.isInteger(message.cacheHits) && !(message.cacheHits && $util.isInteger(message.cacheHits.low) && $util.isInteger(message.cacheHits.high)))\n                return \"cacheHits: integer|Long expected\";\n        if (message.persistedQueryHits != null && message.hasOwnProperty(\"persistedQueryHits\"))\n            if (!$util.isInteger(message.persistedQueryHits) && !(message.persistedQueryHits && $util.isInteger(message.persistedQueryHits.low) && $util.isInteger(message.persistedQueryHits.high)))\n                return \"persistedQueryHits: integer|Long expected\";\n        if (message.persistedQueryMisses != null && message.hasOwnProperty(\"persistedQueryMisses\"))\n            if (!$util.isInteger(message.persistedQueryMisses) && !(message.persistedQueryMisses && $util.isInteger(message.persistedQueryMisses.low) && $util.isInteger(message.persistedQueryMisses.high)))\n                return \"persistedQueryMisses: integer|Long expected\";\n        if (message.cacheLatencyCount != null && message.hasOwnProperty(\"cacheLatencyCount\")) {\n            var array14;\n            if (message.cacheLatencyCount != null && message.cacheLatencyCount.toArray)\n                array14 = message.cacheLatencyCount.toArray();\n            else\n                array14 = message.cacheLatencyCount;\n            if (!Array.isArray(array14))\n                return \"cacheLatencyCount: array expected\";\n            for (var i = 0; i < array14.length; ++i)\n                if (!$util.isInteger(array14[i]) && !(array14[i] && $util.isInteger(array14[i].low) && $util.isInteger(array14[i].high)))\n                    return \"cacheLatencyCount: integer|Long[] expected\";\n        }\n        if (message.rootErrorStats != null && message.hasOwnProperty(\"rootErrorStats\")) {\n            var error = $root.PathErrorStats.verify(message.rootErrorStats);\n            if (error)\n                return \"rootErrorStats.\" + error;\n        }\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))\n                return \"requestsWithErrorsCount: integer|Long expected\";\n        if (message.publicCacheTtlCount != null && message.hasOwnProperty(\"publicCacheTtlCount\")) {\n            var array15;\n            if (message.publicCacheTtlCount != null && message.publicCacheTtlCount.toArray)\n                array15 = message.publicCacheTtlCount.toArray();\n            else\n                array15 = message.publicCacheTtlCount;\n            if (!Array.isArray(array15))\n                return \"publicCacheTtlCount: array expected\";\n            for (var i = 0; i < array15.length; ++i)\n                if (!$util.isInteger(array15[i]) && !(array15[i] && $util.isInteger(array15[i].low) && $util.isInteger(array15[i].high)))\n                    return \"publicCacheTtlCount: integer|Long[] expected\";\n        }\n        if (message.privateCacheTtlCount != null && message.hasOwnProperty(\"privateCacheTtlCount\")) {\n            var array16;\n            if (message.privateCacheTtlCount != null && message.privateCacheTtlCount.toArray)\n                array16 = message.privateCacheTtlCount.toArray();\n            else\n                array16 = message.privateCacheTtlCount;\n            if (!Array.isArray(array16))\n                return \"privateCacheTtlCount: array expected\";\n            for (var i = 0; i < array16.length; ++i)\n                if (!$util.isInteger(array16[i]) && !(array16[i] && $util.isInteger(array16[i].low) && $util.isInteger(array16[i].high)))\n                    return \"privateCacheTtlCount: integer|Long[] expected\";\n        }\n        if (message.registeredOperationCount != null && message.hasOwnProperty(\"registeredOperationCount\"))\n            if (!$util.isInteger(message.registeredOperationCount) && !(message.registeredOperationCount && $util.isInteger(message.registeredOperationCount.low) && $util.isInteger(message.registeredOperationCount.high)))\n                return \"registeredOperationCount: integer|Long expected\";\n        if (message.forbiddenOperationCount != null && message.hasOwnProperty(\"forbiddenOperationCount\"))\n            if (!$util.isInteger(message.forbiddenOperationCount) && !(message.forbiddenOperationCount && $util.isInteger(message.forbiddenOperationCount.low) && $util.isInteger(message.forbiddenOperationCount.high)))\n                return \"forbiddenOperationCount: integer|Long expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a QueryLatencyStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof QueryLatencyStats\n     * @static\n     * @param {QueryLatencyStats} message QueryLatencyStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    QueryLatencyStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults) {\n            object.latencyCount = [];\n            object.cacheLatencyCount = [];\n            object.publicCacheTtlCount = [];\n            object.privateCacheTtlCount = [];\n        }\n        if (options.defaults) {\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.requestCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.requestCount = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.cacheHits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.cacheHits = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.persistedQueryHits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.persistedQueryHits = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.persistedQueryMisses = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.persistedQueryMisses = options.longs === String ? \"0\" : 0;\n            object.rootErrorStats = null;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.requestsWithErrorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.requestsWithErrorsCount = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.registeredOperationCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.registeredOperationCount = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.forbiddenOperationCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.forbiddenOperationCount = options.longs === String ? \"0\" : 0;\n        }\n        if (message.requestCount != null && message.hasOwnProperty(\"requestCount\"))\n            if (typeof message.requestCount === \"number\")\n                object.requestCount = options.longs === String ? String(message.requestCount) : message.requestCount;\n            else\n                object.requestCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestCount) : options.longs === Number ? new $util.LongBits(message.requestCount.low >>> 0, message.requestCount.high >>> 0).toNumber(true) : message.requestCount;\n        if (message.cacheHits != null && message.hasOwnProperty(\"cacheHits\"))\n            if (typeof message.cacheHits === \"number\")\n                object.cacheHits = options.longs === String ? String(message.cacheHits) : message.cacheHits;\n            else\n                object.cacheHits = options.longs === String ? $util.Long.prototype.toString.call(message.cacheHits) : options.longs === Number ? new $util.LongBits(message.cacheHits.low >>> 0, message.cacheHits.high >>> 0).toNumber(true) : message.cacheHits;\n        if (message.persistedQueryHits != null && message.hasOwnProperty(\"persistedQueryHits\"))\n            if (typeof message.persistedQueryHits === \"number\")\n                object.persistedQueryHits = options.longs === String ? String(message.persistedQueryHits) : message.persistedQueryHits;\n            else\n                object.persistedQueryHits = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryHits) : options.longs === Number ? new $util.LongBits(message.persistedQueryHits.low >>> 0, message.persistedQueryHits.high >>> 0).toNumber(true) : message.persistedQueryHits;\n        if (message.persistedQueryMisses != null && message.hasOwnProperty(\"persistedQueryMisses\"))\n            if (typeof message.persistedQueryMisses === \"number\")\n                object.persistedQueryMisses = options.longs === String ? String(message.persistedQueryMisses) : message.persistedQueryMisses;\n            else\n                object.persistedQueryMisses = options.longs === String ? $util.Long.prototype.toString.call(message.persistedQueryMisses) : options.longs === Number ? new $util.LongBits(message.persistedQueryMisses.low >>> 0, message.persistedQueryMisses.high >>> 0).toNumber(true) : message.persistedQueryMisses;\n        if (message.rootErrorStats != null && message.hasOwnProperty(\"rootErrorStats\"))\n            object.rootErrorStats = $root.PathErrorStats.toObject(message.rootErrorStats, options);\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (typeof message.requestsWithErrorsCount === \"number\")\n                object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;\n            else\n                object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n        if (message.registeredOperationCount != null && message.hasOwnProperty(\"registeredOperationCount\"))\n            if (typeof message.registeredOperationCount === \"number\")\n                object.registeredOperationCount = options.longs === String ? String(message.registeredOperationCount) : message.registeredOperationCount;\n            else\n                object.registeredOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.registeredOperationCount) : options.longs === Number ? new $util.LongBits(message.registeredOperationCount.low >>> 0, message.registeredOperationCount.high >>> 0).toNumber(true) : message.registeredOperationCount;\n        if (message.forbiddenOperationCount != null && message.hasOwnProperty(\"forbiddenOperationCount\"))\n            if (typeof message.forbiddenOperationCount === \"number\")\n                object.forbiddenOperationCount = options.longs === String ? String(message.forbiddenOperationCount) : message.forbiddenOperationCount;\n            else\n                object.forbiddenOperationCount = options.longs === String ? $util.Long.prototype.toString.call(message.forbiddenOperationCount) : options.longs === Number ? new $util.LongBits(message.forbiddenOperationCount.low >>> 0, message.forbiddenOperationCount.high >>> 0).toNumber(true) : message.forbiddenOperationCount;\n        if (message.latencyCount && message.latencyCount.length) {\n            object.latencyCount = [];\n            for (var j = 0; j < message.latencyCount.length; ++j)\n                if (typeof message.latencyCount[j] === \"number\")\n                    object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];\n                else\n                    object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];\n        }\n        if (message.cacheLatencyCount && message.cacheLatencyCount.length) {\n            object.cacheLatencyCount = [];\n            for (var j = 0; j < message.cacheLatencyCount.length; ++j)\n                if (typeof message.cacheLatencyCount[j] === \"number\")\n                    object.cacheLatencyCount[j] = options.longs === String ? String(message.cacheLatencyCount[j]) : message.cacheLatencyCount[j];\n                else\n                    object.cacheLatencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.cacheLatencyCount[j]) : options.longs === Number ? new $util.LongBits(message.cacheLatencyCount[j].low >>> 0, message.cacheLatencyCount[j].high >>> 0).toNumber() : message.cacheLatencyCount[j];\n        }\n        if (message.publicCacheTtlCount && message.publicCacheTtlCount.length) {\n            object.publicCacheTtlCount = [];\n            for (var j = 0; j < message.publicCacheTtlCount.length; ++j)\n                if (typeof message.publicCacheTtlCount[j] === \"number\")\n                    object.publicCacheTtlCount[j] = options.longs === String ? String(message.publicCacheTtlCount[j]) : message.publicCacheTtlCount[j];\n                else\n                    object.publicCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.publicCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.publicCacheTtlCount[j].low >>> 0, message.publicCacheTtlCount[j].high >>> 0).toNumber() : message.publicCacheTtlCount[j];\n        }\n        if (message.privateCacheTtlCount && message.privateCacheTtlCount.length) {\n            object.privateCacheTtlCount = [];\n            for (var j = 0; j < message.privateCacheTtlCount.length; ++j)\n                if (typeof message.privateCacheTtlCount[j] === \"number\")\n                    object.privateCacheTtlCount[j] = options.longs === String ? String(message.privateCacheTtlCount[j]) : message.privateCacheTtlCount[j];\n                else\n                    object.privateCacheTtlCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.privateCacheTtlCount[j]) : options.longs === Number ? new $util.LongBits(message.privateCacheTtlCount[j].low >>> 0, message.privateCacheTtlCount[j].high >>> 0).toNumber() : message.privateCacheTtlCount[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this QueryLatencyStats to JSON.\n     * @function toJSON\n     * @memberof QueryLatencyStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    QueryLatencyStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return QueryLatencyStats;\n})();\n\n$root.StatsContext = (function() {\n\n    /**\n     * Properties of a StatsContext.\n     * @exports IStatsContext\n     * @interface IStatsContext\n     * @property {string|null} [clientReferenceId] StatsContext clientReferenceId\n     * @property {string|null} [clientName] StatsContext clientName\n     * @property {string|null} [clientVersion] StatsContext clientVersion\n     */\n\n    /**\n     * Constructs a new StatsContext.\n     * @exports StatsContext\n     * @classdesc Represents a StatsContext.\n     * @implements IStatsContext\n     * @constructor\n     * @param {IStatsContext=} [properties] Properties to set\n     */\n    function StatsContext(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * StatsContext clientReferenceId.\n     * @member {string} clientReferenceId\n     * @memberof StatsContext\n     * @instance\n     */\n    StatsContext.prototype.clientReferenceId = \"\";\n\n    /**\n     * StatsContext clientName.\n     * @member {string} clientName\n     * @memberof StatsContext\n     * @instance\n     */\n    StatsContext.prototype.clientName = \"\";\n\n    /**\n     * StatsContext clientVersion.\n     * @member {string} clientVersion\n     * @memberof StatsContext\n     * @instance\n     */\n    StatsContext.prototype.clientVersion = \"\";\n\n    /**\n     * Creates a new StatsContext instance using the specified properties.\n     * @function create\n     * @memberof StatsContext\n     * @static\n     * @param {IStatsContext=} [properties] Properties to set\n     * @returns {StatsContext} StatsContext instance\n     */\n    StatsContext.create = function create(properties) {\n        return new StatsContext(properties);\n    };\n\n    /**\n     * Encodes the specified StatsContext message. Does not implicitly {@link StatsContext.verify|verify} messages.\n     * @function encode\n     * @memberof StatsContext\n     * @static\n     * @param {IStatsContext} message StatsContext message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StatsContext.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.clientReferenceId != null && Object.hasOwnProperty.call(message, \"clientReferenceId\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).string(message.clientReferenceId);\n        if (message.clientName != null && Object.hasOwnProperty.call(message, \"clientName\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientName);\n        if (message.clientVersion != null && Object.hasOwnProperty.call(message, \"clientVersion\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientVersion);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified StatsContext message, length delimited. Does not implicitly {@link StatsContext.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof StatsContext\n     * @static\n     * @param {IStatsContext} message StatsContext message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    StatsContext.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a StatsContext message from the specified reader or buffer.\n     * @function decode\n     * @memberof StatsContext\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {StatsContext} StatsContext\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StatsContext.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.StatsContext();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.clientReferenceId = reader.string();\n                break;\n            case 2:\n                message.clientName = reader.string();\n                break;\n            case 3:\n                message.clientVersion = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a StatsContext message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof StatsContext\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {StatsContext} StatsContext\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    StatsContext.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a StatsContext message.\n     * @function verify\n     * @memberof StatsContext\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    StatsContext.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.clientReferenceId != null && message.hasOwnProperty(\"clientReferenceId\"))\n            if (!$util.isString(message.clientReferenceId))\n                return \"clientReferenceId: string expected\";\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            if (!$util.isString(message.clientName))\n                return \"clientName: string expected\";\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            if (!$util.isString(message.clientVersion))\n                return \"clientVersion: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a StatsContext message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof StatsContext\n     * @static\n     * @param {StatsContext} message StatsContext\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    StatsContext.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.clientReferenceId = \"\";\n            object.clientName = \"\";\n            object.clientVersion = \"\";\n        }\n        if (message.clientReferenceId != null && message.hasOwnProperty(\"clientReferenceId\"))\n            object.clientReferenceId = message.clientReferenceId;\n        if (message.clientName != null && message.hasOwnProperty(\"clientName\"))\n            object.clientName = message.clientName;\n        if (message.clientVersion != null && message.hasOwnProperty(\"clientVersion\"))\n            object.clientVersion = message.clientVersion;\n        return object;\n    };\n\n    /**\n     * Converts this StatsContext to JSON.\n     * @function toJSON\n     * @memberof StatsContext\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    StatsContext.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return StatsContext;\n})();\n\n$root.ContextualizedQueryLatencyStats = (function() {\n\n    /**\n     * Properties of a ContextualizedQueryLatencyStats.\n     * @exports IContextualizedQueryLatencyStats\n     * @interface IContextualizedQueryLatencyStats\n     * @property {IQueryLatencyStats|null} [queryLatencyStats] ContextualizedQueryLatencyStats queryLatencyStats\n     * @property {IStatsContext|null} [context] ContextualizedQueryLatencyStats context\n     */\n\n    /**\n     * Constructs a new ContextualizedQueryLatencyStats.\n     * @exports ContextualizedQueryLatencyStats\n     * @classdesc Represents a ContextualizedQueryLatencyStats.\n     * @implements IContextualizedQueryLatencyStats\n     * @constructor\n     * @param {IContextualizedQueryLatencyStats=} [properties] Properties to set\n     */\n    function ContextualizedQueryLatencyStats(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ContextualizedQueryLatencyStats queryLatencyStats.\n     * @member {IQueryLatencyStats|null|undefined} queryLatencyStats\n     * @memberof ContextualizedQueryLatencyStats\n     * @instance\n     */\n    ContextualizedQueryLatencyStats.prototype.queryLatencyStats = null;\n\n    /**\n     * ContextualizedQueryLatencyStats context.\n     * @member {IStatsContext|null|undefined} context\n     * @memberof ContextualizedQueryLatencyStats\n     * @instance\n     */\n    ContextualizedQueryLatencyStats.prototype.context = null;\n\n    /**\n     * Creates a new ContextualizedQueryLatencyStats instance using the specified properties.\n     * @function create\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {IContextualizedQueryLatencyStats=} [properties] Properties to set\n     * @returns {ContextualizedQueryLatencyStats} ContextualizedQueryLatencyStats instance\n     */\n    ContextualizedQueryLatencyStats.create = function create(properties) {\n        return new ContextualizedQueryLatencyStats(properties);\n    };\n\n    /**\n     * Encodes the specified ContextualizedQueryLatencyStats message. Does not implicitly {@link ContextualizedQueryLatencyStats.verify|verify} messages.\n     * @function encode\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {IContextualizedQueryLatencyStats} message ContextualizedQueryLatencyStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedQueryLatencyStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, \"queryLatencyStats\"))\n            $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.context != null && Object.hasOwnProperty.call(message, \"context\"))\n            $root.StatsContext.encode(message.context, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ContextualizedQueryLatencyStats message, length delimited. Does not implicitly {@link ContextualizedQueryLatencyStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {IContextualizedQueryLatencyStats} message ContextualizedQueryLatencyStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedQueryLatencyStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ContextualizedQueryLatencyStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ContextualizedQueryLatencyStats} ContextualizedQueryLatencyStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedQueryLatencyStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ContextualizedQueryLatencyStats();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());\n                break;\n            case 2:\n                message.context = $root.StatsContext.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ContextualizedQueryLatencyStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ContextualizedQueryLatencyStats} ContextualizedQueryLatencyStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedQueryLatencyStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ContextualizedQueryLatencyStats message.\n     * @function verify\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ContextualizedQueryLatencyStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\")) {\n            var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);\n            if (error)\n                return \"queryLatencyStats.\" + error;\n        }\n        if (message.context != null && message.hasOwnProperty(\"context\")) {\n            var error = $root.StatsContext.verify(message.context);\n            if (error)\n                return \"context.\" + error;\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a ContextualizedQueryLatencyStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ContextualizedQueryLatencyStats\n     * @static\n     * @param {ContextualizedQueryLatencyStats} message ContextualizedQueryLatencyStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ContextualizedQueryLatencyStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.queryLatencyStats = null;\n            object.context = null;\n        }\n        if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\"))\n            object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);\n        if (message.context != null && message.hasOwnProperty(\"context\"))\n            object.context = $root.StatsContext.toObject(message.context, options);\n        return object;\n    };\n\n    /**\n     * Converts this ContextualizedQueryLatencyStats to JSON.\n     * @function toJSON\n     * @memberof ContextualizedQueryLatencyStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ContextualizedQueryLatencyStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ContextualizedQueryLatencyStats;\n})();\n\n$root.ContextualizedTypeStats = (function() {\n\n    /**\n     * Properties of a ContextualizedTypeStats.\n     * @exports IContextualizedTypeStats\n     * @interface IContextualizedTypeStats\n     * @property {IStatsContext|null} [context] ContextualizedTypeStats context\n     * @property {Object.<string,ITypeStat>|null} [perTypeStat] ContextualizedTypeStats perTypeStat\n     */\n\n    /**\n     * Constructs a new ContextualizedTypeStats.\n     * @exports ContextualizedTypeStats\n     * @classdesc Represents a ContextualizedTypeStats.\n     * @implements IContextualizedTypeStats\n     * @constructor\n     * @param {IContextualizedTypeStats=} [properties] Properties to set\n     */\n    function ContextualizedTypeStats(properties) {\n        this.perTypeStat = {};\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ContextualizedTypeStats context.\n     * @member {IStatsContext|null|undefined} context\n     * @memberof ContextualizedTypeStats\n     * @instance\n     */\n    ContextualizedTypeStats.prototype.context = null;\n\n    /**\n     * ContextualizedTypeStats perTypeStat.\n     * @member {Object.<string,ITypeStat>} perTypeStat\n     * @memberof ContextualizedTypeStats\n     * @instance\n     */\n    ContextualizedTypeStats.prototype.perTypeStat = $util.emptyObject;\n\n    /**\n     * Creates a new ContextualizedTypeStats instance using the specified properties.\n     * @function create\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {IContextualizedTypeStats=} [properties] Properties to set\n     * @returns {ContextualizedTypeStats} ContextualizedTypeStats instance\n     */\n    ContextualizedTypeStats.create = function create(properties) {\n        return new ContextualizedTypeStats(properties);\n    };\n\n    /**\n     * Encodes the specified ContextualizedTypeStats message. Does not implicitly {@link ContextualizedTypeStats.verify|verify} messages.\n     * @function encode\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {IContextualizedTypeStats} message ContextualizedTypeStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedTypeStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.context != null && Object.hasOwnProperty.call(message, \"context\"))\n            $root.StatsContext.encode(message.context, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, \"perTypeStat\"))\n            for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ContextualizedTypeStats message, length delimited. Does not implicitly {@link ContextualizedTypeStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {IContextualizedTypeStats} message ContextualizedTypeStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedTypeStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ContextualizedTypeStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ContextualizedTypeStats} ContextualizedTypeStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedTypeStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ContextualizedTypeStats(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.context = $root.StatsContext.decode(reader, reader.uint32());\n                break;\n            case 2:\n                reader.skip().pos++;\n                if (message.perTypeStat === $util.emptyObject)\n                    message.perTypeStat = {};\n                key = reader.string();\n                reader.pos++;\n                message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ContextualizedTypeStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ContextualizedTypeStats} ContextualizedTypeStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedTypeStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ContextualizedTypeStats message.\n     * @function verify\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ContextualizedTypeStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.context != null && message.hasOwnProperty(\"context\")) {\n            var error = $root.StatsContext.verify(message.context);\n            if (error)\n                return \"context.\" + error;\n        }\n        if (message.perTypeStat != null && message.hasOwnProperty(\"perTypeStat\")) {\n            if (!$util.isObject(message.perTypeStat))\n                return \"perTypeStat: object expected\";\n            var key = Object.keys(message.perTypeStat);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);\n                if (error)\n                    return \"perTypeStat.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a ContextualizedTypeStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ContextualizedTypeStats\n     * @static\n     * @param {ContextualizedTypeStats} message ContextualizedTypeStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ContextualizedTypeStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.objects || options.defaults)\n            object.perTypeStat = {};\n        if (options.defaults)\n            object.context = null;\n        if (message.context != null && message.hasOwnProperty(\"context\"))\n            object.context = $root.StatsContext.toObject(message.context, options);\n        var keys2;\n        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {\n            object.perTypeStat = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ContextualizedTypeStats to JSON.\n     * @function toJSON\n     * @memberof ContextualizedTypeStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ContextualizedTypeStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ContextualizedTypeStats;\n})();\n\n$root.FieldStat = (function() {\n\n    /**\n     * Properties of a FieldStat.\n     * @exports IFieldStat\n     * @interface IFieldStat\n     * @property {string|null} [returnType] FieldStat returnType\n     * @property {number|null} [errorsCount] FieldStat errorsCount\n     * @property {number|null} [count] FieldStat count\n     * @property {number|null} [requestsWithErrorsCount] FieldStat requestsWithErrorsCount\n     * @property {$protobuf.ToArray.<number>|Array.<number>|null} [latencyCount] FieldStat latencyCount\n     */\n\n    /**\n     * Constructs a new FieldStat.\n     * @exports FieldStat\n     * @classdesc Represents a FieldStat.\n     * @implements IFieldStat\n     * @constructor\n     * @param {IFieldStat=} [properties] Properties to set\n     */\n    function FieldStat(properties) {\n        this.latencyCount = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * FieldStat returnType.\n     * @member {string} returnType\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.returnType = \"\";\n\n    /**\n     * FieldStat errorsCount.\n     * @member {number} errorsCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.errorsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * FieldStat count.\n     * @member {number} count\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.count = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * FieldStat requestsWithErrorsCount.\n     * @member {number} requestsWithErrorsCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.requestsWithErrorsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * FieldStat latencyCount.\n     * @member {Array.<number>} latencyCount\n     * @memberof FieldStat\n     * @instance\n     */\n    FieldStat.prototype.latencyCount = $util.emptyArray;\n\n    /**\n     * Creates a new FieldStat instance using the specified properties.\n     * @function create\n     * @memberof FieldStat\n     * @static\n     * @param {IFieldStat=} [properties] Properties to set\n     * @returns {FieldStat} FieldStat instance\n     */\n    FieldStat.create = function create(properties) {\n        return new FieldStat(properties);\n    };\n\n    /**\n     * Encodes the specified FieldStat message. Does not implicitly {@link FieldStat.verify|verify} messages.\n     * @function encode\n     * @memberof FieldStat\n     * @static\n     * @param {IFieldStat} message FieldStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FieldStat.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.returnType != null && Object.hasOwnProperty.call(message, \"returnType\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.returnType);\n        if (message.errorsCount != null && Object.hasOwnProperty.call(message, \"errorsCount\"))\n            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.errorsCount);\n        if (message.count != null && Object.hasOwnProperty.call(message, \"count\"))\n            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.count);\n        if (message.requestsWithErrorsCount != null && Object.hasOwnProperty.call(message, \"requestsWithErrorsCount\"))\n            writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.requestsWithErrorsCount);\n        var array9;\n        if (message.latencyCount != null && message.latencyCount.toArray)\n            array9 = message.latencyCount.toArray();\n        else\n            array9 = message.latencyCount;\n        if (array9 != null && array9.length) {\n            writer.uint32(/* id 9, wireType 2 =*/74).fork();\n            for (var i = 0; i < array9.length; ++i)\n                writer.sint64(array9[i]);\n            writer.ldelim();\n        }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified FieldStat message, length delimited. Does not implicitly {@link FieldStat.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof FieldStat\n     * @static\n     * @param {IFieldStat} message FieldStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    FieldStat.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a FieldStat message from the specified reader or buffer.\n     * @function decode\n     * @memberof FieldStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {FieldStat} FieldStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FieldStat.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.FieldStat();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 3:\n                message.returnType = reader.string();\n                break;\n            case 4:\n                message.errorsCount = reader.uint64();\n                break;\n            case 5:\n                message.count = reader.uint64();\n                break;\n            case 6:\n                message.requestsWithErrorsCount = reader.uint64();\n                break;\n            case 9:\n                if (!(message.latencyCount && message.latencyCount.length))\n                    message.latencyCount = [];\n                if ((tag & 7) === 2) {\n                    var end2 = reader.uint32() + reader.pos;\n                    while (reader.pos < end2)\n                        message.latencyCount.push(reader.sint64());\n                } else\n                    message.latencyCount.push(reader.sint64());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a FieldStat message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof FieldStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {FieldStat} FieldStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    FieldStat.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a FieldStat message.\n     * @function verify\n     * @memberof FieldStat\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    FieldStat.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            if (!$util.isString(message.returnType))\n                return \"returnType: string expected\";\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (!$util.isInteger(message.errorsCount) && !(message.errorsCount && $util.isInteger(message.errorsCount.low) && $util.isInteger(message.errorsCount.high)))\n                return \"errorsCount: integer|Long expected\";\n        if (message.count != null && message.hasOwnProperty(\"count\"))\n            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))\n                return \"count: integer|Long expected\";\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (!$util.isInteger(message.requestsWithErrorsCount) && !(message.requestsWithErrorsCount && $util.isInteger(message.requestsWithErrorsCount.low) && $util.isInteger(message.requestsWithErrorsCount.high)))\n                return \"requestsWithErrorsCount: integer|Long expected\";\n        if (message.latencyCount != null && message.hasOwnProperty(\"latencyCount\")) {\n            var array9;\n            if (message.latencyCount != null && message.latencyCount.toArray)\n                array9 = message.latencyCount.toArray();\n            else\n                array9 = message.latencyCount;\n            if (!Array.isArray(array9))\n                return \"latencyCount: array expected\";\n            for (var i = 0; i < array9.length; ++i)\n                if (!$util.isInteger(array9[i]) && !(array9[i] && $util.isInteger(array9[i].low) && $util.isInteger(array9[i].high)))\n                    return \"latencyCount: integer|Long[] expected\";\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a FieldStat message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof FieldStat\n     * @static\n     * @param {FieldStat} message FieldStat\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    FieldStat.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.latencyCount = [];\n        if (options.defaults) {\n            object.returnType = \"\";\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.errorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.errorsCount = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.count = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var long = new $util.Long(0, 0, true);\n                object.requestsWithErrorsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n                object.requestsWithErrorsCount = options.longs === String ? \"0\" : 0;\n        }\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            object.returnType = message.returnType;\n        if (message.errorsCount != null && message.hasOwnProperty(\"errorsCount\"))\n            if (typeof message.errorsCount === \"number\")\n                object.errorsCount = options.longs === String ? String(message.errorsCount) : message.errorsCount;\n            else\n                object.errorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.errorsCount) : options.longs === Number ? new $util.LongBits(message.errorsCount.low >>> 0, message.errorsCount.high >>> 0).toNumber(true) : message.errorsCount;\n        if (message.count != null && message.hasOwnProperty(\"count\"))\n            if (typeof message.count === \"number\")\n                object.count = options.longs === String ? String(message.count) : message.count;\n            else\n                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber(true) : message.count;\n        if (message.requestsWithErrorsCount != null && message.hasOwnProperty(\"requestsWithErrorsCount\"))\n            if (typeof message.requestsWithErrorsCount === \"number\")\n                object.requestsWithErrorsCount = options.longs === String ? String(message.requestsWithErrorsCount) : message.requestsWithErrorsCount;\n            else\n                object.requestsWithErrorsCount = options.longs === String ? $util.Long.prototype.toString.call(message.requestsWithErrorsCount) : options.longs === Number ? new $util.LongBits(message.requestsWithErrorsCount.low >>> 0, message.requestsWithErrorsCount.high >>> 0).toNumber(true) : message.requestsWithErrorsCount;\n        if (message.latencyCount && message.latencyCount.length) {\n            object.latencyCount = [];\n            for (var j = 0; j < message.latencyCount.length; ++j)\n                if (typeof message.latencyCount[j] === \"number\")\n                    object.latencyCount[j] = options.longs === String ? String(message.latencyCount[j]) : message.latencyCount[j];\n                else\n                    object.latencyCount[j] = options.longs === String ? $util.Long.prototype.toString.call(message.latencyCount[j]) : options.longs === Number ? new $util.LongBits(message.latencyCount[j].low >>> 0, message.latencyCount[j].high >>> 0).toNumber() : message.latencyCount[j];\n        }\n        return object;\n    };\n\n    /**\n     * Converts this FieldStat to JSON.\n     * @function toJSON\n     * @memberof FieldStat\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    FieldStat.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return FieldStat;\n})();\n\n$root.TypeStat = (function() {\n\n    /**\n     * Properties of a TypeStat.\n     * @exports ITypeStat\n     * @interface ITypeStat\n     * @property {Object.<string,IFieldStat>|null} [perFieldStat] TypeStat perFieldStat\n     */\n\n    /**\n     * Constructs a new TypeStat.\n     * @exports TypeStat\n     * @classdesc Represents a TypeStat.\n     * @implements ITypeStat\n     * @constructor\n     * @param {ITypeStat=} [properties] Properties to set\n     */\n    function TypeStat(properties) {\n        this.perFieldStat = {};\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TypeStat perFieldStat.\n     * @member {Object.<string,IFieldStat>} perFieldStat\n     * @memberof TypeStat\n     * @instance\n     */\n    TypeStat.prototype.perFieldStat = $util.emptyObject;\n\n    /**\n     * Creates a new TypeStat instance using the specified properties.\n     * @function create\n     * @memberof TypeStat\n     * @static\n     * @param {ITypeStat=} [properties] Properties to set\n     * @returns {TypeStat} TypeStat instance\n     */\n    TypeStat.create = function create(properties) {\n        return new TypeStat(properties);\n    };\n\n    /**\n     * Encodes the specified TypeStat message. Does not implicitly {@link TypeStat.verify|verify} messages.\n     * @function encode\n     * @memberof TypeStat\n     * @static\n     * @param {ITypeStat} message TypeStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TypeStat.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.perFieldStat != null && Object.hasOwnProperty.call(message, \"perFieldStat\"))\n            for (var keys = Object.keys(message.perFieldStat), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.FieldStat.encode(message.perFieldStat[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TypeStat message, length delimited. Does not implicitly {@link TypeStat.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TypeStat\n     * @static\n     * @param {ITypeStat} message TypeStat message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TypeStat.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TypeStat message from the specified reader or buffer.\n     * @function decode\n     * @memberof TypeStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TypeStat} TypeStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TypeStat.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TypeStat(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 3:\n                reader.skip().pos++;\n                if (message.perFieldStat === $util.emptyObject)\n                    message.perFieldStat = {};\n                key = reader.string();\n                reader.pos++;\n                message.perFieldStat[key] = $root.FieldStat.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a TypeStat message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TypeStat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TypeStat} TypeStat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TypeStat.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TypeStat message.\n     * @function verify\n     * @memberof TypeStat\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TypeStat.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.perFieldStat != null && message.hasOwnProperty(\"perFieldStat\")) {\n            if (!$util.isObject(message.perFieldStat))\n                return \"perFieldStat: object expected\";\n            var key = Object.keys(message.perFieldStat);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.FieldStat.verify(message.perFieldStat[key[i]]);\n                if (error)\n                    return \"perFieldStat.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a TypeStat message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TypeStat\n     * @static\n     * @param {TypeStat} message TypeStat\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TypeStat.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.objects || options.defaults)\n            object.perFieldStat = {};\n        var keys2;\n        if (message.perFieldStat && (keys2 = Object.keys(message.perFieldStat)).length) {\n            object.perFieldStat = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.perFieldStat[keys2[j]] = $root.FieldStat.toObject(message.perFieldStat[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this TypeStat to JSON.\n     * @function toJSON\n     * @memberof TypeStat\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TypeStat.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return TypeStat;\n})();\n\n$root.Field = (function() {\n\n    /**\n     * Properties of a Field.\n     * @exports IField\n     * @interface IField\n     * @property {string|null} [name] Field name\n     * @property {string|null} [returnType] Field returnType\n     */\n\n    /**\n     * Constructs a new Field.\n     * @exports Field\n     * @classdesc Represents a Field.\n     * @implements IField\n     * @constructor\n     * @param {IField=} [properties] Properties to set\n     */\n    function Field(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Field name.\n     * @member {string} name\n     * @memberof Field\n     * @instance\n     */\n    Field.prototype.name = \"\";\n\n    /**\n     * Field returnType.\n     * @member {string} returnType\n     * @memberof Field\n     * @instance\n     */\n    Field.prototype.returnType = \"\";\n\n    /**\n     * Creates a new Field instance using the specified properties.\n     * @function create\n     * @memberof Field\n     * @static\n     * @param {IField=} [properties] Properties to set\n     * @returns {Field} Field instance\n     */\n    Field.create = function create(properties) {\n        return new Field(properties);\n    };\n\n    /**\n     * Encodes the specified Field message. Does not implicitly {@link Field.verify|verify} messages.\n     * @function encode\n     * @memberof Field\n     * @static\n     * @param {IField} message Field message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Field.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n        if (message.returnType != null && Object.hasOwnProperty.call(message, \"returnType\"))\n            writer.uint32(/* id 3, wireType 2 =*/26).string(message.returnType);\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Field message, length delimited. Does not implicitly {@link Field.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Field\n     * @static\n     * @param {IField} message Field message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Field.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Field message from the specified reader or buffer.\n     * @function decode\n     * @memberof Field\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Field} Field\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Field.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Field();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 2:\n                message.name = reader.string();\n                break;\n            case 3:\n                message.returnType = reader.string();\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Field message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Field\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Field} Field\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Field.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Field message.\n     * @function verify\n     * @memberof Field\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Field.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            if (!$util.isString(message.name))\n                return \"name: string expected\";\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            if (!$util.isString(message.returnType))\n                return \"returnType: string expected\";\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a Field message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Field\n     * @static\n     * @param {Field} message Field\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Field.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.name = \"\";\n            object.returnType = \"\";\n        }\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n        if (message.returnType != null && message.hasOwnProperty(\"returnType\"))\n            object.returnType = message.returnType;\n        return object;\n    };\n\n    /**\n     * Converts this Field to JSON.\n     * @function toJSON\n     * @memberof Field\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Field.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Field;\n})();\n\n$root.Type = (function() {\n\n    /**\n     * Properties of a Type.\n     * @exports IType\n     * @interface IType\n     * @property {string|null} [name] Type name\n     * @property {Array.<IField>|null} [field] Type field\n     */\n\n    /**\n     * Constructs a new Type.\n     * @exports Type\n     * @classdesc Represents a Type.\n     * @implements IType\n     * @constructor\n     * @param {IType=} [properties] Properties to set\n     */\n    function Type(properties) {\n        this.field = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Type name.\n     * @member {string} name\n     * @memberof Type\n     * @instance\n     */\n    Type.prototype.name = \"\";\n\n    /**\n     * Type field.\n     * @member {Array.<IField>} field\n     * @memberof Type\n     * @instance\n     */\n    Type.prototype.field = $util.emptyArray;\n\n    /**\n     * Creates a new Type instance using the specified properties.\n     * @function create\n     * @memberof Type\n     * @static\n     * @param {IType=} [properties] Properties to set\n     * @returns {Type} Type instance\n     */\n    Type.create = function create(properties) {\n        return new Type(properties);\n    };\n\n    /**\n     * Encodes the specified Type message. Does not implicitly {@link Type.verify|verify} messages.\n     * @function encode\n     * @memberof Type\n     * @static\n     * @param {IType} message Type message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Type.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n        if (message.field != null && message.field.length)\n            for (var i = 0; i < message.field.length; ++i)\n                $root.Field.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Type message, length delimited. Does not implicitly {@link Type.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Type\n     * @static\n     * @param {IType} message Type message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Type.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Type message from the specified reader or buffer.\n     * @function decode\n     * @memberof Type\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Type} Type\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Type.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Type();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.name = reader.string();\n                break;\n            case 2:\n                if (!(message.field && message.field.length))\n                    message.field = [];\n                message.field.push($root.Field.decode(reader, reader.uint32()));\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Type message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Type\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Type} Type\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Type.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Type message.\n     * @function verify\n     * @memberof Type\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Type.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            if (!$util.isString(message.name))\n                return \"name: string expected\";\n        if (message.field != null && message.hasOwnProperty(\"field\")) {\n            if (!Array.isArray(message.field))\n                return \"field: array expected\";\n            for (var i = 0; i < message.field.length; ++i) {\n                var error = $root.Field.verify(message.field[i]);\n                if (error)\n                    return \"field.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a Type message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Type\n     * @static\n     * @param {Type} message Type\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Type.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.field = [];\n        if (options.defaults)\n            object.name = \"\";\n        if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n        if (message.field && message.field.length) {\n            object.field = [];\n            for (var j = 0; j < message.field.length; ++j)\n                object.field[j] = $root.Field.toObject(message.field[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Type to JSON.\n     * @function toJSON\n     * @memberof Type\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Type.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Type;\n})();\n\n$root.Report = (function() {\n\n    /**\n     * Properties of a Report.\n     * @exports IReport\n     * @interface IReport\n     * @property {IReportHeader|null} [header] Report header\n     * @property {Object.<string,ITracesAndStats>|null} [tracesPerQuery] Report tracesPerQuery\n     * @property {google.protobuf.ITimestamp|null} [endTime] Report endTime\n     */\n\n    /**\n     * Constructs a new Report.\n     * @exports Report\n     * @classdesc Represents a Report.\n     * @implements IReport\n     * @constructor\n     * @param {IReport=} [properties] Properties to set\n     */\n    function Report(properties) {\n        this.tracesPerQuery = {};\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * Report header.\n     * @member {IReportHeader|null|undefined} header\n     * @memberof Report\n     * @instance\n     */\n    Report.prototype.header = null;\n\n    /**\n     * Report tracesPerQuery.\n     * @member {Object.<string,ITracesAndStats>} tracesPerQuery\n     * @memberof Report\n     * @instance\n     */\n    Report.prototype.tracesPerQuery = $util.emptyObject;\n\n    /**\n     * Report endTime.\n     * @member {google.protobuf.ITimestamp|null|undefined} endTime\n     * @memberof Report\n     * @instance\n     */\n    Report.prototype.endTime = null;\n\n    /**\n     * Creates a new Report instance using the specified properties.\n     * @function create\n     * @memberof Report\n     * @static\n     * @param {IReport=} [properties] Properties to set\n     * @returns {Report} Report instance\n     */\n    Report.create = function create(properties) {\n        return new Report(properties);\n    };\n\n    /**\n     * Encodes the specified Report message. Does not implicitly {@link Report.verify|verify} messages.\n     * @function encode\n     * @memberof Report\n     * @static\n     * @param {IReport} message Report message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Report.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.header != null && Object.hasOwnProperty.call(message, \"header\"))\n            $root.ReportHeader.encode(message.header, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.endTime != null && Object.hasOwnProperty.call(message, \"endTime\"))\n            $root.google.protobuf.Timestamp.encode(message.endTime, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.tracesPerQuery != null && Object.hasOwnProperty.call(message, \"tracesPerQuery\"))\n            for (var keys = Object.keys(message.tracesPerQuery), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.TracesAndStats.encode(message.tracesPerQuery[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified Report message, length delimited. Does not implicitly {@link Report.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Report\n     * @static\n     * @param {IReport} message Report message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Report.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a Report message from the specified reader or buffer.\n     * @function decode\n     * @memberof Report\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Report} Report\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Report.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Report(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.header = $root.ReportHeader.decode(reader, reader.uint32());\n                break;\n            case 5:\n                reader.skip().pos++;\n                if (message.tracesPerQuery === $util.emptyObject)\n                    message.tracesPerQuery = {};\n                key = reader.string();\n                reader.pos++;\n                message.tracesPerQuery[key] = $root.TracesAndStats.decode(reader, reader.uint32());\n                break;\n            case 2:\n                message.endTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a Report message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Report\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Report} Report\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Report.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a Report message.\n     * @function verify\n     * @memberof Report\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Report.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.header != null && message.hasOwnProperty(\"header\")) {\n            var error = $root.ReportHeader.verify(message.header);\n            if (error)\n                return \"header.\" + error;\n        }\n        if (message.tracesPerQuery != null && message.hasOwnProperty(\"tracesPerQuery\")) {\n            if (!$util.isObject(message.tracesPerQuery))\n                return \"tracesPerQuery: object expected\";\n            var key = Object.keys(message.tracesPerQuery);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.TracesAndStats.verify(message.tracesPerQuery[key[i]]);\n                if (error)\n                    return \"tracesPerQuery.\" + error;\n            }\n        }\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\")) {\n            var error = $root.google.protobuf.Timestamp.verify(message.endTime);\n            if (error)\n                return \"endTime.\" + error;\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a Report message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Report\n     * @static\n     * @param {Report} message Report\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Report.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.objects || options.defaults)\n            object.tracesPerQuery = {};\n        if (options.defaults) {\n            object.header = null;\n            object.endTime = null;\n        }\n        if (message.header != null && message.hasOwnProperty(\"header\"))\n            object.header = $root.ReportHeader.toObject(message.header, options);\n        if (message.endTime != null && message.hasOwnProperty(\"endTime\"))\n            object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);\n        var keys2;\n        if (message.tracesPerQuery && (keys2 = Object.keys(message.tracesPerQuery)).length) {\n            object.tracesPerQuery = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.tracesPerQuery[keys2[j]] = $root.TracesAndStats.toObject(message.tracesPerQuery[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this Report to JSON.\n     * @function toJSON\n     * @memberof Report\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Report.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Report;\n})();\n\n$root.ContextualizedStats = (function() {\n\n    /**\n     * Properties of a ContextualizedStats.\n     * @exports IContextualizedStats\n     * @interface IContextualizedStats\n     * @property {IStatsContext|null} [context] ContextualizedStats context\n     * @property {IQueryLatencyStats|null} [queryLatencyStats] ContextualizedStats queryLatencyStats\n     * @property {Object.<string,ITypeStat>|null} [perTypeStat] ContextualizedStats perTypeStat\n     */\n\n    /**\n     * Constructs a new ContextualizedStats.\n     * @exports ContextualizedStats\n     * @classdesc Represents a ContextualizedStats.\n     * @implements IContextualizedStats\n     * @constructor\n     * @param {IContextualizedStats=} [properties] Properties to set\n     */\n    function ContextualizedStats(properties) {\n        this.perTypeStat = {};\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * ContextualizedStats context.\n     * @member {IStatsContext|null|undefined} context\n     * @memberof ContextualizedStats\n     * @instance\n     */\n    ContextualizedStats.prototype.context = null;\n\n    /**\n     * ContextualizedStats queryLatencyStats.\n     * @member {IQueryLatencyStats|null|undefined} queryLatencyStats\n     * @memberof ContextualizedStats\n     * @instance\n     */\n    ContextualizedStats.prototype.queryLatencyStats = null;\n\n    /**\n     * ContextualizedStats perTypeStat.\n     * @member {Object.<string,ITypeStat>} perTypeStat\n     * @memberof ContextualizedStats\n     * @instance\n     */\n    ContextualizedStats.prototype.perTypeStat = $util.emptyObject;\n\n    /**\n     * Creates a new ContextualizedStats instance using the specified properties.\n     * @function create\n     * @memberof ContextualizedStats\n     * @static\n     * @param {IContextualizedStats=} [properties] Properties to set\n     * @returns {ContextualizedStats} ContextualizedStats instance\n     */\n    ContextualizedStats.create = function create(properties) {\n        return new ContextualizedStats(properties);\n    };\n\n    /**\n     * Encodes the specified ContextualizedStats message. Does not implicitly {@link ContextualizedStats.verify|verify} messages.\n     * @function encode\n     * @memberof ContextualizedStats\n     * @static\n     * @param {IContextualizedStats} message ContextualizedStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.context != null && Object.hasOwnProperty.call(message, \"context\"))\n            $root.StatsContext.encode(message.context, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        if (message.queryLatencyStats != null && Object.hasOwnProperty.call(message, \"queryLatencyStats\"))\n            $root.QueryLatencyStats.encode(message.queryLatencyStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.perTypeStat != null && Object.hasOwnProperty.call(message, \"perTypeStat\"))\n            for (var keys = Object.keys(message.perTypeStat), i = 0; i < keys.length; ++i) {\n                writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                $root.TypeStat.encode(message.perTypeStat[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n            }\n        return writer;\n    };\n\n    /**\n     * Encodes the specified ContextualizedStats message, length delimited. Does not implicitly {@link ContextualizedStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof ContextualizedStats\n     * @static\n     * @param {IContextualizedStats} message ContextualizedStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    ContextualizedStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a ContextualizedStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof ContextualizedStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ContextualizedStats} ContextualizedStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ContextualizedStats(), key;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                message.context = $root.StatsContext.decode(reader, reader.uint32());\n                break;\n            case 2:\n                message.queryLatencyStats = $root.QueryLatencyStats.decode(reader, reader.uint32());\n                break;\n            case 3:\n                reader.skip().pos++;\n                if (message.perTypeStat === $util.emptyObject)\n                    message.perTypeStat = {};\n                key = reader.string();\n                reader.pos++;\n                message.perTypeStat[key] = $root.TypeStat.decode(reader, reader.uint32());\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a ContextualizedStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof ContextualizedStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {ContextualizedStats} ContextualizedStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ContextualizedStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a ContextualizedStats message.\n     * @function verify\n     * @memberof ContextualizedStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    ContextualizedStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.context != null && message.hasOwnProperty(\"context\")) {\n            var error = $root.StatsContext.verify(message.context);\n            if (error)\n                return \"context.\" + error;\n        }\n        if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\")) {\n            var error = $root.QueryLatencyStats.verify(message.queryLatencyStats);\n            if (error)\n                return \"queryLatencyStats.\" + error;\n        }\n        if (message.perTypeStat != null && message.hasOwnProperty(\"perTypeStat\")) {\n            if (!$util.isObject(message.perTypeStat))\n                return \"perTypeStat: object expected\";\n            var key = Object.keys(message.perTypeStat);\n            for (var i = 0; i < key.length; ++i) {\n                var error = $root.TypeStat.verify(message.perTypeStat[key[i]]);\n                if (error)\n                    return \"perTypeStat.\" + error;\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a ContextualizedStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof ContextualizedStats\n     * @static\n     * @param {ContextualizedStats} message ContextualizedStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    ContextualizedStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.objects || options.defaults)\n            object.perTypeStat = {};\n        if (options.defaults) {\n            object.context = null;\n            object.queryLatencyStats = null;\n        }\n        if (message.context != null && message.hasOwnProperty(\"context\"))\n            object.context = $root.StatsContext.toObject(message.context, options);\n        if (message.queryLatencyStats != null && message.hasOwnProperty(\"queryLatencyStats\"))\n            object.queryLatencyStats = $root.QueryLatencyStats.toObject(message.queryLatencyStats, options);\n        var keys2;\n        if (message.perTypeStat && (keys2 = Object.keys(message.perTypeStat)).length) {\n            object.perTypeStat = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.perTypeStat[keys2[j]] = $root.TypeStat.toObject(message.perTypeStat[keys2[j]], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this ContextualizedStats to JSON.\n     * @function toJSON\n     * @memberof ContextualizedStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    ContextualizedStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return ContextualizedStats;\n})();\n\n$root.TracesAndStats = (function() {\n\n    /**\n     * Properties of a TracesAndStats.\n     * @exports ITracesAndStats\n     * @interface ITracesAndStats\n     * @property {Array.<ITrace|Uint8Array>|null} [trace] TracesAndStats trace\n     * @property {$protobuf.ToArray.<IContextualizedStats>|Array.<IContextualizedStats>|null} [statsWithContext] TracesAndStats statsWithContext\n     * @property {Array.<ITrace|Uint8Array>|null} [internalTracesContributingToStats] TracesAndStats internalTracesContributingToStats\n     */\n\n    /**\n     * Constructs a new TracesAndStats.\n     * @exports TracesAndStats\n     * @classdesc Represents a TracesAndStats.\n     * @implements ITracesAndStats\n     * @constructor\n     * @param {ITracesAndStats=} [properties] Properties to set\n     */\n    function TracesAndStats(properties) {\n        this.trace = [];\n        this.statsWithContext = [];\n        this.internalTracesContributingToStats = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n\n    /**\n     * TracesAndStats trace.\n     * @member {Array.<ITrace|Uint8Array>} trace\n     * @memberof TracesAndStats\n     * @instance\n     */\n    TracesAndStats.prototype.trace = $util.emptyArray;\n\n    /**\n     * TracesAndStats statsWithContext.\n     * @member {Array.<IContextualizedStats>} statsWithContext\n     * @memberof TracesAndStats\n     * @instance\n     */\n    TracesAndStats.prototype.statsWithContext = $util.emptyArray;\n\n    /**\n     * TracesAndStats internalTracesContributingToStats.\n     * @member {Array.<ITrace|Uint8Array>} internalTracesContributingToStats\n     * @memberof TracesAndStats\n     * @instance\n     */\n    TracesAndStats.prototype.internalTracesContributingToStats = $util.emptyArray;\n\n    /**\n     * Creates a new TracesAndStats instance using the specified properties.\n     * @function create\n     * @memberof TracesAndStats\n     * @static\n     * @param {ITracesAndStats=} [properties] Properties to set\n     * @returns {TracesAndStats} TracesAndStats instance\n     */\n    TracesAndStats.create = function create(properties) {\n        return new TracesAndStats(properties);\n    };\n\n    /**\n     * Encodes the specified TracesAndStats message. Does not implicitly {@link TracesAndStats.verify|verify} messages.\n     * @function encode\n     * @memberof TracesAndStats\n     * @static\n     * @param {ITracesAndStats} message TracesAndStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TracesAndStats.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.trace != null && message.trace.length)\n            for (var i = 0; i < message.trace.length; ++i)\n                if (message.trace[i] instanceof Uint8Array) {\n                    writer.uint32(/* id 1, wireType 2 =*/10);\n                    writer.bytes(message.trace[i]);\n                } else\n                    $root.Trace.encode(message.trace[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n        var array2;\n        if (message.statsWithContext != null && message.statsWithContext.toArray)\n            array2 = message.statsWithContext.toArray();\n        else\n            array2 = message.statsWithContext;\n        if (array2 != null && array2.length)\n            for (var i = 0; i < array2.length; ++i)\n                $root.ContextualizedStats.encode(array2[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n        if (message.internalTracesContributingToStats != null && message.internalTracesContributingToStats.length)\n            for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)\n                if (message.internalTracesContributingToStats[i] instanceof Uint8Array) {\n                    writer.uint32(/* id 3, wireType 2 =*/26);\n                    writer.bytes(message.internalTracesContributingToStats[i]);\n                } else\n                    $root.Trace.encode(message.internalTracesContributingToStats[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n        return writer;\n    };\n\n    /**\n     * Encodes the specified TracesAndStats message, length delimited. Does not implicitly {@link TracesAndStats.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof TracesAndStats\n     * @static\n     * @param {ITracesAndStats} message TracesAndStats message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    TracesAndStats.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n\n    /**\n     * Decodes a TracesAndStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof TracesAndStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TracesAndStats} TracesAndStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TracesAndStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.TracesAndStats();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n            case 1:\n                if (!(message.trace && message.trace.length))\n                    message.trace = [];\n                message.trace.push($root.Trace.decode(reader, reader.uint32()));\n                break;\n            case 2:\n                if (!(message.statsWithContext && message.statsWithContext.length))\n                    message.statsWithContext = [];\n                message.statsWithContext.push($root.ContextualizedStats.decode(reader, reader.uint32()));\n                break;\n            case 3:\n                if (!(message.internalTracesContributingToStats && message.internalTracesContributingToStats.length))\n                    message.internalTracesContributingToStats = [];\n                message.internalTracesContributingToStats.push($root.Trace.decode(reader, reader.uint32()));\n                break;\n            default:\n                reader.skipType(tag & 7);\n                break;\n            }\n        }\n        return message;\n    };\n\n    /**\n     * Decodes a TracesAndStats message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof TracesAndStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {TracesAndStats} TracesAndStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TracesAndStats.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n\n    /**\n     * Verifies a TracesAndStats message.\n     * @function verify\n     * @memberof TracesAndStats\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    TracesAndStats.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.trace != null && message.hasOwnProperty(\"trace\")) {\n            if (!Array.isArray(message.trace))\n                return \"trace: array expected\";\n            for (var i = 0; i < message.trace.length; ++i)\n                if (!(message.trace[i] instanceof Uint8Array)) {\n                    var error = $root.Trace.verify(message.trace[i]);\n                    if (error)\n                        return \"trace.\" + error;\n                }\n        }\n        if (message.statsWithContext != null && message.hasOwnProperty(\"statsWithContext\")) {\n            var array2;\n            if (message.statsWithContext != null && message.statsWithContext.toArray)\n                array2 = message.statsWithContext.toArray();\n            else\n                array2 = message.statsWithContext;\n            if (!Array.isArray(array2))\n                return \"statsWithContext: array expected\";\n            for (var i = 0; i < array2.length; ++i) {\n                var error = $root.ContextualizedStats.verify(array2[i]);\n                if (error)\n                    return \"statsWithContext.\" + error;\n            }\n        }\n        if (message.internalTracesContributingToStats != null && message.hasOwnProperty(\"internalTracesContributingToStats\")) {\n            if (!Array.isArray(message.internalTracesContributingToStats))\n                return \"internalTracesContributingToStats: array expected\";\n            for (var i = 0; i < message.internalTracesContributingToStats.length; ++i)\n                if (!(message.internalTracesContributingToStats[i] instanceof Uint8Array)) {\n                    var error = $root.Trace.verify(message.internalTracesContributingToStats[i]);\n                    if (error)\n                        return \"internalTracesContributingToStats.\" + error;\n                }\n        }\n        return null;\n    };\n\n    /**\n     * Creates a plain object from a TracesAndStats message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof TracesAndStats\n     * @static\n     * @param {TracesAndStats} message TracesAndStats\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    TracesAndStats.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults) {\n            object.trace = [];\n            object.statsWithContext = [];\n            object.internalTracesContributingToStats = [];\n        }\n        if (message.trace && message.trace.length) {\n            object.trace = [];\n            for (var j = 0; j < message.trace.length; ++j)\n                object.trace[j] = $root.Trace.toObject(message.trace[j], options);\n        }\n        if (message.statsWithContext && message.statsWithContext.length) {\n            object.statsWithContext = [];\n            for (var j = 0; j < message.statsWithContext.length; ++j)\n                object.statsWithContext[j] = $root.ContextualizedStats.toObject(message.statsWithContext[j], options);\n        }\n        if (message.internalTracesContributingToStats && message.internalTracesContributingToStats.length) {\n            object.internalTracesContributingToStats = [];\n            for (var j = 0; j < message.internalTracesContributingToStats.length; ++j)\n                object.internalTracesContributingToStats[j] = $root.Trace.toObject(message.internalTracesContributingToStats[j], options);\n        }\n        return object;\n    };\n\n    /**\n     * Converts this TracesAndStats to JSON.\n     * @function toJSON\n     * @memberof TracesAndStats\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    TracesAndStats.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return TracesAndStats;\n})();\n\n$root.google = (function() {\n\n    /**\n     * Namespace google.\n     * @exports google\n     * @namespace\n     */\n    var google = {};\n\n    google.protobuf = (function() {\n\n        /**\n         * Namespace protobuf.\n         * @memberof google\n         * @namespace\n         */\n        var protobuf = {};\n\n        protobuf.Timestamp = (function() {\n\n            /**\n             * Properties of a Timestamp.\n             * @memberof google.protobuf\n             * @interface ITimestamp\n             * @property {number|null} [seconds] Timestamp seconds\n             * @property {number|null} [nanos] Timestamp nanos\n             */\n\n            /**\n             * Constructs a new Timestamp.\n             * @memberof google.protobuf\n             * @classdesc Represents a Timestamp.\n             * @implements ITimestamp\n             * @constructor\n             * @param {google.protobuf.ITimestamp=} [properties] Properties to set\n             */\n            function Timestamp(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n\n            /**\n             * Timestamp seconds.\n             * @member {number} seconds\n             * @memberof google.protobuf.Timestamp\n             * @instance\n             */\n            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n            /**\n             * Timestamp nanos.\n             * @member {number} nanos\n             * @memberof google.protobuf.Timestamp\n             * @instance\n             */\n            Timestamp.prototype.nanos = 0;\n\n            /**\n             * Creates a new Timestamp instance using the specified properties.\n             * @function create\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.ITimestamp=} [properties] Properties to set\n             * @returns {google.protobuf.Timestamp} Timestamp instance\n             */\n            Timestamp.create = function create(properties) {\n                return new Timestamp(properties);\n            };\n\n            /**\n             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.\n             * @function encode\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Timestamp.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.seconds != null && Object.hasOwnProperty.call(message, \"seconds\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);\n                if (message.nanos != null && Object.hasOwnProperty.call(message, \"nanos\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);\n                return writer;\n            };\n\n            /**\n             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n\n            /**\n             * Decodes a Timestamp message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.Timestamp} Timestamp\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Timestamp.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.seconds = reader.int64();\n                        break;\n                    case 2:\n                        message.nanos = reader.int32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n\n            /**\n             * Decodes a Timestamp message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {google.protobuf.Timestamp} Timestamp\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Timestamp.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n\n            /**\n             * Verifies a Timestamp message.\n             * @function verify\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Timestamp.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))\n                        return \"seconds: integer|Long expected\";\n                if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                    if (!$util.isInteger(message.nanos))\n                        return \"nanos: integer expected\";\n                return null;\n            };\n\n            /**\n             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof google.protobuf.Timestamp\n             * @static\n             * @param {google.protobuf.Timestamp} message Timestamp\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Timestamp.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults) {\n                    if ($util.Long) {\n                        var long = new $util.Long(0, 0, false);\n                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                    } else\n                        object.seconds = options.longs === String ? \"0\" : 0;\n                    object.nanos = 0;\n                }\n                if (message.seconds != null && message.hasOwnProperty(\"seconds\"))\n                    if (typeof message.seconds === \"number\")\n                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;\n                    else\n                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;\n                if (message.nanos != null && message.hasOwnProperty(\"nanos\"))\n                    object.nanos = message.nanos;\n                return object;\n            };\n\n            /**\n             * Converts this Timestamp to JSON.\n             * @function toJSON\n             * @memberof google.protobuf.Timestamp\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Timestamp.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Timestamp;\n        })();\n\n        return protobuf;\n    })();\n\n    return google;\n})();\n\nmodule.exports = $root;\n"]},"metadata":{},"sourceType":"script"}