{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dispatcher = void 0;\n\nclass Dispatcher {\n  constructor(targets) {\n    this.targets = targets;\n  }\n\n  callTargets(targets, methodName) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return targets.map(target => {\n      const method = target[methodName];\n\n      if (method && typeof method === 'function') {\n        return method.apply(target, args);\n      }\n    });\n  }\n\n  invokeHookAsync(methodName) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return yield Promise.all(this.callTargets(this.targets, methodName, ...args));\n    });\n  }\n\n  invokeHookSync(methodName) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return this.callTargets(this.targets, methodName, ...args);\n  }\n\n  reverseInvokeHookSync(methodName) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n\n    return this.callTargets(this.targets.reverse(), methodName, ...args);\n  }\n\n  invokeHooksUntilNonNull(methodName) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const target of this.targets) {\n        const method = target[methodName];\n\n        if (!(method && typeof method === 'function')) {\n          continue;\n        }\n\n        const value = yield method.apply(target, args);\n\n        if (value !== null) {\n          return value;\n        }\n      }\n\n      return null;\n    });\n  }\n\n  invokeDidStartHook(methodName) {\n    const didEndHooks = [];\n\n    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      args[_key6 - 1] = arguments[_key6];\n    }\n\n    for (const target of this.targets) {\n      const method = target[methodName];\n\n      if (method && typeof method === 'function') {\n        const didEndHook = method.apply(target, args);\n\n        if (didEndHook) {\n          didEndHooks.push(didEndHook);\n        }\n      }\n    }\n\n    return function () {\n      didEndHooks.reverse();\n\n      for (const didEndHook of didEndHooks) {\n        didEndHook(...arguments);\n      }\n    };\n  }\n\n}\n\nexports.Dispatcher = Dispatcher;","map":{"version":3,"sources":["../../src/utils/dispatcher.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA,MAAa,UAAb,CAAuB;AACrB,EAAA,WAAA,CAAsB,OAAtB,EAAkC;AAAZ,SAAA,OAAA,GAAA,OAAA;AAAgB;;AAE9B,EAAA,WAAW,CACjB,OADiB,EAEjB,UAFiB,EAGY;AAAA,sCAA1B,IAA0B;AAA1B,MAAA,IAA0B;AAAA;;AAE7B,WAAO,OAAO,CAAC,GAAR,CAAY,MAAM,IAAG;AAC1B,YAAM,MAAM,GAAG,MAAM,CAAC,UAAD,CAArB;;AACA,UAAI,MAAM,IAAI,OAAO,MAAP,KAAkB,UAAhC,EAA4C;AAC1C,eAAO,MAAM,CAAC,KAAP,CAAa,MAAb,EAAqB,IAArB,CAAP;AACD;AACF,KALM,CAAP;AAMD;;AAEY,EAAA,eAAe,CAC1B,UAD0B,EAEG;AAAA,uCAA1B,IAA0B;AAA1B,MAAA,IAA0B;AAAA;;;AAE7B,aAAO,MAAM,OAAO,CAAC,GAAR,CACX,KAAK,WAAL,CAAiB,KAAK,OAAtB,EAA+B,UAA/B,EAA2C,GAAG,IAA9C,CADW,CAAb;AAED,K;AAAA;;AAEM,EAAA,cAAc,CACnB,UADmB,EAEU;AAAA,uCAA1B,IAA0B;AAA1B,MAAA,IAA0B;AAAA;;AAE7B,WAAO,KAAK,WAAL,CAAiB,KAAK,OAAtB,EAA+B,UAA/B,EAA2C,GAAG,IAA9C,CAAP;AACD;;AAEM,EAAA,qBAAqB,CAC1B,UAD0B,EAEG;AAAA,uCAA1B,IAA0B;AAA1B,MAAA,IAA0B;AAAA;;AAE7B,WAAO,KAAK,WAAL,CAAiB,KAAK,OAAL,CAAa,OAAb,EAAjB,EAAyC,UAAzC,EAAqD,GAAG,IAAxD,CAAP;AACD;;AAEY,EAAA,uBAAuB,CAClC,UADkC,EAEL;AAAA,uCAA1B,IAA0B;AAA1B,MAAA,IAA0B;AAAA;;;AAE7B,WAAK,MAAM,MAAX,IAAqB,KAAK,OAA1B,EAAmC;AACjC,cAAM,MAAM,GAAG,MAAM,CAAC,UAAD,CAArB;;AACA,YAAI,EAAE,MAAM,IAAI,OAAO,MAAP,KAAkB,UAA9B,CAAJ,EAA+C;AAC7C;AACD;;AACD,cAAM,KAAK,GAAG,MAAM,MAAM,CAAC,KAAP,CAAa,MAAb,EAAqB,IAArB,CAApB;;AACA,YAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,iBAAO,KAAP;AACD;AACF;;AACD,aAAO,IAAP;AACD,K;AAAA;;AAEM,EAAA,kBAAkB,CAIvB,UAJuB,EAKM;AAE7B,UAAM,WAAW,GAA+B,EAAhD;;AAF6B,uCAA1B,IAA0B;AAA1B,MAAA,IAA0B;AAAA;;AAI7B,SAAK,MAAM,MAAX,IAAqB,KAAK,OAA1B,EAAmC;AACjC,YAAM,MAAM,GAAG,MAAM,CAAC,UAAD,CAArB;;AACA,UAAI,MAAM,IAAI,OAAO,MAAP,KAAkB,UAAhC,EAA4C;AAC1C,cAAM,UAAU,GAAG,MAAM,CAAC,KAAP,CAAa,MAAb,EAAqB,IAArB,CAAnB;;AACA,YAAI,UAAJ,EAAgB;AACd,UAAA,WAAW,CAAC,IAAZ,CAAiB,UAAjB;AACD;AACF;AACF;;AAED,WAAO,YAA0B;AAC/B,MAAA,WAAW,CAAC,OAAZ;;AAEA,WAAK,MAAM,UAAX,IAAyB,WAAzB,EAAsC;AACpC,QAAA,UAAU,CAAC,YAAD,CAAV;AACD;AACF,KAND;AAOD;;AAjFoB;;AAAvB,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Dispatcher = void 0;\nclass Dispatcher {\n    constructor(targets) {\n        this.targets = targets;\n    }\n    callTargets(targets, methodName, ...args) {\n        return targets.map(target => {\n            const method = target[methodName];\n            if (method && typeof method === 'function') {\n                return method.apply(target, args);\n            }\n        });\n    }\n    invokeHookAsync(methodName, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield Promise.all(this.callTargets(this.targets, methodName, ...args));\n        });\n    }\n    invokeHookSync(methodName, ...args) {\n        return this.callTargets(this.targets, methodName, ...args);\n    }\n    reverseInvokeHookSync(methodName, ...args) {\n        return this.callTargets(this.targets.reverse(), methodName, ...args);\n    }\n    invokeHooksUntilNonNull(methodName, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const target of this.targets) {\n                const method = target[methodName];\n                if (!(method && typeof method === 'function')) {\n                    continue;\n                }\n                const value = yield method.apply(target, args);\n                if (value !== null) {\n                    return value;\n                }\n            }\n            return null;\n        });\n    }\n    invokeDidStartHook(methodName, ...args) {\n        const didEndHooks = [];\n        for (const target of this.targets) {\n            const method = target[methodName];\n            if (method && typeof method === 'function') {\n                const didEndHook = method.apply(target, args);\n                if (didEndHook) {\n                    didEndHooks.push(didEndHook);\n                }\n            }\n        }\n        return (...args) => {\n            didEndHooks.reverse();\n            for (const didEndHook of didEndHooks) {\n                didEndHook(...args);\n            }\n        };\n    }\n}\nexports.Dispatcher = Dispatcher;\n//# sourceMappingURL=dispatcher.js.map"]},"metadata":{},"sourceType":"script"}